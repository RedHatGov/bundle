
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>additional: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/openshift/oc-mirror/v2/pkg/additional/collector.go (43.5%)</option>
				
				<option value="file1">github.com/openshift/oc-mirror/v2/pkg/additional/local_stored_collector.go (0.0%)</option>
				
				<option value="file2">github.com/openshift/oc-mirror/v2/pkg/additional/new.go (0.0%)</option>
				
				<option value="file3">github.com/openshift/oc-mirror/v2/pkg/batch/worker.go (62.3%)</option>
				
				<option value="file4">github.com/openshift/oc-mirror/v2/pkg/cli/executor.go (43.2%)</option>
				
				<option value="file5">github.com/openshift/oc-mirror/v2/pkg/config/defaults.go (100.0%)</option>
				
				<option value="file6">github.com/openshift/oc-mirror/v2/pkg/config/load.go (81.2%)</option>
				
				<option value="file7">github.com/openshift/oc-mirror/v2/pkg/config/validate.go (95.0%)</option>
				
				<option value="file8">github.com/openshift/oc-mirror/v2/pkg/log/logger.go (85.7%)</option>
				
				<option value="file9">github.com/openshift/oc-mirror/v2/pkg/manifest/oci-manifest.go (67.5%)</option>
				
				<option value="file10">github.com/openshift/oc-mirror/v2/pkg/mirror/mirror.go (51.0%)</option>
				
				<option value="file11">github.com/openshift/oc-mirror/v2/pkg/mirror/options.go (61.0%)</option>
				
				<option value="file12">github.com/openshift/oc-mirror/v2/pkg/mirror/unshare.go (30.8%)</option>
				
				<option value="file13">github.com/openshift/oc-mirror/v2/pkg/operator/collector.go (63.6%)</option>
				
				<option value="file14">github.com/openshift/oc-mirror/v2/pkg/operator/local_stored_collector.go (0.0%)</option>
				
				<option value="file15">github.com/openshift/oc-mirror/v2/pkg/operator/new.go (0.0%)</option>
				
				<option value="file16">github.com/openshift/oc-mirror/v2/pkg/release/cincinnati.go (48.8%)</option>
				
				<option value="file17">github.com/openshift/oc-mirror/v2/pkg/release/client.go (84.6%)</option>
				
				<option value="file18">github.com/openshift/oc-mirror/v2/pkg/release/collector.go (63.1%)</option>
				
				<option value="file19">github.com/openshift/oc-mirror/v2/pkg/release/core-cincinnati.go (83.3%)</option>
				
				<option value="file20">github.com/openshift/oc-mirror/v2/pkg/release/find.go (95.8%)</option>
				
				<option value="file21">github.com/openshift/oc-mirror/v2/pkg/release/local_stored_collector.go (79.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package additional

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
)

const (
        indexJson           string = "index.json"
        ociProtocolTrimmed  string = "oci:"
        additionalImagesDir string = "additional-images"
        errMsg              string = "[AdditionalImagesCollector] %v "
)

type Collector struct {
        Log      clog.PluggableLoggerInterface
        Mirror   mirror.MirrorInterface
        Manifest manifest.ManifestInterface
        Config   v1alpha2.ImageSetConfiguration
        Opts     mirror.CopyOptions
}

// AdditionalImagesCollector - this looks into the additional images field
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded in oci format
func (o *Collector) AdditionalImagesCollector(ctx context.Context) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{

        var allImages []v1alpha3.CopyImageSchema

        if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                for _, img := range o.Config.ImageSetConfigurationSpec.Mirror.AdditionalImages </span><span class="cov8" title="1">{
                        irs, err := customImageParser(img.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>
                        <span class="cov8" title="1">cacheDir := strings.Join([]string{o.Opts.Global.Dir, additionalImagesDir, irs.Namespace, irs.Component}, "/")
                        if _, err := os.Stat(cacheDir); errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                                err := os.MkdirAll(cacheDir, 0755)
                                if err != nil </span><span class="cov8" title="1">{
                                        return []v1alpha3.CopyImageSchema{}, nil
                                }</span>
                                <span class="cov0" title="0">src := dockerProtocol + img.Name
                                transport := strings.Split(o.Opts.Destination, "://")[0] + ":"
                                dest := transport + cacheDir
                                o.Log.Debug("source %s", src)
                                o.Log.Debug("destination %s", dest)
                                allImages = append(allImages, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>
                        } else<span class="cov0" title="0"> {
                                o.Log.Info("cache dir exists %s", cacheDir)
                        }</span>
                }
        }

        <span class="cov0" title="0">if o.Opts.Mode == diskToMirror </span><span class="cov0" title="0">{
                regex, e := regexp.Compile(indexJson)
                if e != nil </span><span class="cov0" title="0">{
                        o.Log.Error("%v", e)
                }</span>
                <span class="cov0" title="0">for _, addImg := range o.Config.Mirror.AdditionalImages </span><span class="cov0" title="0">{
                        imagesDir := strings.Replace(addImg.Name, "dir://", "", 1)
                        e = filepath.Walk(imagesDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                                if err == nil &amp;&amp; regex.MatchString(info.Name()) </span><span class="cov0" title="0">{
                                        hld := strings.Split(filepath.Dir(path), additionalImagesDir)
                                        //ref := filepath.Dir(strings.Join(hld, "/"))
                                        src := ociProtocolTrimmed + filepath.Dir(path)
                                        dest := o.Opts.Destination + hld[1]
                                        allImages = append(allImages, v1alpha3.CopyImageSchema{Source: src, Destination: dest})
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        })
                }
                <span class="cov0" title="0">if e != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, e
                }</span>
        }
        <span class="cov0" title="0">return allImages, nil</span>
}

// customImageParser - simple image string parser
func customImageParser(image string) (*v1alpha3.ImageRefSchema, error) <span class="cov8" title="1">{
        var irs *v1alpha3.ImageRefSchema
        var component string
        parts := strings.Split(image, "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return irs, fmt.Errorf("[customImageParser] image url seems to be wrong %s ", image)
        }</span>
        <span class="cov8" title="1">component = parts[2]
        if strings.Contains(parts[2], "@") </span><span class="cov0" title="0">{
                component = strings.Split(parts[2], "@")[0]
        }</span>
        <span class="cov8" title="1">if strings.Contains(parts[2], ":") </span><span class="cov8" title="1">{
                component = strings.Split(parts[2], ":")[0]
        }</span>
        <span class="cov8" title="1">irs = &amp;v1alpha3.ImageRefSchema{Repository: parts[0], Namespace: parts[1], Component: component}
        return irs, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package additional

import (
        "context"
        "fmt"
        "strings"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
)

const (
        hashTruncLen int = 12
)

type LocalStorageCollector struct {
        Log              clog.PluggableLoggerInterface
        Mirror           mirror.MirrorInterface
        Manifest         manifest.ManifestInterface
        Config           v1alpha2.ImageSetConfiguration
        Opts             mirror.CopyOptions
        LocalStorageFQDN string
}

// AdditionalImagesCollector - this looks into the additional images field
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded in oci format
func (o *LocalStorageCollector) AdditionalImagesCollector(ctx context.Context) ([]v1alpha3.CopyImageSchema, error) <span class="cov0" title="0">{

        var allImages []v1alpha3.CopyImageSchema

        if o.Opts.Mode == mirrorToDisk </span><span class="cov0" title="0">{
                for _, img := range o.Config.ImageSetConfigurationSpec.Mirror.AdditionalImages </span><span class="cov0" title="0">{
                        imgRef := img.Name
                        var src string
                        var dest string
                        // no transport was provided, assume docker://
                        if !strings.Contains(src, "://") </span><span class="cov0" title="0">{
                                src = dockerProtocol + imgRef
                        }</span> else<span class="cov0" title="0"> {
                                transportAndRef := strings.Split(imgRef, "://")
                                // because we are reusing this to construct dest
                                imgRef = transportAndRef[1]
                        }</span>

                        <span class="cov0" title="0">if isImageByDigest(imgRef) </span><span class="cov0" title="0">{
                                dest = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, imageName(imgRef) + ":" + imageHash(imgRef)[:hashTruncLen]}, "/")
                        }</span> else<span class="cov0" title="0"> {
                                dest = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, imgRef}, "/")
                        }</span>

                        <span class="cov0" title="0">o.Log.Debug("source %s", src)
                        o.Log.Debug("destination %s", dest)
                        allImages = append(allImages, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>

                }
        }

        <span class="cov0" title="0">if o.Opts.Mode == diskToMirror </span><span class="cov0" title="0">{
                for _, img := range o.Config.ImageSetConfigurationSpec.Mirror.AdditionalImages </span><span class="cov0" title="0">{
                        // TODO Make this more complete
                        // This logic will be useful for operators and releases
                        // strip the domain name from the img.Name
                        var src string
                        var dest string

                        if !strings.HasPrefix(img.Name, ociProtocol) </span><span class="cov0" title="0">{

                                domainAndPathComps := img.Name
                                // pathComponents := img.Name
                                // temporarily strip out the transport
                                transportAndRef := strings.Split(domainAndPathComps, "://")
                                if len(transportAndRef) &gt; 1 </span><span class="cov0" title="0">{
                                        domainAndPathComps = transportAndRef[1]
                                }</span>
                                <span class="cov0" title="0">src = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, img.Name}, "/")

                                if isImageByDigest(img.Name) </span><span class="cov0" title="0">{
                                        dest = strings.Join([]string{o.Opts.Destination, imageName(img.Name) + ":" + imageHash(img.Name)[:hashTruncLen]}, "/")
                                }</span> else<span class="cov0" title="0"> {
                                        dest = strings.Join([]string{o.Opts.Destination, img.Name}, "/")
                                }</span>

                                // the following is for having the destination without the initial domain name =&gt; later
                                // domainAndPathCompsArray := strings.Split(domainAndPathComps, "/")
                                // if len(domainAndPathCompsArray) &gt; 2 {
                                //         pathComponents = strings.Join(domainAndPathCompsArray[1:], "/")
                                // } else {
                                //         return allImages, fmt.Errorf("unable to parse image %s correctly", img.Name)
                                // }
                                // src = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, pathComponents}, "/")
                                // dst = strings.Join([]string{o.Opts.Destination, pathComponents}, "/") // already has a transport protocol

                        } else<span class="cov0" title="0"> {
                                src = img.Name
                                transportAndPath := strings.Split(img.Name, "://")
                                dest = dockerProtocol + strings.Join([]string{o.Opts.Destination, transportAndPath[1]}, "/")
                        }</span>

                        <span class="cov0" title="0">if src == "" || dest == "" </span><span class="cov0" title="0">{
                                return allImages, fmt.Errorf("unable to determine src %s or dst %s for %s", src, dest, img.Name)
                        }</span>

                        <span class="cov0" title="0">o.Log.Debug("source %s", src)
                        o.Log.Debug("destination %s", dest)
                        allImages = append(allImages, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>
                }
        }
        <span class="cov0" title="0">return allImages, nil</span>
}

func isImageByDigest(imgRef string) bool <span class="cov0" title="0">{
        return strings.Contains(imgRef, "@")
}</span>

func imageName(imgRef string) string <span class="cov0" title="0">{
        var imageName string
        imgSplit := strings.Split(imgRef, "@")
        if len(imgSplit) &gt; 1 </span><span class="cov0" title="0">{
                imageName = imgSplit[0]
        }</span>

        <span class="cov0" title="0">return imageName</span>
}

func imageHash(imgRef string) string <span class="cov0" title="0">{
        var hash string
        imgSplit := strings.Split(imgRef, "@")
        if len(imgSplit) &gt; 1 </span><span class="cov0" title="0">{
                hash = strings.Split(imgSplit[1], ":")[1]
        }</span>

        <span class="cov0" title="0">return hash</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package additional

import (
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
)


func New(log clog.PluggableLoggerInterface,
                config v1alpha2.ImageSetConfiguration,
                opts mirror.CopyOptions,
                mirror mirror.MirrorInterface,
                manifest manifest.ManifestInterface,
                localStorageFQDN string,
) CollectorInterface <span class="cov0" title="0">{
        if localStorageFQDN != "" </span><span class="cov0" title="0">{
                return &amp;LocalStorageCollector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest, LocalStorageFQDN: localStorageFQDN}
        }</span> else<span class="cov0" title="0"> {
                return &amp;Collector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest}
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package batch

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "strconv"
        "strings"
        "sync"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
)

const (
        BATCH_SIZE int    = 8
        logFile    string = "logs/worker-{batch}.log"
)

type BatchInterface interface {
        Worker(ctx context.Context, images []v1alpha3.CopyImageSchema, opts mirror.CopyOptions) error
}

func New(log clog.PluggableLoggerInterface,
        mirror mirror.MirrorInterface,
        manifest manifest.ManifestInterface,
) BatchInterface <span class="cov8" title="1">{
        return &amp;Batch{Log: log, Mirror: mirror, Manifest: manifest}
}</span>

type Batch struct {
        Log      clog.PluggableLoggerInterface
        Mirror   mirror.MirrorInterface
        Manifest manifest.ManifestInterface
}

type BatchSchema struct {
        Writer     io.Writer
        CopyImages []v1alpha3.RelatedImage
        Items      int
        Count      int
        BatchSize  int
        BatchIndex int
        Remainder  int
}

// Worker - the main batch processor
func (o *Batch) Worker(ctx context.Context, images []v1alpha3.CopyImageSchema, opts mirror.CopyOptions) error <span class="cov8" title="1">{

        var errArray []error
        var wg sync.WaitGroup
        var err error

        var b *BatchSchema
        imgs := len(images)
        if imgs &lt; BATCH_SIZE </span><span class="cov8" title="1">{
                b = &amp;BatchSchema{Items: imgs, Count: 1, BatchSize: imgs, BatchIndex: 0, Remainder: 0}
        }</span> else<span class="cov0" title="0"> {
                b = &amp;BatchSchema{Items: imgs, Count: (imgs / BATCH_SIZE), BatchSize: BATCH_SIZE, Remainder: (imgs % BATCH_SIZE)}
        }</span>

        <span class="cov8" title="1">o.Log.Info("images to mirror %d ", b.Items)
        o.Log.Info("batch count %d ", b.Count)
        o.Log.Info("batch index %d ", b.BatchIndex)
        o.Log.Info("batch size %d ", b.BatchSize)
        o.Log.Info("remainder size %d ", b.Remainder)

        f := make([]*os.File, b.Count)
        //f, err := make([]os.File)
        // prepare batching
        wg.Add(b.BatchSize)
        for i := 0; i &lt; b.Count; i++ </span><span class="cov8" title="1">{
                // create a log file for each batch
                f[i], err = os.Create(strings.Replace(logFile, "{batch}", strconv.Itoa(i), -1))
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error("[Worker] %v", err)
                }</span>
                <span class="cov8" title="1">writer := bufio.NewWriter(f[i])
                o.Log.Info(fmt.Sprintf("starting batch %d ", i))
                for x := 0; x &lt; b.BatchSize; x++ </span><span class="cov8" title="1">{
                        index := (i * b.BatchSize) + x
                        o.Log.Debug("source %s ", images[index].Source)
                        o.Log.Debug("destination %s ", images[index].Destination)
                        opts.MultiArch = "all"
                        go func(ctx context.Context, src, dest string, opts *mirror.CopyOptions, writer bufio.Writer) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                err := o.Mirror.Run(ctx, src, dest, "copy", opts, writer)
                                if err != nil </span><span class="cov0" title="0">{
                                        errArray = append(errArray, err)
                                }</span>
                        }(ctx, images[index].Source, images[index].Destination, &amp;opts, *writer)
                }
                <span class="cov8" title="1">wg.Wait()
                // rather than use defer Close we intentianally close the log files
                for _, f := range f </span><span class="cov8" title="1">{
                        f.Close()
                }</span>
                <span class="cov8" title="1">o.Log.Info("completed batch %d", i)
                if b.Count &gt; 1 </span><span class="cov0" title="0">{
                        wg.Add(BATCH_SIZE)
                }</span>
                <span class="cov8" title="1">if len(errArray) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errArray </span><span class="cov0" title="0">{
                                o.Log.Error("[Worker] errArray %v", err)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("[Worker] error in batch - refer to console logs")</span>
                }
        }
        <span class="cov8" title="1">if b.Remainder &gt; 0 </span><span class="cov0" title="0">{
                // one level of simple recursion
                i := b.Count * BATCH_SIZE
                o.Log.Info("executing remainder [batch size of 1]")
                err := o.Worker(ctx, images[i:], opts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // output the logs to console
                <span class="cov0" title="0">if !opts.Global.Quiet </span><span class="cov0" title="0">{
                        consoleLogFromFile(o.Log)
                }</span>
                <span class="cov0" title="0">o.Log.Info("[Worker] successfully completed all batches")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// consoleLogFromFile
func consoleLogFromFile(log clog.PluggableLoggerInterface) <span class="cov0" title="0">{
        dir, _ := os.ReadDir("logs")
        for _, f := range dir </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), "worker") </span><span class="cov0" title="0">{
                        log.Debug("[batch] %s ", f.Name())
                        data, _ := os.ReadFile("logs/" + f.Name())
                        lines := strings.Split(string(data), "\n")
                        for _, s := range lines </span><span class="cov0" title="0">{
                                if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                        // clean the line
                                        log.Debug("%s ", strings.ToLower(s))
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cli

import (
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "k8s.io/kubectl/pkg/util/templates"

        "github.com/distribution/distribution/v3/configuration"
        dcontext "github.com/distribution/distribution/v3/context"
        "github.com/distribution/distribution/v3/registry"
        _ "github.com/distribution/distribution/v3/registry/storage/driver/filesystem"
        distversion "github.com/distribution/distribution/v3/version"
        "github.com/sirupsen/logrus"

        "github.com/google/uuid"

        "github.com/openshift/oc-mirror/v2/pkg/additional"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        "github.com/openshift/oc-mirror/v2/pkg/batch"
        "github.com/openshift/oc-mirror/v2/pkg/config"
        "github.com/openshift/oc-mirror/v2/pkg/diff"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
        "github.com/openshift/oc-mirror/v2/pkg/operator"
        "github.com/openshift/oc-mirror/v2/pkg/release"
        "github.com/spf13/cobra"
)

const (
        dockerProtocol          string = "docker://"
        ociProtocol             string = "oci://"
        dirProtocol             string = "dir://"
        fileProtocol            string = "file://"
        diskToMirror            string = "diskToMirror"
        mirrorToDisk            string = "mirrorToDisk"
        releaseImageDir         string = "release-images"
        logsDir                 string = "logs"
        workingDir              string = "working-dir"
        additionalImages        string = "additional-images"
        releaseImageExtractDir  string = "hold-release"
        operatorImageExtractDir string = "hold-operator"
        signaturesDir           string = "signatures"
        registryLogFilename     string = "logs/registry.log"
)

var (
        mirrorlongDesc = templates.LongDesc(
                ` 
                Create and publish user-configured mirrors with a declarative configuration input.
                used for authenticating to the registries. 

                The podman location for credentials is also supported as a secondary location.

                1. Destination prefix is docker:// - The current working directory will be used.
                2. Destination prefix is oci:// - The destination directory specified will be used.

                `,
        )
        mirrorExamples = templates.Examples(
                `
                # Mirror to a directory
                oc-mirror oci:mirror --config mirror-config.yaml
                `,
        )
        registryLogFile *os.File
)

type ExecutorSchema struct {
        Log              clog.PluggableLoggerInterface
        Config           v1alpha2.ImageSetConfiguration
        MetaData         diff.SequenceSchema
        Opts             mirror.CopyOptions
        Operator         operator.CollectorInterface
        Release          release.CollectorInterface
        AdditionalImages additional.CollectorInterface
        Mirror           mirror.MirrorInterface
        Manifest         manifest.ManifestInterface
        Batch            batch.BatchInterface
        Diff             diff.DiffInterface
        LocalStorage     registry.Registry
        LocalStorageFQDN string
}

// NewMirrorCmd - cobra entry point
func NewMirrorCmd(log clog.PluggableLoggerInterface) *cobra.Command <span class="cov8" title="1">{

        global := &amp;mirror.GlobalOptions{
                TlsVerify:      false,
                InsecurePolicy: true,
        }

        flagSharedOpts, sharedOpts := mirror.SharedImageFlags()
        flagDepTLS, deprecatedTLSVerifyOpt := mirror.DeprecatedTLSVerifyFlags()
        flagSrcOpts, srcOpts := mirror.ImageSrcFlags(global, sharedOpts, deprecatedTLSVerifyOpt, "src-", "screds")
        flagDestOpts, destOpts := mirror.ImageDestFlags(global, sharedOpts, deprecatedTLSVerifyOpt, "dest-", "dcreds")
        flagRetryOpts, retryOpts := mirror.RetryFlags()

        opts := mirror.CopyOptions{
                Global:              global,
                DeprecatedTLSVerify: deprecatedTLSVerifyOpt,
                SrcImage:            srcOpts,
                DestImage:           destOpts,
                RetryOpts:           retryOpts,
                Dev:                 false,
        }

        ex := &amp;ExecutorSchema{
                Log:  log,
                Opts: opts,
        }

        cmd := &amp;cobra.Command{
                Use:           fmt.Sprintf("%v &lt;destination type&gt;:&lt;destination location&gt;", filepath.Base(os.Args[0])),
                Version:       "v2.0.0-dev-01",
                Short:         "Manage mirrors per user configuration",
                Long:          mirrorlongDesc,
                Example:       mirrorExamples,
                Args:          cobra.MinimumNArgs(1),
                SilenceErrors: false,
                SilenceUsage:  false,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        err := ex.Validate(args)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("%v ", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">ex.Complete(args)
                        // prepare internal storage
                        err = ex.PrepareStorageAndLogs()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(" %v ", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">err = ex.Run(cmd, args)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("%v ", err)
                                os.Exit(1)
                        }</span>
                },
        }

        <span class="cov8" title="1">cmd.PersistentFlags().StringVarP(&amp;opts.Global.ConfigPath, "config", "c", "", "Path to imageset configuration file")
        cmd.Flags().StringVar(&amp;opts.Global.LogLevel, "loglevel", "info", "Log level one of (info, debug, trace, error)")
        cmd.Flags().StringVar(&amp;opts.Global.Dir, "dir", "working-dir", "Assets directory")
        cmd.Flags().StringVar(&amp;opts.Global.From, "from", "working-dir", "local storage directory for disk to mirror workflow")
        cmd.Flags().Uint16VarP(&amp;opts.Global.Port, "port", "p", 5000, "HTTP port used by oc-mirror's local storage instance")
        cmd.Flags().BoolVarP(&amp;opts.Global.Quiet, "quiet", "q", false, "enable detailed logging when copying images")
        cmd.Flags().BoolVarP(&amp;opts.Global.Force, "force", "f", false, "force the copy and mirror functionality")
        cmd.Flags().BoolVar(&amp;opts.Global.V2, "v2", opts.Global.V2, "Redirect the flow to oc-mirror v2 - PLEASE DO NOT USE that. V2 is still under development and it is not ready to be used.")
        cmd.Flags().MarkHidden("v2")
        cmd.Flags().AddFlagSet(&amp;flagSharedOpts)
        cmd.Flags().AddFlagSet(&amp;flagRetryOpts)
        cmd.Flags().AddFlagSet(&amp;flagDepTLS)
        cmd.Flags().AddFlagSet(&amp;flagSrcOpts)
        cmd.Flags().AddFlagSet(&amp;flagDestOpts)
        return cmd</span>
}

// Validate - cobra validation
func (o *ExecutorSchema) Validate(dest []string) error <span class="cov8" title="1">{
        if len(o.Opts.Global.ConfigPath) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("use the --config flag it is mandatory")
        }</span>
        <span class="cov8" title="1">if strings.Contains(dest[0], dockerProtocol) &amp;&amp; o.Opts.Global.From == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("when destination is file://, diskToMirror workflow is assumed, and the --from argument become mandatory")

        }</span>
        <span class="cov8" title="1">if strings.Contains(dest[0], fileProtocol) || strings.Contains(dest[0], dockerProtocol) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("destination must have either file:// (mirror to disk) or docker:// (diskToMirror) protocol prefixes")
        }</span>
}

func (o *ExecutorSchema) PrepareStorageAndLogs() error <span class="cov0" title="0">{

        // clean up logs directory
        os.RemoveAll(logsDir)

        // create logs directory
        err := os.MkdirAll(logsDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        //create config file for local registry
        <span class="cov0" title="0">configYamlV0_1 := `
version: 0.1
log:
  accesslog:
    disabled: $$PLACEHOLDER_ACCESS_LOG_OFF$$
  level: $$PLACEHOLDER_LOG_LEVEL$$
  formatter: text
  fields:
    service: registry
storage:
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: $$PLACEHOLDER_ROOT$$
http:
  addr: :$$PLACEHOLDER_PORT$$
  headers:
    X-Content-Type-Options: [nosniff]
      #auth:
      #htpasswd:
      #realm: basic-realm
      #path: /etc/registry
health:
  storagedriver:
    enabled: true
    interval: 10s
    threshold: 3
`

        rootDir := ""

        if o.Opts.Mode == mirrorToDisk </span><span class="cov0" title="0">{
                rootDir = strings.TrimPrefix(o.Opts.Destination, fileProtocol)
        }</span> else<span class="cov0" title="0"> {
                rootDir = strings.TrimPrefix(o.Opts.Global.From, fileProtocol)
        }</span>

        <span class="cov0" title="0">if rootDir == "" </span><span class="cov0" title="0">{
                // something went wrong
                return fmt.Errorf("error determining the local storage folder to use")
        }</span>
        <span class="cov0" title="0">configYamlV0_1 = strings.Replace(configYamlV0_1, "$$PLACEHOLDER_ROOT$$", rootDir, 1)
        configYamlV0_1 = strings.Replace(configYamlV0_1, "$$PLACEHOLDER_PORT$$", strconv.Itoa(int(o.Opts.Global.Port)), 1)
        configYamlV0_1 = strings.Replace(configYamlV0_1, "$$PLACEHOLDER_LOG_LEVEL$$", o.Opts.Global.LogLevel, 1)
        if o.Opts.Global.LogLevel == "debug" </span><span class="cov0" title="0">{
                configYamlV0_1 = strings.Replace(configYamlV0_1, "$$PLACEHOLDER_ACCESS_LOG_OFF$$", "false", 1)
        }</span> else<span class="cov0" title="0"> {
                configYamlV0_1 = strings.Replace(configYamlV0_1, "$$PLACEHOLDER_ACCESS_LOG_OFF$$", "true", 1)
        }</span>

        <span class="cov0" title="0">config, err := configuration.Parse(bytes.NewReader([]byte(configYamlV0_1)))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing local storage configuration : %v\n %s", err, configYamlV0_1)
        }</span>

        <span class="cov0" title="0">regLogger := logrus.New()
        // prepare the logger
        registryLogFile, err = os.Create(registryLogFilename)
        if err != nil </span><span class="cov0" title="0">{
                regLogger.Warn("Failed to create log file for local storage registry, using default stderr")
        }</span> else<span class="cov0" title="0"> {
                regLogger.Out = registryLogFile
        }</span>
        <span class="cov0" title="0">absPath, err := filepath.Abs(registryLogFilename)
        o.Log.Info("local storage registry will log to %s", absPath)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(err.Error())
        }</span>
        <span class="cov0" title="0">regLogEntry := logrus.NewEntry(regLogger)

        // setup the context
        dcontext.SetDefaultLogger(regLogEntry)
        ctx := dcontext.WithVersion(dcontext.Background(), distversion.Version)
        ctx = dcontext.WithLogger(ctx, regLogEntry)

        reg, err := registry.NewRegistry(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">o.LocalStorage = *reg
        errchan := make(chan error)

        o.Log.Info("starting local storage on %v", config.HTTP.Addr)

        go startLocalRegistry(reg, errchan)
        go panicOnRegistryError(errchan)
        return nil</span>
}

func startLocalRegistry(reg *registry.Registry, errchan chan error) <span class="cov0" title="0">{
        err := reg.ListenAndServe()
        errchan &lt;- err
}</span>

func panicOnRegistryError(errchan chan error) <span class="cov0" title="0">{
        err := &lt;-errchan
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// Complete - do the final setup of modules
func (o *ExecutorSchema) Complete(args []string) <span class="cov0" title="0">{
        // override log level
        o.Log.Level(o.Opts.Global.LogLevel)
        o.Log.Debug("imagesetconfig file %s ", o.Opts.Global.ConfigPath)
        // read the ImageSetConfiguration
        cfg, err := config.ReadConfig(o.Opts.Global.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("imagesetconfig %v ", err)
        }</span>
        <span class="cov0" title="0">o.Log.Trace("imagesetconfig : %v ", cfg)

        // update all dependant modules
        mc := mirror.NewMirrorCopy()
        md := mirror.NewMirrorDelete()
        o.Manifest = manifest.New(o.Log)
        o.Mirror = mirror.New(mc, md)
        o.Config = cfg
        o.Batch = batch.New(o.Log, o.Mirror, o.Manifest)

        // logic to check mode
        var dest string
        if strings.Contains(args[0], fileProtocol) </span><span class="cov0" title="0">{
                o.Opts.Mode = mirrorToDisk
                dest = workingDir + "/" + strings.Split(args[0], "://")[1]
                o.Log.Debug("destination %s ", dest)
        }</span> else<span class="cov0" title="0"> if strings.Contains(args[0], dockerProtocol) </span><span class="cov0" title="0">{
                dest = workingDir
                o.Opts.Mode = diskToMirror
        }</span> else<span class="cov0" title="0"> {
                o.Log.Error("unable to determine the mode (the destination must be either file:// or docker://)")
        }</span>
        <span class="cov0" title="0">o.Opts.Destination = args[0]
        o.Opts.Global.Dir = dest
        o.Log.Info("mode %s ", o.Opts.Mode)
        o.LocalStorageFQDN = "localhost:" + strconv.Itoa(int(o.Opts.Global.Port))

        client, _ := release.NewOCPClient(uuid.New())

        signature := release.NewSignatureClient(o.Log, &amp;o.Config, &amp;o.Opts)
        cn := release.NewCincinnati(o.Log, &amp;o.Config, &amp;o.Opts, client, false, signature)
        o.Release = release.NewWithLocalStorage(o.Log, o.Config, o.Opts, o.Mirror, o.Manifest, cn, o.LocalStorageFQDN)
        o.Operator = operator.New(o.Log, o.Config, o.Opts, o.Mirror, o.Manifest, o.LocalStorageFQDN)
        o.AdditionalImages = additional.New(o.Log, o.Config, o.Opts, o.Mirror, o.Manifest, o.LocalStorageFQDN)</span>

}

// Run - start the mirror functionality
func (o *ExecutorSchema) Run(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        startTime := time.Now()
        // clean up logs directory
        os.RemoveAll(logsDir)

        // create logs directory
        err := os.MkdirAll(logsDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        <span class="cov8" title="1">if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                // ensure working dir exists
                err := os.MkdirAll(workingDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        o.Log.Error(" %v ", err)
                        return err
                }</span>

                // create signatures directory
                <span class="cov8" title="1">o.Log.Trace("creating signatures directory %s ", o.Opts.Global.Dir+"/"+signaturesDir)
                err = os.MkdirAll(o.Opts.Global.Dir+"/"+signaturesDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        o.Log.Error(" %v ", err)
                        return err
                }</span>

                // create release-images directory
                <span class="cov8" title="1">o.Log.Trace("creating release images directory %s ", o.Opts.Global.Dir+"/"+releaseImageDir)
                err = os.MkdirAll(o.Opts.Global.Dir+"/"+releaseImageDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        o.Log.Error(" %v ", err)
                        return err
                }</span>

                // create release cache dir
                <span class="cov8" title="1">o.Log.Trace("creating release cache directory %s ", o.Opts.Global.Dir+"/"+releaseImageExtractDir)
                err = os.MkdirAll(o.Opts.Global.Dir+"/"+releaseImageExtractDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        o.Log.Error(" %v ", err)
                        return err
                }</span>

                // create operator cache dir
                <span class="cov8" title="1">o.Log.Trace("creating operator cache directory %s ", o.Opts.Global.Dir+"/"+operatorImageExtractDir)
                err = os.MkdirAll(o.Opts.Global.Dir+"/"+operatorImageExtractDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        o.Log.Error(" %v ", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">var allRelatedImages []v1alpha3.CopyImageSchema

        // do releases
        imgs, err := o.Release.ReleaseImageCollector(cmd.Context())
        if err != nil </span><span class="cov8" title="1">{
                cleanUp()
                return err
        }</span>
        <span class="cov8" title="1">o.Log.Info("total release images to copy %d ", len(imgs))
        o.Opts.ImageType = "release"
        allRelatedImages = mergeImages(allRelatedImages, imgs)

        // do operators
        imgs, err = o.Operator.OperatorImageCollector(cmd.Context())
        if err != nil </span><span class="cov8" title="1">{
                cleanUp()
                return err
        }</span>
        <span class="cov8" title="1">o.Log.Info("total operator images to copy %d ", len(imgs))
        o.Opts.ImageType = "operator"
        allRelatedImages = mergeImages(allRelatedImages, imgs)

        // do additionalImages
        imgs, err = o.AdditionalImages.AdditionalImagesCollector(cmd.Context())
        if err != nil </span><span class="cov0" title="0">{
                cleanUp()
                return err
        }</span>
        <span class="cov8" title="1">o.Log.Info("total additional images to copy %d ", len(imgs))
        allRelatedImages = mergeImages(allRelatedImages, imgs)

        collectionFinish := time.Now()

        //call the batch worker
        err = o.Batch.Worker(cmd.Context(), allRelatedImages, o.Opts)
        mirrorFinish := time.Now()
        o.Log.Info("start time: %v\ncollection time: %v\nmirror time: %v", startTime, collectionFinish, mirrorFinish)
        if err != nil </span><span class="cov8" title="1">{
                cleanUp()
                return err
        }</span>

        <span class="cov8" title="1">defer cleanUp()
        return nil</span>
}

// mergeImages - simple function to append related images
// nolint
func mergeImages(base, in []v1alpha3.CopyImageSchema) []v1alpha3.CopyImageSchema <span class="cov8" title="1">{
        base = append(base, in...)
        return base
}</span>

// cleanUp - utility to clean directories
func cleanUp() <span class="cov8" title="1">{
        // close registry log file
        err := registryLogFile.Close()
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, "error closing log file %s: %v\n", registryLogFilename, err)
        }</span>
        // clean up logs directory
        <span class="cov8" title="1">os.RemoveAll(logsDir)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
)

// Complete set default values in the ImageSetConfiguration
// when applicable
func Complete(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        completeReleaseArchitectures(cfg)
}</span>

func completeReleaseArchitectures(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        if len(cfg.Mirror.Platform.Channels) != 0 &amp;&amp; len(cfg.Mirror.Platform.Architectures) == 0 </span><span class="cov8" title="1">{
                cfg.Mirror.Platform.Architectures = []string{v1alpha2.DefaultPlatformArchitecture}
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/yaml"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
)

// TODO(estroz): create interface scheme such that configuration and metadata
// versions do not matter to the caller.
// See https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/config/config.go

// ReadConfig opens an imageset configuration file at the given path
// and loads it into a v1alpha2.ImageSetConfiguration instance for processing and validation.
func ReadConfig(configPath string) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov8" title="1">{

        data, err := os.ReadFile(filepath.Clean(configPath))
        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>
        <span class="cov8" title="1">typeMeta, err := getTypeMeta(data)

        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov8" title="1">switch typeMeta.GroupVersionKind() </span>{
        case v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind):<span class="cov8" title="1">
                c, err = LoadConfig(data)
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>
        default:<span class="cov0" title="0">
                return c, fmt.Errorf("config GVK not recognized: %s", typeMeta.GroupVersionKind())</span>
        }

        <span class="cov8" title="1">Complete(&amp;c)

        return c, Validate(&amp;c)</span>
}

// LoadConfig loads data into a v1alpha2.ImageSetConfiguration instance
func LoadConfig(data []byte) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind)

        if data, err = yaml.YAMLToJSON(data); err != nil </span><span class="cov0" title="0">{
                return c, fmt.Errorf("yaml to json %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;c); err != nil </span><span class="cov8" title="1">{
                return c, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">c.SetGroupVersionKind(gvk)

        return c, nil</span>
}

// LoadMetadata loads data into a v1alpha2.Metadata instance
func LoadMetadata(data []byte) (m v1alpha2.Metadata, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.MetadataKind)

        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;m); err != nil </span><span class="cov8" title="1">{
                return m, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">m.SetGroupVersionKind(gvk)

        return m, nil</span>
}

func getTypeMeta(data []byte) (typeMeta metav1.TypeMeta, err error) <span class="cov8" title="1">{
        if err := yaml.Unmarshal(data, &amp;typeMeta); err != nil </span><span class="cov0" title="0">{
                return typeMeta, fmt.Errorf("get type meta: %v", err)
        }</span>
        <span class="cov8" title="1">return typeMeta, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"

        utilerrors "k8s.io/apimachinery/pkg/util/errors"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
)

type validationFunc func(cfg *v1alpha2.ImageSetConfiguration) error

var validationChecks = []validationFunc{validateOperatorOptions, validateReleaseChannels}

// Validate will check an ImagesetConfiguration for input errors.
func Validate(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        var errs []error
        for _, check := range validationChecks </span><span class="cov8" title="1">{
                if err := check(cfg); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("invalid configuration: %v", err))
                }</span>
        }
        <span class="cov8" title="1">return utilerrors.NewAggregate(errs)</span>
}

func validateOperatorOptions(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, ctlg := range cfg.Mirror.Operators </span><span class="cov8" title="1">{
                ctlgName, err := ctlg.GetUniqueName()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if seen[ctlgName] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "catalog %q: duplicate found in configuration", ctlgName,
                        )
                }</span>
                <span class="cov8" title="1">seen[ctlgName] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateReleaseChannels(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, channel := range cfg.Mirror.Platform.Channels </span><span class="cov8" title="1">{
                if seen[channel.Name] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "release channel %q: duplicate found in configuration", channel.Name,
                        )
                }</span>
                <span class="cov8" title="1">seen[channel.Name] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package log

import (
        "fmt"

        "github.com/microlib/simple"
)

// PluggableLoggerInterface - allows us to use other logging systems
// as long as the interface implementation is adhered to
type PluggableLoggerInterface interface {
        Error(msg string, val ...interface{})
        Info(msg string, val ...interface{})
        Debug(msg string, val ...interface{})
        Trace(msg string, val ...interface{})
        Warn(msg string, val ...interface{})
        Level(levele string)
}

// PluggableLogger
type PluggableLogger struct {
        Log *simple.Logger
}

// New - returns a new PluggableLogger instance
func New(level string) PluggableLoggerInterface <span class="cov8" title="1">{
        return &amp;PluggableLogger{Log: &amp;simple.Logger{Level: level}}
}</span>

// Error
func (c *PluggableLogger) Error(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Error(fmt.Sprintf(msg, val...))
}</span>

// Info
func (c *PluggableLogger) Info(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Info(fmt.Sprintf(msg, val...))
}</span>

// Debug
func (c *PluggableLogger) Debug(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Debug(fmt.Sprintf(msg, val...))
}</span>

// Trace
func (c *PluggableLogger) Trace(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Trace(fmt.Sprintf(msg, val...))
}</span>

// Warn
func (c *PluggableLogger) Warn(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Warn(fmt.Sprintf(msg, val...))
}</span>

// Level - ovveride log level
func (c *PluggableLogger) Level(level string) <span class="cov0" title="0">{
        c.Log.Level = level
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package manifest

import (
        "archive/tar"
        "compress/gzip"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/blang/semver/v4"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "k8s.io/klog/v2"
)

const (
        index                   string = "index.json"
        catalogJson             string = "catalog.json"
        operatorImageExtractDir string = "hold-operator"
        errorSemver             string = " semver %v "
)

type ManifestInterface interface {
        GetImageIndex(dir string) (*v1alpha3.OCISchema, error)
        GetImageManifest(file string) (*v1alpha3.OCISchema, error)
        GetOperatorConfig(file string) (*v1alpha3.OperatorConfigSchema, error)
        GetRelatedImagesFromCatalog(filePath, label string) (map[string][]v1alpha3.RelatedImage, error)
        GetRelatedImagesFromCatalogByFilter(filePath, label string, op v1alpha2.Operator, mp map[string]v1alpha3.ISCPackage) (map[string][]v1alpha3.RelatedImage, error)
        ExtractLayersOCI(filePath, toPath, label string, oci *v1alpha3.OCISchema) error
        GetReleaseSchema(filePath string) ([]v1alpha3.RelatedImage, error)
}

type Manifest struct {
        Log clog.PluggableLoggerInterface
}

func New(log clog.PluggableLoggerInterface) ManifestInterface <span class="cov0" title="0">{
        return &amp;Manifest{Log: log}
}</span>

// GetImageIndex - used to get the oci index.json
func (o *Manifest) GetImageIndex(dir string) (*v1alpha3.OCISchema, error) <span class="cov8" title="1">{
        var oci *v1alpha3.OCISchema
        indx, err := os.ReadFile(dir + "/" + index)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(indx, &amp;oci)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return oci, nil</span>
}

// GetImageManifest used to ge the manifest in the oci blobs/sha254
// directory - found in index.json
func (o *Manifest) GetImageManifest(file string) (*v1alpha3.OCISchema, error) <span class="cov8" title="1">{
        var oci *v1alpha3.OCISchema
        manifest, err := os.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(manifest, &amp;oci)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return oci, nil</span>
}

// GetOperatorConfig used to parse the operator json
func (o *Manifest) GetOperatorConfig(file string) (*v1alpha3.OperatorConfigSchema, error) <span class="cov8" title="1">{
        var ocs *v1alpha3.OperatorConfigSchema
        manifest, err := os.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(manifest, &amp;ocs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ocs, nil</span>
}

// operatorImageExtractDir + "/" + label
// GetRelatedImagesFromCatalog
func (o *Manifest) GetRelatedImagesFromCatalog(filePath, label string) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        files, err := os.ReadDir(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return relatedImages, err
        }</span>
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                // the catalog.json - does not really conform to json standards
                // this needs some thorough testing
                olm, err := readOperatorCatalog(filePath + "/" + file.Name())
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>
                <span class="cov8" title="1">ri, err := getRelatedImageByDefaultChannel(o.Log, olm)
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>
                // append to relatedImages map
                <span class="cov8" title="1">for k, v := range ri </span><span class="cov8" title="1">{
                        relatedImages[k] = v
                }</span>
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// GetRelatedImagesFromCatalogByFilter
func (o *Manifest) GetRelatedImagesFromCatalogByFilter(filePath, label string, op v1alpha2.Operator, mp map[string]v1alpha3.ISCPackage) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        for _, pkg := range op.Packages </span><span class="cov8" title="1">{
                // the catalog.json - does not really conform to json standards
                // this needs some thorough testing
                olm, err := readOperatorCatalog(filePath + "/" + label + "/" + pkg.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>

                <span class="cov8" title="1">ri, err := getRelatedImageByFilter(o.Log, olm, mp[pkg.Name])
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>
                // append to reletedImages map
                <span class="cov8" title="1">for k, v := range ri </span><span class="cov8" title="1">{
                        relatedImages[k] = v
                }</span>
                <span class="cov8" title="1">o.Log.Trace("related images %v", relatedImages)</span>
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// ExtractLayersOCI
func (o *Manifest) ExtractLayersOCI(fromPath, toPath, label string, oci *v1alpha3.OCISchema) error <span class="cov8" title="1">{
        if _, err := os.Stat(toPath + "/" + label); errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                for _, blob := range oci.Layers </span><span class="cov0" title="0">{
                        if !strings.Contains(blob.Digest, "sha256") </span><span class="cov0" title="0">{
                                return fmt.Errorf("the digest format is not correct %s ", blob.Digest)
                        }</span>
                        <span class="cov0" title="0">f, err := os.Open(fromPath + "/" + strings.Split(blob.Digest, ":")[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = untar(f, toPath, label)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                o.Log.Info("extract directory exists (nop)")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetReleaseSchema
func (o *Manifest) GetReleaseSchema(filePath string) ([]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        var release = v1alpha3.ReleaseSchema{}

        file, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.RelatedImage{}, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal([]byte(file), &amp;release)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.RelatedImage{}, err
        }</span>

        <span class="cov8" title="1">var allImages []v1alpha3.RelatedImage
        for _, item := range release.Spec.Tags </span><span class="cov8" title="1">{
                allImages = append(allImages, v1alpha3.RelatedImage{Image: item.From.Name, Name: item.Name})
        }</span>
        <span class="cov8" title="1">return allImages, nil</span>
}

// UntarLayers simple function that untars the image layers
func untar(gzipStream io.Reader, path string, cfgDirName string) error <span class="cov0" title="0">{
        //Remove any separators in cfgDirName as received from the label
        cfgDirName = strings.TrimSuffix(cfgDirName, "/")
        cfgDirName = strings.TrimPrefix(cfgDirName, "/")
        uncompressedStream, err := gzip.NewReader(gzipStream)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("untar: gzipStream - %w", err)
        }</span>

        <span class="cov0" title="0">tarReader := tar.NewReader(uncompressedStream)
        for </span><span class="cov0" title="0">{
                header, err := tarReader.Next()

                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("untar: Next() failed: %s", err.Error())
                }</span>

                <span class="cov0" title="0">if strings.Contains(header.Name, cfgDirName) </span><span class="cov0" title="0">{
                        switch header.Typeflag </span>{
                        case tar.TypeDir:<span class="cov0" title="0">
                                if header.Name != "./" </span><span class="cov0" title="0">{
                                        if err := os.MkdirAll(path+"/"+header.Name, 0755); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("untar: Mkdir() failed: %v", err)
                                        }</span>
                                }
                        case tar.TypeReg:<span class="cov0" title="0">
                                outFile, err := os.Create(path + "/" + header.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("untar: Create() failed: %v", err)
                                }</span>
                                <span class="cov0" title="0">if _, err := io.Copy(outFile, tarReader); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("untar: Copy() failed: %v", err)
                                }</span>
                                <span class="cov0" title="0">outFile.Close()</span>

                        default:<span class="cov0" title="0">
                                // just ignore errors as we are only interested in the FB configs layer
                                klog.Warningf("untar: unknown type: %v in %s", header.Typeflag, header.Name)</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// readOperatorCatalog - simple function tha treads the specific catalog.json file
// and unmarshals it to DeclarativeConfig struct
func readOperatorCatalog(path string) ([]v1alpha3.DeclarativeConfig, error) <span class="cov8" title="1">{
        // the catalog.json - dos not really conform to json standards
        // this needs some thorough testing
        // operatorImageExtractDir + "/" + label + "/" + name + "/" + catalogJson
        var olm []v1alpha3.DeclarativeConfig
        data, err := os.ReadFile(path + "/" + catalogJson)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.DeclarativeConfig{}, err
        }</span>
        <span class="cov8" title="1">tmp := strings.NewReplacer(" ", "").Replace(string(data))
        updatedJson := "[" + strings.ReplaceAll(tmp, "}\n{", "},{") + "]"
        err = json.Unmarshal([]byte(updatedJson), &amp;olm)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.DeclarativeConfig{}, err
        }</span>
        <span class="cov8" title="1">return olm, nil</span>
}

// getRelatedImageByDefaultChannel - get the DeclarativeConfig for the default channel
// it returns the HEAD (latest version of the bundles relatedImages)
func getRelatedImageByDefaultChannel(log clog.PluggableLoggerInterface, olm []v1alpha3.DeclarativeConfig) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        // relevant variables
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        bundles := make(map[string]bool)
        var defaultChannel string

        // iterate through the catalog objects
        for i, obj := range olm </span><span class="cov8" title="1">{
                switch </span>{
                case obj.Schema == "olm.channel":<span class="cov8" title="1">
                        if defaultChannel == obj.Name </span><span class="cov8" title="1">{
                                log.Debug("found channel : %v", obj)
                                log.Debug("bundle image to use : %v", obj.Entries[0].Name)
                                name, err := semverFindMax(obj.Entries)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(errorSemver, err)
                                }</span>
                                <span class="cov8" title="1">bundles[name] = true</span>
                        }
                case obj.Schema == "olm.bundle":<span class="cov8" title="1">
                        if bundles[obj.Name] </span><span class="cov8" title="1">{
                                log.Debug("config bundle: %d %v", i, obj.Name)
                                log.Trace("config relatedImages: %d %v", i, obj.RelatedImages)
                                relatedImages[obj.Name] = obj.RelatedImages
                        }</span>
                case obj.Schema == "olm.package":<span class="cov8" title="1">
                        log.Debug("Config package: %v", obj.Name)
                        defaultChannel = obj.DefaultChannel</span>
                }
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// getRelatedImageByFilter - get the DeclarativeConfig for a specifc channel with
// min,max version if set
func getRelatedImageByFilter(log clog.PluggableLoggerInterface, olm []v1alpha3.DeclarativeConfig, pkg v1alpha3.ISCPackage) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        // relevant variables
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        bundles := make(map[string]bool)
        // iterate through the catalog objects
        for i, obj := range olm </span><span class="cov8" title="1">{
                switch </span>{
                case obj.Schema == "olm.channel":<span class="cov8" title="1">
                        if len(pkg.Channel) &gt; 0 </span><span class="cov8" title="1">{
                                if pkg.Channel == obj.Name </span><span class="cov8" title="1">{
                                        log.Debug("found channel : %v", obj)
                                        name, err := semverFindRange(obj.Entries, pkg.MinVersion, pkg.MaxVersion)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error(errorSemver, err)
                                        }</span>
                                        <span class="cov8" title="1">for _, x := range name </span><span class="cov0" title="0">{
                                                bundles[x] = true
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                name, err := semverFindMax(obj.Entries)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(errorSemver, err)
                                }</span>
                                <span class="cov8" title="1">log.Debug("adding channel : %s", name)
                                bundles[name] = true</span>
                        }
                case obj.Schema == "olm.bundle":<span class="cov8" title="1">
                        if bundles[obj.Name] &amp;&amp; !pkg.Full </span><span class="cov8" title="1">{
                                log.Debug("config bundle: %d %v", i, obj.Name)
                                log.Trace("config relatedImages: %d %v", i, obj.RelatedImages)
                                relatedImages[obj.Name] = obj.RelatedImages
                        }</span>
                        // add all bundles
                        <span class="cov8" title="1">if pkg.Full </span><span class="cov0" title="0">{
                                relatedImages[obj.Name] = obj.RelatedImages
                        }</span>
                case obj.Schema == "olm.package":<span class="cov8" title="1">
                        log.Debug("config package: %v", obj.Name)
                        bundles[obj.DefaultChannel] = true</span>
                }
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// semverFindMax - finds the max bundle version
func semverFindMax(entries []v1alpha3.ChannelEntry) (string, error) <span class="cov8" title="1">{
        var max semver.Version
        var index int
        for id, s := range entries </span><span class="cov8" title="1">{
                hld := strings.Split(s.Name, ".")
                // we are only interested in 1,2,3 positions
                if len(hld) &lt; 4 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("versioning of string is not correct %s ", s.Name)
                }</span>
                <span class="cov8" title="1">hld[1] = strings.Replace(hld[1], "v", "", -1)
                end := strings.Split(hld[3], "-")
                semStr := strings.Join([]string{hld[1], hld[2], end[0]}, ".")
                version, err := semver.Parse(semStr)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">if version.Compare(max) == 1 </span><span class="cov8" title="1">{
                        max = version
                        index = id
                }</span>
        }
        <span class="cov8" title="1">return entries[index].Name, nil</span>
}

// semverFindRange - finds the bundles between ranges version
func semverFindRange(entries []v1alpha3.ChannelEntry, min, max string) ([]string, error) <span class="cov8" title="1">{

        var minVersion semver.Version
        var maxVersion semver.Version
        var err error
        var results []string

        // parse the min max strings
        if len(min) &gt; 0 </span><span class="cov8" title="1">{
                minVersion, err = semver.Parse(min)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                minVersion, _ = semver.Parse("0.0.0")
        }</span>
        <span class="cov8" title="1">if len(max) &gt; 0 </span><span class="cov8" title="1">{
                maxVersion, err = semver.Parse(max)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                maxVersion, _ = semver.Parse("9.9.9")
        }</span>

        <span class="cov8" title="1">for _, s := range entries </span><span class="cov8" title="1">{
                hld := strings.Split(s.Name, ".")
                // we are only interested in 1,2,3 positions
                if len(hld) &lt; 4 </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf("versioning of string is not correct %s ", s.Name)
                }</span>
                <span class="cov8" title="1">hld[1] = strings.Replace(hld[1], "v", "", -1)
                end := strings.Split(hld[3], "-")
                semStr := strings.Join([]string{hld[1], hld[2], end[0]}, ".")
                version, err := semver.Parse(semStr)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
                <span class="cov8" title="1">if version.Compare(maxVersion) &lt;= 0 &amp;&amp; version.Compare(minVersion) &gt;= 1 </span><span class="cov0" title="0">{
                        results = append(results, s.Name)
                }</span>
        }
        <span class="cov8" title="1">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mirror

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "strconv"

        "github.com/containers/common/pkg/retry"
        "github.com/containers/image/v5/copy"
        "github.com/containers/image/v5/manifest"
        "github.com/containers/image/v5/pkg/cli"
        "github.com/containers/image/v5/signature"
        "github.com/containers/image/v5/transports/alltransports"
        "github.com/containers/image/v5/types"
        "github.com/docker/distribution/reference"
)

const (
        mirrorToDisk = "mirrorToDisk"
        diskToMirror = "diskToMirror"
)

// MirrorInterface  used to mirror images with container/images (skopeo)
type MirrorInterface interface {
        Run(ctx context.Context, src, dest, mode string, opts *CopyOptions, stdout bufio.Writer) (retErr error)
}

type MirrorCopyInterface interface {
        CopyImage(ctx context.Context, pc *signature.PolicyContext, destRef, srcRef types.ImageReference, opts *copy.Options) ([]byte, error)
}

type MirrorDeleteInterface interface {
        DeleteImage(ctx context.Context, image string, opts *CopyOptions) error
}

// Mirror
type Mirror struct {
        mc   MirrorCopyInterface
        md   MirrorDeleteInterface
        Mode string
}

type MirrorCopy struct{}
type MirrorDelete struct{}

// New returns new Mirror instance
func New(mc MirrorCopyInterface, md MirrorDeleteInterface) MirrorInterface <span class="cov8" title="1">{
        return &amp;Mirror{mc: mc, md: md}
}</span>

func NewMirrorCopy() MirrorCopyInterface <span class="cov0" title="0">{
        return &amp;MirrorCopy{}
}</span>

func NewMirrorDelete() MirrorDeleteInterface <span class="cov0" title="0">{
        return &amp;MirrorDelete{}
}</span>

// Run - method to copy images from source to destination
func (o *Mirror) Run(ctx context.Context, src, dest, mode string, opts *CopyOptions, stdout bufio.Writer) (retErr error) <span class="cov8" title="1">{
        if mode == "delete" </span><span class="cov0" title="0">{
                return o.delete(ctx, src, opts)
        }</span>
        <span class="cov8" title="1">return o.copy(ctx, src, dest, opts, stdout)</span>
}

func (o *MirrorCopy) CopyImage(ctx context.Context, pc *signature.PolicyContext, destRef, srcRef types.ImageReference, co *copy.Options) ([]byte, error) <span class="cov0" title="0">{
        return copy.Image(ctx, pc, destRef, srcRef, co)
}</span>

func (o *MirrorDelete) DeleteImage(ctx context.Context, image string, co *CopyOptions) error <span class="cov0" title="0">{
        return nil
}</span>

// copy - copy images setup and execute
func (o *Mirror) copy(ctx context.Context, src, dest string, opts *CopyOptions, out bufio.Writer) (retErr error) <span class="cov8" title="1">{

        opts.DeprecatedTLSVerify.WarnIfUsed([]string{"--src-tls-verify", "--dest-tls-verify"})

        opts.RemoveSignatures, _ = strconv.ParseBool("true")

        if err := ReexecIfNecessaryForImages([]string{src, dest}...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">policyContext, err := opts.Global.GetPolicyContext()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error loading trust policy: %v", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := policyContext.Destroy(); err != nil </span><span class="cov0" title="0">{
                        retErr = NoteCloseFailure(retErr, "tearing down policy context", err)
                }</span>
        }()

        <span class="cov8" title="1">srcRef, err := alltransports.ParseImageName(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid source name %s: %v", src, err)
        }</span>
        <span class="cov8" title="1">destRef, err := alltransports.ParseImageName(dest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid destination name %s: %v", dest, err)
        }</span>

        <span class="cov8" title="1">sourceCtx, err := opts.SrcImage.NewSystemContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">destinationCtx, err := opts.DestImage.NewSystemContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var manifestType string
        if len(opts.Format) &gt; 0 </span><span class="cov8" title="1">{
                manifestType, err = ParseManifestFormat(opts.Format)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        /*
                for _, image := range opts.AdditionalTags {
                        ref, err := reference.ParseNormalizedNamed(image)
                        if err != nil {
                                return fmt.Errorf("error parsing additional-tag '%s': %v", image, err)
                        }
                        namedTagged, isNamedTagged := ref.(reference.NamedTagged)
                        if !isNamedTagged {
                                return fmt.Errorf("additional-tag '%s' must be a tagged reference", image)
                        }
                        destinationCtx.DockerArchiveAdditionalTags = append(destinationCtx.DockerArchiveAdditionalTags, namedTagged)
                }
        */

        <span class="cov8" title="1">ctx, cancel := opts.Global.CommandTimeoutContext()
        defer cancel()

        //if opts.Quiet {
        //        stdout = nil
        //}

        imageListSelection := copy.CopySystemImage
        if len(opts.MultiArch) &gt; 0 &amp;&amp; opts.All </span><span class="cov0" title="0">{
                return fmt.Errorf("Cannot use --all and --multi-arch flags together")
        }</span>

        <span class="cov8" title="1">if len(opts.MultiArch) &gt; 0 </span><span class="cov8" title="1">{
                imageListSelection, err = parseMultiArch(opts.MultiArch)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if opts.All </span><span class="cov0" title="0">{
                imageListSelection = copy.CopyAllImages
        }</span>

        <span class="cov8" title="1">if len(opts.EncryptionKeys) &gt; 0 &amp;&amp; len(opts.DecryptionKeys) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--encryption-key and --decryption-key cannot be specified together")
        }</span>

        /*
                var encLayers *[]int
                var encConfig *encconfig.EncryptConfig
                var decConfig *encconfig.DecryptConfig

                if len(opts.EncryptLayer) &gt; 0 &amp;&amp; len(opts.EncryptionKeys) == 0 {
                        return fmt.Errorf("--encrypt-layer can only be used with --encryption-key")
                }

                if len(opts.EncryptionKeys) &gt; 0 {
                        // encryption
                        p := opts.EncryptLayer
                        encLayers = &amp;p
                        encryptionKeys := opts.EncryptionKeys
                        ecc, err := enchelpers.CreateCryptoConfig(encryptionKeys, []string{})
                        if err != nil {
                                return fmt.Errorf("Invalid encryption keys: %v", err)
                        }
                        cc := encconfig.CombineCryptoConfigs([]encconfig.CryptoConfig{ecc})
                        encConfig = cc.EncryptConfig
                }

                if len(opts.DecryptionKeys) &gt; 0 {
                        // decryption
                        decryptionKeys := opts.DecryptionKeys
                        dcc, err := enchelpers.CreateCryptoConfig([]string{}, decryptionKeys)
                        if err != nil {
                                return fmt.Errorf("Invalid decryption keys: %v", err)
                        }
                        cc := encconfig.CombineCryptoConfigs([]encconfig.CryptoConfig{dcc})
                        decConfig = cc.DecryptConfig
                }
        */

        // c/image/copy.Image does allow creating both simple signing and sigstore signatures simultaneously,
        // with independent passphrases, but that would make the CLI probably too confusing.
        // For now, use the passphrase with either, but only one of them.
        <span class="cov8" title="1">if opts.SignPassphraseFile != "" &amp;&amp; opts.SignByFingerprint != "" &amp;&amp; opts.SignBySigstorePrivateKey != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Only one of --sign-by and sign-by-sigstore-private-key can be used with sign-passphrase-file")
        }</span>
        <span class="cov8" title="1">var passphrase string
        if opts.SignPassphraseFile != "" </span><span class="cov8" title="1">{
                p, err := cli.ReadPassphraseFile(opts.SignPassphraseFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">passphrase = p</span>
        }

        // opts.signByFingerprint triggers a GPG-agent passphrase prompt, possibly using a more secure channel,
        // so we usually shouldn’t prompt ourselves if no passphrase was explicitly provided.
        <span class="cov8" title="1">var signIdentity reference.Named = nil
        if opts.SignIdentity != "" </span><span class="cov0" title="0">{
                signIdentity, err = reference.ParseNamed(opts.SignIdentity)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Could not parse --sign-identity: %v", err)
                }</span>
        }

        //opts.DigestFile = "test-digest"
        <span class="cov8" title="1">writer := io.Writer(&amp;out)

        co := &amp;copy.Options{
                RemoveSignatures:                 opts.RemoveSignatures,
                SignBy:                           opts.SignByFingerprint,
                SignPassphrase:                   passphrase,
                SignBySigstorePrivateKeyFile:     opts.SignBySigstorePrivateKey,
                SignSigstorePrivateKeyPassphrase: []byte(passphrase),
                SignIdentity:                     signIdentity,
                ReportWriter:                     writer,
                SourceCtx:                        sourceCtx,
                DestinationCtx:                   destinationCtx,
                ForceManifestMIMEType:            manifestType,
                ImageListSelection:               imageListSelection,
                PreserveDigests:                  opts.PreserveDigests,
                //OciDecryptConfig:                 decConfig,
                //OciEncryptLayers:                 encLayers,
                //OciEncryptConfig:                 encConfig,
        }

        return retry.IfNecessary(ctx, func() error </span><span class="cov8" title="1">{

                //manifestBytes, err := copy.Image(ctx, policyContext, destRef, srcRef, &amp;copy.Options{
                manifestBytes, err := o.mc.CopyImage(ctx, policyContext, destRef, srcRef, co)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">out.Flush()
                if opts.DigestFile != "" </span><span class="cov0" title="0">{
                        manifestDigest, err := manifest.Digest(manifestBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err = os.WriteFile(opts.DigestFile, []byte(manifestDigest.String()), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to write digest to file %q: %w", opts.DigestFile, err)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }, opts.RetryOpts)
}

// delete - delete images
func (o *Mirror) delete(ctx context.Context, image string, opts *CopyOptions) error <span class="cov0" title="0">{

        if err := ReexecIfNecessaryForImages([]string{image}...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">imageRef, err := alltransports.ParseImageName(image)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid source name %s: %v", image, err)
        }</span>

        <span class="cov0" title="0">sysCtx, err := opts.DestImage.NewSystemContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx, cancel := opts.Global.CommandTimeoutContext()
        defer cancel()

        return retry.IfNecessary(ctx, func() error </span><span class="cov0" title="0">{
                err := imageRef.DeleteImage(ctx, sysCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, opts.RetryOpts)
}

// parseMultiArch
func parseMultiArch(multiArch string) (copy.ImageListSelection, error) <span class="cov8" title="1">{
        switch multiArch </span>{
        case "system":<span class="cov0" title="0">
                return copy.CopySystemImage, nil</span>
        case "all":<span class="cov8" title="1">
                return copy.CopyAllImages, nil</span>
        // There is no CopyNoImages value in copy.ImageListSelection, but because we
        // don't provide an option to select a set of images to copy, we can use
        // CopySpecificImages.
        case "index-only":<span class="cov0" title="0">
                return copy.CopySpecificImages, nil</span>
        // We don't expose CopySpecificImages other than index-only above, because
        // we currently don't provide an option to choose the images to copy. That
        // could be added in the future.
        default:<span class="cov0" title="0">
                return copy.CopySystemImage, fmt.Errorf("unknown multi-arch option %q. Choose one of the supported options: 'system', 'all', or 'index-only'", multiArch)</span>
        }
}

func HelloFromV2() string <span class="cov0" title="0">{
        return "Hello From V2"
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"
        "time"

        commonFlag "github.com/containers/common/pkg/flag"
        "github.com/containers/common/pkg/retry"
        "github.com/containers/image/v5/manifest"
        "github.com/containers/image/v5/signature"
        "github.com/containers/image/v5/types"
        "github.com/google/uuid"
        imgspecv1 "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "golang.org/x/term"
)

const defaultUserAgent string = "skopeo/v.19.5"

// errorShouldDisplayUsage is a subtype of error used by command handlers to indicate that cli.ShowSubcommandHelp should be called.
type ErrorShouldDisplayUsage struct {
        Error error
}

type GlobalOptions struct {
        LogLevel           string        // one of info, debug, trace
        TlsVerify          bool          // Require HTTPS and verify certificates (for docker: and docker-daemon:)
        PolicyPath         string        // Path to a signature verification policy file
        InsecurePolicy     bool          // Use an "allow everything" signature verification policy
        RegistriesDirPath  string        // Path to a "registries.d" registry configuration directory
        OverrideArch       string        // Architecture to use for choosing images, instead of the runtime one
        OverrideOS         string        // OS to use for choosing images, instead of the runtime one
        OverrideVariant    string        // Architecture variant to use for choosing images, instead of the runtime one
        CommandTimeout     time.Duration // Timeout for the command execution
        RegistriesConfPath string        // Path to the "registries.conf" file
        TmpDir             string        // Path to use for big temporary files
        Dir                string        // working directory
        From               string        // local storage for diskToMirror workflow
        Port               uint16        // HTTP port used by oc-mirror's local storage instance
        ConfigPath         string        // Path to use for imagesetconfig
        ReleaseFrom        string        // Used for release mirroring (diskToMirror)
        OperatorsFrom      string        // Used for operators mirroring (diskToMirror)
        AdditionalFrom     string        // Used for additionalImages mirroring (diskToMirror)
        Quiet              bool          // Suppress output information when copying images
        Force              bool          // Force the copy/mirror even if there is nothing to update
        V2                 bool          // Redirect the flow to oc-mirror v2 - PLEASE DO NOT USE that. V2 is still under development and it is not ready to be used.
}

type CopyOptions struct {
        Global                   *GlobalOptions
        DeprecatedTLSVerify      *DeprecatedTLSVerifyOption
        SrcImage                 *imageOptions
        DestImage                *imageDestOptions
        RetryOpts                *retry.Options
        AdditionalTags           []string  // For docker-archive: destinations, in addition to the name:tag specified as destination, also add these
        RemoveSignatures         bool      // Do not copy signatures from the source image
        SignByFingerprint        string    // Sign the image using a GPG key with the specified fingerprint
        SignBySigstorePrivateKey string    // Sign the image using a sigstore private key
        SignPassphraseFile       string    // Path pointing to a passphrase file when signing (for either signature format, but only one of them)
        SignIdentity             string    // Identity of the signed image, must be a fully specified docker reference
        DigestFile               string    // Write digest to this file
        Format                   string    // Force conversion of the image to a specified format
        All                      bool      // Copy all of the images if the source is a list
        MultiArch                string    // How to handle multi architecture images
        PreserveDigests          bool      // Preserve digests during copy
        EncryptLayer             []int     // The list of layers to encrypt
        EncryptionKeys           []string  // Keys needed to encrypt the image
        DecryptionKeys           []string  // Keys needed to decrypt the image
        Mode                     string    // 2 options disktoMirror or mirrorToDisk (for now)
        Dev                      bool      // developer mode - will be removed when completed
        Destination              string    // what to target to
        UUID                     uuid.UUID // set uuid
        ImageType                string    // release, catalog-operator, additionalImage
}

// deprecatedTLSVerifyOption represents a deprecated --tls-verify option,
// which was accepted for all subcommands, for a time.
// Every user should call deprecatedTLSVerifyOption.warnIfUsed() as part of handling the CLI,
// whether or not the value actually ends up being used.
// DO NOT ADD ANY NEW USES OF THIS; just call dockerImageFlags with an appropriate, possibly empty, flagPrefix.
type DeprecatedTLSVerifyOption struct {
        tlsVerify commonFlag.OptionalBool // FIXME FIXME: Warn if this is used, or even if it is ignored.
}

// sharedImageOptions collects CLI flags which are image-related, but do not change across images.
// This really should be a part of globalOptions, but that would break existing users of (skopeo copy --authfile=).
type SharedImageOptions struct {
        authFilePath string // Path to a */containers/auth.json
}

// dockerImageOptions collects CLI flags specific to the "docker" transport, which are
// the same across subcommands, but may be different for each image
// (e.g. may differ between the source and destination of a copy)
type dockerImageOptions struct {
        global              *GlobalOptions             // May be shared across several imageOptions instances.
        shared              *SharedImageOptions        // May be shared across several imageOptions instances.
        deprecatedTLSVerify *DeprecatedTLSVerifyOption // May be shared across several imageOptions instances, or nil.
        authFilePath        commonFlag.OptionalString  // Path to a */containers/auth.json (prefixed version to override shared image option).
        credsOption         commonFlag.OptionalString  // username[:password] for accessing a registry
        userName            commonFlag.OptionalString  // username for accessing a registry
        password            commonFlag.OptionalString  // password for accessing a registry
        registryToken       commonFlag.OptionalString  // token to be used directly as a Bearer token when accessing the registry
        dockerCertPath      string                     // A directory using Docker-like *.{crt,cert,key} files for connecting to a registry or a daemon
        tlsVerify           commonFlag.OptionalBool    // Require HTTPS and verify certificates (for docker: and docker-daemon:)
        noCreds             bool                       // Access the registry anonymously
}

// imageOptions collects CLI flags which are the same across subcommands, but may be different for each image
// (e.g. may differ between the source and destination of a copy)
type imageOptions struct {
        dockerImageOptions
        sharedBlobDir    string // A directory to use for OCI blobs, shared across repositories
        dockerDaemonHost string // docker-daemon: host to connect to
}

// imageDestOptions is a superset of imageOptions specialized for image destinations.
type imageDestOptions struct {
        *imageOptions
        dirForceCompression         bool                   // Compress layers when saving to the dir: transport
        dirForceDecompression       bool                   // Decompress layers when saving to the dir: transport
        ociAcceptUncompressedLayers bool                   // Whether to accept uncompressed layers in the oci: transport
        compressionFormat           string                 // Format to use for the compression
        compressionLevel            commonFlag.OptionalInt // Level to use for the compression
        precomputeDigests           bool                   // Precompute digests to dedup layers when saving to the docker: transport
}

// noteCloseFailure returns (possibly-nil) err modified to account for (non-nil) closeErr.
// The error for closeErr is annotated with description (which is not a format string)
// Typical usage:
//
//        defer func() {
//                if err := something.Close(); err != nil {
//                        returnedErr = noteCloseFailure(returnedErr, "closing something", err)
//                }
//        }
func NoteCloseFailure(err error, description string, closeErr error) error <span class="cov0" title="0">{
        // We don’t accept a Closer() and close it ourselves because signature.PolicyContext has .Destroy(), not .Close().
        // This also makes it harder for a caller to do
        //     defer noteCloseFailure(returnedErr, …)
        // which doesn’t use the right value of returnedErr, and doesn’t update it.
        if err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", description, closeErr)
        }</span>
        // In this case we prioritize the primary error for use with %w; closeErr is usually less relevant, or might be a consequence of the primary erorr.
        <span class="cov0" title="0">return fmt.Errorf("%w (%s: %v)", err, description, closeErr)</span>
}

// commandAction intermediates between the RunE interface and the real handler,
// primarily to ensure that cobra.Command is not available to the handler, which in turn
// makes sure that the cmd.Flags() etc. flag access functions are not used,
// and everything is done using the *Options structures and the *Var() methods of cmd.Flag().
// handler may return errorShouldDisplayUsage to cause c.Help to be called.
func CommandAction(handler func(args []string, stdout io.Writer) error) func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        return func(c *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                err := handler(args, c.OutOrStdout())
                //var shouldDisplayUsage = &amp;ErrorShouldDisplayUsage{}
                //if errors.As(err, &amp;ErrorShouldDisplayUsage{}) {
                //        return c.Help()
                //}
                return err
        }</span>
}

// warnIfUsed warns if tlsVerify was set by the user, and suggests alternatives (which should
// start with "--").
// Every user should call this as part of handling the CLI, whether or not the value actually
// ends up being used.
func (opts *DeprecatedTLSVerifyOption) WarnIfUsed(alternatives []string) <span class="cov8" title="1">{
        if opts.tlsVerify.Present() </span><span class="cov0" title="0">{
                logrus.Warnf("'--tls-verify' is deprecated, instead use: %s", strings.Join(alternatives, ", "))
        }</span>
}

// deprecatedTLSVerifyFlags prepares the CLI flag writing into deprecatedTLSVerifyOption, and the managed deprecatedTLSVerifyOption structure.
// DO NOT ADD ANY NEW USES OF THIS; just call dockerImageFlags with an appropriate, possibly empty, flagPrefix.
func DeprecatedTLSVerifyFlags() (pflag.FlagSet, *DeprecatedTLSVerifyOption) <span class="cov8" title="1">{
        opts := DeprecatedTLSVerifyOption{}
        fs := pflag.FlagSet{}
        flag := commonFlag.OptionalBoolFlag(&amp;fs, &amp;opts.tlsVerify, "tls-verify", "require HTTPS and verify certificates when accessing the container registry")
        flag.Hidden = true
        return fs, &amp;opts
}</span>

// sharedImageFlags prepares a collection of CLI flags writing into sharedImageOptions, and the managed sharedImageOptions structure.
func SharedImageFlags() (pflag.FlagSet, *SharedImageOptions) <span class="cov8" title="1">{
        opts := SharedImageOptions{}
        fs := pflag.FlagSet{}
        fs.StringVar(&amp;opts.authFilePath, "authfile", os.Getenv("REGISTRY_AUTH_FILE"), "path of the authentication file. Default is ${XDG_RUNTIME_DIR}/containers/auth.json")
        return fs, &amp;opts
}</span>

// dockerImageFlags prepares a collection of docker-transport specific CLI flags
// writing into imageOptions, and the managed imageOptions structure.
func dockerImageFlags(global *GlobalOptions, shared *SharedImageOptions, deprecatedTLSVerify *DeprecatedTLSVerifyOption, flagPrefix, credsOptionAlias string) (pflag.FlagSet, *imageOptions) <span class="cov8" title="1">{
        flags := imageOptions{
                dockerImageOptions: dockerImageOptions{
                        global:              global,
                        shared:              shared,
                        deprecatedTLSVerify: deprecatedTLSVerify,
                },
        }

        fs := pflag.FlagSet{}
        if flagPrefix != "" </span><span class="cov8" title="1">{
                // the non-prefixed flag is handled by a shared flag.
                fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.authFilePath), flagPrefix+"authfile", "path of the authentication file. Default is ${XDG_RUNTIME_DIR}/containers/auth.json")
        }</span>
        <span class="cov8" title="1">fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.credsOption), flagPrefix+"creds", "Use `USERNAME[:PASSWORD]` for accessing the registry")
        fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.userName), flagPrefix+"username", "Username for accessing the registry")
        fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.password), flagPrefix+"password", "Password for accessing the registry")
        if credsOptionAlias != "" </span><span class="cov8" title="1">{
                // This is horribly ugly, but we need to support the old option forms of (skopeo copy) for compatibility.
                // Don't add any more cases like this.
                f := fs.VarPF(commonFlag.NewOptionalStringValue(&amp;flags.credsOption), credsOptionAlias, "", "Use `USERNAME[:PASSWORD]` for accessing the registry")
                f.Hidden = true
        }</span>
        <span class="cov8" title="1">fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.registryToken), flagPrefix+"registry-token", "Provide a Bearer token for accessing the registry")
        fs.StringVar(&amp;flags.dockerCertPath, flagPrefix+"cert-dir", "", "use certificates at `PATH` (*.crt, *.cert, *.key) to connect to the registry or daemon")
        commonFlag.OptionalBoolFlag(&amp;fs, &amp;flags.tlsVerify, flagPrefix+"tls-verify", "require HTTPS and verify certificates when talking to the container registry or daemon")
        fs.BoolVar(&amp;flags.noCreds, flagPrefix+"no-creds", false, "Access the registry anonymously")
        return fs, &amp;flags</span>
}

// imageFlags prepares a collection of CLI flags writing into imageOptions, and the managed imageOptions structure.
func ImageSrcFlags(global *GlobalOptions, shared *SharedImageOptions, deprecatedTLSVerify *DeprecatedTLSVerifyOption, flagPrefix, credsOptionAlias string) (pflag.FlagSet, *imageOptions) <span class="cov8" title="1">{
        fs := pflag.FlagSet{}

        dockerFlags, opts := dockerImageFlags(global, shared, deprecatedTLSVerify, flagPrefix, credsOptionAlias)

        fs.StringVar(&amp;opts.sharedBlobDir, flagPrefix+"shared-blob-dir", "", "`DIRECTORY` to use to share blobs across OCI repositories")
        fs.StringVar(&amp;opts.dockerDaemonHost, flagPrefix+"daemon-host", "", "use docker daemon host at `HOST` (docker-daemon: only)")
        fs.AddFlagSet(&amp;dockerFlags)
        return fs, opts
}</span>

func RetryFlags() (pflag.FlagSet, *retry.Options) <span class="cov8" title="1">{
        opts := retry.Options{}
        fs := pflag.FlagSet{}
        fs.IntVar(&amp;opts.MaxRetry, "retry-times", 0, "the number of times to possibly retry")
        return fs, &amp;opts
}</span>

// getPolicyContext returns a *signature.PolicyContext based on opts.
func (opts *GlobalOptions) GetPolicyContext() (*signature.PolicyContext, error) <span class="cov8" title="1">{
        var policy *signature.Policy // This could be cached across calls in opts.
        var err error
        if opts.InsecurePolicy </span><span class="cov8" title="1">{
                policy = &amp;signature.Policy{Default: []signature.PolicyRequirement{signature.NewPRInsecureAcceptAnything()}}
        }</span> else<span class="cov0" title="0"> if opts.PolicyPath == "" </span><span class="cov0" title="0">{
                policy, err = signature.DefaultPolicy(nil)
        }</span> else<span class="cov0" title="0"> {
                policy, err = signature.NewPolicyFromFile(opts.PolicyPath)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return signature.NewPolicyContext(policy)</span>
}

// commandTimeoutContext returns a context.Context and a cancellation callback based on opts.
// The caller should usually "defer cancel()" immediately after calling this.
func (opts *GlobalOptions) CommandTimeoutContext() (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        ctx := context.Background()
        var cancel context.CancelFunc = func() </span>{<span class="cov8" title="1">
                // empty function - its ok for now
        }</span>
        <span class="cov8" title="1">if opts.CommandTimeout &gt; 0 </span><span class="cov0" title="0">{
                ctx, cancel = context.WithTimeout(ctx, opts.CommandTimeout)
        }</span>
        <span class="cov8" title="1">return ctx, cancel</span>
}

// newSystemContext returns a *types.SystemContext corresponding to opts.
// It is guaranteed to return a fresh instance, so it is safe to make additional updates to it.
func (opts *GlobalOptions) NewSystemContext() *types.SystemContext <span class="cov8" title="1">{
        ctx := &amp;types.SystemContext{
                RegistriesDirPath:        opts.RegistriesDirPath,
                ArchitectureChoice:       opts.OverrideArch,
                OSChoice:                 opts.OverrideOS,
                VariantChoice:            opts.OverrideVariant,
                SystemRegistriesConfPath: opts.RegistriesConfPath,
                BigFilesTemporaryDir:     opts.TmpDir,
                DockerRegistryUserAgent:  defaultUserAgent,
        }
        // DEPRECATED: We support this for backward compatibility, but override it if a per-image flag is provided.
        if !opts.TlsVerify </span><span class="cov8" title="1">{
                ctx.DockerInsecureSkipTLSVerify = types.NewOptionalBool(true)
        }</span>
        <span class="cov8" title="1">return ctx</span>
}

// newSystemContext returns a *types.SystemContext corresponding to opts.
// It is guaranteed to return a fresh instance, so it is safe to make additional updates to it.
func (opts *imageOptions) NewSystemContext() (*types.SystemContext, error) <span class="cov8" title="1">{
        // *types.SystemContext instance from globalOptions
        //  imageOptions option overrides the instance if both are present.
        ctx := opts.global.NewSystemContext()
        ctx.DockerCertPath = opts.dockerCertPath
        ctx.OCISharedBlobDirPath = opts.sharedBlobDir
        ctx.AuthFilePath = opts.shared.authFilePath
        ctx.DockerDaemonHost = opts.dockerDaemonHost
        ctx.DockerDaemonCertPath = opts.dockerCertPath
        if opts.dockerImageOptions.authFilePath.Present() </span><span class="cov0" title="0">{
                ctx.AuthFilePath = opts.dockerImageOptions.authFilePath.Value()
        }</span>
        <span class="cov8" title="1">if opts.deprecatedTLSVerify != nil &amp;&amp; opts.deprecatedTLSVerify.tlsVerify.Present() </span><span class="cov0" title="0">{
                // If both this deprecated option and a non-deprecated option is present, we use the latter value.
                ctx.DockerInsecureSkipTLSVerify = types.NewOptionalBool(!opts.deprecatedTLSVerify.tlsVerify.Value())
        }</span>
        <span class="cov8" title="1">if opts.tlsVerify.Present() </span><span class="cov0" title="0">{
                ctx.DockerDaemonInsecureSkipTLSVerify = !opts.tlsVerify.Value()
        }</span>
        <span class="cov8" title="1">if opts.tlsVerify.Present() </span><span class="cov0" title="0">{
                ctx.DockerInsecureSkipTLSVerify = types.NewOptionalBool(!opts.tlsVerify.Value())
        }</span>
        <span class="cov8" title="1">if opts.credsOption.Present() &amp;&amp; opts.noCreds </span><span class="cov0" title="0">{
                return nil, errors.New("creds and no-creds cannot be specified at the same time")
        }</span>
        <span class="cov8" title="1">if opts.userName.Present() &amp;&amp; opts.noCreds </span><span class="cov0" title="0">{
                return nil, errors.New("username and no-creds cannot be specified at the same time")
        }</span>
        <span class="cov8" title="1">if opts.credsOption.Present() &amp;&amp; opts.userName.Present() </span><span class="cov0" title="0">{
                return nil, errors.New("creds and username cannot be specified at the same time")
        }</span>
        // if any of username or password is present, then both are expected to be present
        <span class="cov8" title="1">if opts.userName.Present() != opts.password.Present() </span><span class="cov0" title="0">{
                if opts.userName.Present() </span><span class="cov0" title="0">{
                        return nil, errors.New("password must be specified when username is specified")
                }</span>
                <span class="cov0" title="0">return nil, errors.New("username must be specified when password is specified")</span>
        }
        <span class="cov8" title="1">if opts.credsOption.Present() </span><span class="cov0" title="0">{
                var err error
                ctx.DockerAuthConfig, err = getDockerAuth(opts.credsOption.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> if opts.userName.Present() </span><span class="cov0" title="0">{
                ctx.DockerAuthConfig = &amp;types.DockerAuthConfig{
                        Username: opts.userName.Value(),
                        Password: opts.password.Value(),
                }
        }</span>
        <span class="cov8" title="1">if opts.registryToken.Present() </span><span class="cov0" title="0">{
                ctx.DockerBearerRegistryToken = opts.registryToken.Value()
        }</span>
        <span class="cov8" title="1">if opts.noCreds </span><span class="cov0" title="0">{
                ctx.DockerAuthConfig = &amp;types.DockerAuthConfig{}
        }</span>

        <span class="cov8" title="1">return ctx, nil</span>
}

// imageDestFlags prepares a collection of CLI flags writing into imageDestOptions, and the managed imageDestOptions structure.
func ImageDestFlags(global *GlobalOptions, shared *SharedImageOptions, deprecatedTLSVerify *DeprecatedTLSVerifyOption, flagPrefix, credsOptionAlias string) (pflag.FlagSet, *imageDestOptions) <span class="cov8" title="1">{
        fs := pflag.FlagSet{}
        genericFlags, genericOptions := dockerImageFlags(global, shared, deprecatedTLSVerify, flagPrefix, credsOptionAlias)
        opts := imageDestOptions{imageOptions: genericOptions}
        fs.AddFlagSet(&amp;genericFlags)
        fs.BoolVar(&amp;opts.dirForceCompression, flagPrefix+"compress", false, "Compress tarball image layers when saving to directory using the 'dir' transport. (default is same compression type as source)")
        fs.BoolVar(&amp;opts.dirForceDecompression, flagPrefix+"decompress", false, "Decompress tarball image layers when saving to directory using the 'dir' transport. (default is same compression type as source)")
        fs.BoolVar(&amp;opts.ociAcceptUncompressedLayers, flagPrefix+"oci-accept-uncompressed-layers", false, "Allow uncompressed image layers when saving to an OCI image using the 'oci' transport. (default is to compress things that aren't compressed)")
        fs.StringVar(&amp;opts.compressionFormat, flagPrefix+"compress-format", "", "`FORMAT` to use for the compression")
        fs.Var(commonFlag.NewOptionalIntValue(&amp;opts.compressionLevel), flagPrefix+"compress-level", "`LEVEL` to use for the compression")
        fs.BoolVar(&amp;opts.precomputeDigests, flagPrefix+"precompute-digests", false, "Precompute digests to prevent uploading layers already on the registry using the 'docker' transport.")
        fs.StringVar(&amp;opts.sharedBlobDir, flagPrefix+"shared-blob-dir", "", "`DIRECTORY` to use to share blobs across OCI repositories")
        fs.StringVar(&amp;opts.dockerDaemonHost, flagPrefix+"daemon-host", "", "use docker daemon host at `HOST` (docker-daemon: only)")
        return fs, &amp;opts
}</span>

/*
// newSystemContext returns a *types.SystemContext corresponding to opts.
// It is guaranteed to return a fresh instance, so it is safe to make additional updates to it.
func (opts *imageDestOptions) newSystemContext() (*types.SystemContext, error) {
        ctx, err := opts.imageOptions.NewSystemContext()
        if err != nil {
                return nil, err
        }

        ctx.DirForceCompress = opts.dirForceCompression
        ctx.DirForceDecompress = opts.dirForceDecompression
        ctx.OCIAcceptUncompressedLayers = opts.ociAcceptUncompressedLayers
        if opts.compressionFormat != "" {
                cf, err := compression.AlgorithmByName(opts.compressionFormat)
                if err != nil {
                        return nil, err
                }
                ctx.CompressionFormat = &amp;cf
        }
        if opts.compressionLevel.Present() {
                value := opts.compressionLevel.Value()
                ctx.CompressionLevel = &amp;value
        }
        ctx.DockerRegistryPushPrecomputeDigests = opts.precomputeDigests
        return ctx, err
}
*/

func parseCreds(creds string) (string, string, error) <span class="cov0" title="0">{
        if creds == "" </span><span class="cov0" title="0">{
                return "", "", errors.New("credentials can't be empty")
        }</span>
        <span class="cov0" title="0">up := strings.SplitN(creds, ":", 2)
        if len(up) == 1 </span><span class="cov0" title="0">{
                return up[0], "", nil
        }</span>
        <span class="cov0" title="0">if up[0] == "" </span><span class="cov0" title="0">{
                return "", "", errors.New("username can't be empty")
        }</span>
        <span class="cov0" title="0">return up[0], up[1], nil</span>
}

func getDockerAuth(creds string) (*types.DockerAuthConfig, error) <span class="cov0" title="0">{
        username, password, err := parseCreds(creds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;types.DockerAuthConfig{
                Username: username,
                Password: password,
        }, nil</span>
}

/*
// parseImageSource converts image URL-like string to an ImageSource.
// The caller must call .Close() on the returned ImageSource.
func parseImageSource(ctx context.Context, opts *imageOptions, name string) (types.ImageSource, error) {
        ref, err := alltransports.ParseImageName(name)
        if err != nil {
                return nil, err
        }
        sys, err := opts.NewSystemContext()
        if err != nil {
                return nil, err
        }
        return ref.NewImageSource(ctx, sys)
}
*/

// parseManifestFormat parses format parameter for copy and sync command.
// It returns string value to use as manifest MIME type
func ParseManifestFormat(manifestFormat string) (string, error) <span class="cov8" title="1">{
        switch manifestFormat </span>{
        case "oci":<span class="cov8" title="1">
                return imgspecv1.MediaTypeImageManifest, nil</span>
        case "v2s1":<span class="cov0" title="0">
                return manifest.DockerV2Schema1SignedMediaType, nil</span>
        case "v2s2":<span class="cov0" title="0">
                return manifest.DockerV2Schema2MediaType, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unknown format %q. Choose one of the supported formats: 'oci', 'v2s1', or 'v2s2'", manifestFormat)</span>
        }
}

/*
// usageTemplate returns the usage template for skopeo commands
// This blocks the displaying of the global options. The main skopeo
// command should not use this.
const usageTemplate = `Usage:{{if .Runnable}}
{{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
{{.CommandPath}} [command]{{end}}{{if gt (len .Aliases) 0}}
Aliases:
{{.NameAndAliases}}{{end}}{{if .HasExample}}
Examples:
{{.Example}}{{end}}{{if .HasAvailableSubCommands}}
Available Commands:{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
{{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}
Flags:
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}{{if .HasAvailableInheritedFlags}}
{{end}}
`
*/

/*
// adjustUsage uses usageTemplate template to get rid the GlobalOption from usage
// and disable [flag] at the end of command usage
func adjustUsage(c *cobra.Command) {
        c.SetUsageTemplate(usageTemplate)
        c.DisableFlagsInUseLine = true
}
*/

// promptForPassphrase interactively prompts for a passphrase related to privateKeyFile
func PromptForPassphrase(privateKeyFile string, stdin, stdout *os.File) (string, error) <span class="cov0" title="0">{
        stdinFd := int(stdin.Fd())
        if !term.IsTerminal(stdinFd) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Cannot prompt for a passphrase for key %s, standard input is not a TTY", privateKeyFile)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(stdout, "Passphrase for key %s: ", privateKeyFile)
        passphrase, err := term.ReadPassword(stdinFd)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Error reading password: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(stdout, "\n")
        return string(passphrase), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// go: build !windows
// build !windows
package mirror

import (
        "fmt"

        "github.com/containers/image/v5/transports/alltransports"
        "github.com/containers/storage/pkg/unshare"
        "github.com/syndtr/gocapability/capability"
)

var neededCapabilities = []capability.Cap{
        capability.CAP_CHOWN,
        capability.CAP_DAC_OVERRIDE,
        capability.CAP_FOWNER,
        capability.CAP_FSETID,
        capability.CAP_MKNOD,
        capability.CAP_SETFCAP,
}

func maybeReexec() error <span class="cov0" title="0">{
        // With Skopeo we need only the subset of the root capabilities necessary
        // for pulling an image to the storage.  Do not attempt to create a namespace
        // if we already have the capabilities we need.
        capabilities, err := capability.NewPid2(0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading the current capabilities sets: %w", err)
        }</span>
        <span class="cov0" title="0">for _, cap := range neededCapabilities </span><span class="cov0" title="0">{
                if !capabilities.Get(capability.EFFECTIVE, cap) </span><span class="cov0" title="0">{
                        // We miss a capability we need, create a user namespaces
                        unshare.MaybeReexecUsingUserNamespace(true)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func ReexecIfNecessaryForImages(imageNames ...string) error <span class="cov8" title="1">{
        // Check if container-storage is used before doing unshare
        for _, imageName := range imageNames </span><span class="cov8" title="1">{
                transport := alltransports.TransportFromImageName(imageName)
                // Hard-code the storage name to avoid a reference on c/image/storage.
                // See https://github.com/containers/skopeo/issues/771#issuecomment-563125006.
                if transport != nil &amp;&amp; transport.Name() == "containers-storage" </span><span class="cov0" title="0">{
                        return maybeReexec()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package operator

import (
        "bufio"
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
)

const (
        dirProtocolTrimmed string = "dir:"
)

type Collector struct {
        Log      clog.PluggableLoggerInterface
        Mirror   mirror.MirrorInterface
        Manifest manifest.ManifestInterface
        Config   v1alpha2.ImageSetConfiguration
        Opts     mirror.CopyOptions
}

// OperatorImageCollector - this looks into the operator index image
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded (oci format) and the index.json is inspected
// once unmarshalled, the links to manifests are inspected
func (o *Collector) OperatorImageCollector(ctx context.Context) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{

        var (
                allImages []v1alpha3.CopyImageSchema
                label     string
                dir       string
        )
        compare := make(map[string]v1alpha3.ISCPackage)
        relatedImages := make(map[string][]v1alpha3.RelatedImage)

        // compile a map to compare channels,min &amp; max versions
        for _, ops := range o.Config.Mirror.Operators </span><span class="cov8" title="1">{
                o.Log.Info("isc operators: %s\n", ops.Catalog)
                for _, pkg := range ops.Packages </span><span class="cov8" title="1">{
                        o.Log.Info("catalog packages: %s \n", pkg.Name)
                        for _, channel := range pkg.Channels </span><span class="cov8" title="1">{
                                compare[pkg.Name] = v1alpha3.ISCPackage{Channel: channel.Name, MinVersion: channel.MinVersion, MaxVersion: channel.MaxVersion, Full: ops.Full}
                                o.Log.Info("channels: %v \n", compare)
                        }</span>
                }
        }

        // check the mode
        <span class="cov8" title="1">if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                f, err := os.Create(logsFile)
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error(errMsg, err)
                }</span>
                <span class="cov8" title="1">writer := bufio.NewWriter(f)
                defer f.Close()
                for _, op := range o.Config.Mirror.Operators </span><span class="cov8" title="1">{
                        // download the operator index image
                        o.Log.Info("copying operator image %v", op.Catalog)
                        hld := strings.Split(op.Catalog, "/")
                        imageIndexDir := strings.Replace(hld[len(hld)-1], ":", "/", -1)
                        cacheDir := strings.Join([]string{o.Opts.Global.Dir, operatorImageExtractDir, imageIndexDir}, "/")
                        dir = strings.Join([]string{o.Opts.Global.Dir, operatorImageDir, imageIndexDir}, "/")
                        if _, err := os.Stat(cacheDir); errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                                err := os.MkdirAll(dir, 0755)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.CopyImageSchema{}, err
                                }</span>
                                <span class="cov8" title="1">src := dockerProtocol + op.Catalog
                                dest := ociProtocolTrimmed + dir
                                err = o.Mirror.Run(ctx, src, dest, "copy", &amp;o.Opts, *writer)
                                writer.Flush()
                                if err != nil </span><span class="cov0" title="0">{
                                        o.Log.Error(errMsg, err)
                                }</span>
                                // read the logs
                                <span class="cov8" title="1">f, _ := os.ReadFile(logsFile)
                                lines := strings.Split(string(f), "\n")
                                for _, s := range lines </span><span class="cov8" title="1">{
                                        if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                                o.Log.Debug("%s ", strings.ToLower(s))
                                        }</span>
                                }
                        }

                        // it's in oci format so we can go directly to the index.json file
                        <span class="cov8" title="1">oci, err := o.Manifest.GetImageIndex(dir)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>

                        //read the link to the manifest
                        <span class="cov8" title="1">if len(oci.Manifests) == 0 </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf("[OperatorImageCollector] no manifests found for %s ", op.Catalog)
                        }</span> else<span class="cov8" title="1"> {
                                if !strings.Contains(oci.Manifests[0].Digest, "sha256") </span><span class="cov0" title="0">{
                                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf("[OperatorImageCollector] the disgets seems to incorrect for %s ", op.Catalog)
                                }</span>
                        }
                        <span class="cov8" title="1">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
                        o.Log.Info("manifest %v", manifest)

                        // read the operator image manifest
                        manifestDir := strings.Join([]string{dir, blobsDir, manifest}, "/")
                        oci, err = o.Manifest.GetImageManifest(manifestDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>

                        // read the config digest to get the detailed manifest
                        // looking for the lable to search for a specific folder
                        <span class="cov8" title="1">catalogDir := strings.Join([]string{dir, blobsDir, strings.Split(oci.Config.Digest, ":")[1]}, "/")
                        ocs, err := o.Manifest.GetOperatorConfig(catalogDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>

                        <span class="cov8" title="1">label = ocs.Config.Labels.OperatorsOperatorframeworkIoIndexConfigsV1
                        o.Log.Info("label %s", label)

                        // untar all the blobs for the operator
                        // if the layer with "label (from previous step) is found to a specific folder"
                        fromDir := strings.Join([]string{dir, blobsDir}, "/")
                        err = o.Manifest.ExtractLayersOCI(fromDir, cacheDir, label, oci)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>

                        // select all packages
                        // this is the equivalent of the headOnly mode
                        // only the latest version of each operator will be selected
                        <span class="cov8" title="1">if len(op.Packages) == 0 </span><span class="cov8" title="1">{
                                relatedImages, err = o.Manifest.GetRelatedImagesFromCatalog(cacheDir, label)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.CopyImageSchema{}, err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // iterate through each package
                                relatedImages, err = o.Manifest.GetRelatedImagesFromCatalogByFilter(cacheDir, label, op, compare)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.CopyImageSchema{}, err
                                }</span>
                        }
                }

                <span class="cov8" title="1">o.Log.Info("related images length %d ", len(relatedImages))
                var count = 0
                for _, v := range relatedImages </span><span class="cov8" title="1">{
                        count = count + len(v)
                }</span>
                <span class="cov8" title="1">o.Log.Info("images to copy (before duplicates) %d ", count)

                allImages, err = batchWorkerConverter(o.Log, dir, relatedImages)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, err
                }</span>
        }

        <span class="cov8" title="1">if o.Opts.Mode == diskToMirror </span><span class="cov0" title="0">{
                // check the directory to copy
                regex, e := regexp.Compile(indexJson)
                if e != nil </span><span class="cov0" title="0">{
                        o.Log.Error("%v", e)
                }</span>
                <span class="cov0" title="0">for _, op := range o.Config.Mirror.Operators </span><span class="cov0" title="0">{
                        // Need to fix this - incase their are no operators in the ImageSetConfig
                        for _, pkg := range op.Packages </span><span class="cov0" title="0">{
                                imagesDir := strings.Replace(op.Catalog, "dir://", "", 1)
                                e = filepath.Walk(imagesDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                                        if err == nil &amp;&amp; regex.MatchString(info.Name()) &amp;&amp; strings.Contains(path, pkg.Name) </span><span class="cov0" title="0">{
                                                o.Log.Info("path %s", filepath.Dir(path))
                                                hld := strings.Split(filepath.Dir(path), operatorImageDir)
                                                //ref := filepath.Dir(strings.Join(hld[1], "/"))
                                                if len(hld) == 0 </span><span class="cov0" title="0">{
                                                        return fmt.Errorf(errMsg+"%s", "no directory found for operator-images ", path)
                                                }</span> else<span class="cov0" title="0"> {
                                                        src := ociProtocolTrimmed + filepath.Dir(path)
                                                        dest := o.Opts.Destination + hld[1]
                                                        allImages = append(allImages, v1alpha3.CopyImageSchema{Source: src, Destination: dest})
                                                }</span>
                                        }
                                        <span class="cov0" title="0">return nil</span>
                                })
                        }
                }
                <span class="cov0" title="0">if e != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, e
                }</span>
        }
        <span class="cov8" title="1">return allImages, nil</span>
}

// customImageParser - simple image string parser
func customImageParser(image string) (*v1alpha3.ImageRefSchema, error) <span class="cov8" title="1">{
        var irs *v1alpha3.ImageRefSchema
        var component string
        parts := strings.Split(image, "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return irs, fmt.Errorf("[customImageParser] image url seems to be wrong %s ", image)
        }</span>
        <span class="cov8" title="1">if strings.Contains(parts[2], "@") </span><span class="cov8" title="1">{
                component = strings.Split(parts[2], "@")[0]
        }</span> else<span class="cov0" title="0"> {
                component = parts[2]
        }</span>
        <span class="cov8" title="1">irs = &amp;v1alpha3.ImageRefSchema{Repository: parts[0], Namespace: parts[1], Component: component}
        return irs, nil</span>
}

// batchWorkerConverter convert RelatedImages to strings for batch worker
func batchWorkerConverter(log clog.PluggableLoggerInterface, dir string, images map[string][]v1alpha3.RelatedImage) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{
        var result []v1alpha3.CopyImageSchema
        for bundle, relatedImgs := range images </span><span class="cov8" title="1">{
                for _, img := range relatedImgs </span><span class="cov8" title="1">{
                        irs, err := customImageParser(img.Image)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("[batchWorkerConverter] %v", err)
                                return result, err
                        }</span>
                        <span class="cov8" title="1">componentDir := strings.Join([]string{dir, bundle, irs.Namespace}, "/")
                        // do a lookup on dist first
                        if _, err := os.Stat(componentDir); errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                                err = os.MkdirAll(componentDir, 0755)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("[batchWorkerConverter] %v", err)
                                        return result, err
                                }</span>
                                <span class="cov0" title="0">src := dockerProtocol + img.Image
                                if len(img.Name) == 0 </span><span class="cov0" title="0">{
                                        timestamp := time.Now().Unix()
                                        s := fmt.Sprintf("%d", timestamp)
                                        img.Name = fmt.Sprintf("%x", sha256.Sum256([]byte(s)))[:6]
                                }</span>
                                <span class="cov0" title="0">dest := dirProtocolTrimmed + strings.Join([]string{dir, bundle, irs.Namespace, img.Name}, "/")
                                log.Debug("source %s ", img.Image)
                                log.Debug("destination %s ", dest)
                                result = append(result, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>
                        } else<span class="cov8" title="1"> {
                                log.Info("image in cache %s", componentDir)
                        }</span>
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package operator

import (
        "bufio"
        "context"
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
)

const (
        hashTruncLen int = 12
)

type LocalStorageCollector struct {
        Log              clog.PluggableLoggerInterface
        Mirror           mirror.MirrorInterface
        Manifest         manifest.ManifestInterface
        Config           v1alpha2.ImageSetConfiguration
        Opts             mirror.CopyOptions
        LocalStorageFQDN string
}

// OperatorImageCollector - this looks into the operator index image
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded (oci format) and the index.json is inspected
// once unmarshalled, the links to manifests are inspected
func (o *LocalStorageCollector) OperatorImageCollector(ctx context.Context) ([]v1alpha3.CopyImageSchema, error) <span class="cov0" title="0">{

        var (
                allImages []v1alpha3.CopyImageSchema
                label     string
                dir       string
        )
        compare := make(map[string]v1alpha3.ISCPackage)
        relatedImages := make(map[string][]v1alpha3.RelatedImage)

        // compile a map to compare channels,min &amp; max versions
        for _, ops := range o.Config.Mirror.Operators </span><span class="cov0" title="0">{
                o.Log.Info("isc operators: %s\n", ops.Catalog)
                for _, pkg := range ops.Packages </span><span class="cov0" title="0">{
                        o.Log.Info("catalog packages: %s \n", pkg.Name)
                        for _, channel := range pkg.Channels </span><span class="cov0" title="0">{
                                compare[pkg.Name] = v1alpha3.ISCPackage{Channel: channel.Name, MinVersion: channel.MinVersion, MaxVersion: channel.MaxVersion, Full: ops.Full}
                                o.Log.Info("channels: %v \n", compare)
                        }</span>
                }
        }
        <span class="cov0" title="0">f, err := os.Create(logsFile)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(errMsg, err)
        }</span>
        <span class="cov0" title="0">writer := bufio.NewWriter(f)
        defer f.Close()
        for _, op := range o.Config.Mirror.Operators </span><span class="cov0" title="0">{
                // download the operator index image
                o.Log.Info("copying operator image %v", op.Catalog)
                hld := strings.Split(op.Catalog, "/")
                imageIndexDir := strings.Replace(hld[len(hld)-1], ":", "/", -1)
                cacheDir := strings.Join([]string{o.Opts.Global.Dir, operatorImageExtractDir, imageIndexDir}, "/")
                dir = strings.Join([]string{o.Opts.Global.Dir, operatorImageDir, imageIndexDir}, "/")
                if _, err := os.Stat(cacheDir); errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        err := os.MkdirAll(dir, 0755)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>
                        <span class="cov0" title="0">src := dockerProtocol + op.Catalog
                        dest := ociProtocolTrimmed + dir
                        err = o.Mirror.Run(ctx, src, dest, "copy", &amp;o.Opts, *writer)
                        writer.Flush()
                        if err != nil </span><span class="cov0" title="0">{
                                o.Log.Error(errMsg, err)
                        }</span>
                        // read the logs
                        <span class="cov0" title="0">f, _ := os.ReadFile(logsFile)
                        lines := strings.Split(string(f), "\n")
                        for _, s := range lines </span><span class="cov0" title="0">{
                                if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                        o.Log.Debug("%s ", strings.ToLower(s))
                                }</span>
                        }
                }

                // it's in oci format so we can go directly to the index.json file
                <span class="cov0" title="0">oci, err := o.Manifest.GetImageIndex(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, err
                }</span>

                //read the link to the manifest
                <span class="cov0" title="0">if len(oci.Manifests) == 0 </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf("[OperatorImageCollector] no manifests found for %s ", op.Catalog)
                }</span> else<span class="cov0" title="0"> {
                        if !strings.Contains(oci.Manifests[0].Digest, "sha256") </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf("[OperatorImageCollector] the disgets seems to incorrect for %s ", op.Catalog)
                        }</span>
                }
                <span class="cov0" title="0">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
                o.Log.Info("manifest %v", manifest)

                // read the operator image manifest
                manifestDir := strings.Join([]string{dir, blobsDir, manifest}, "/")
                oci, err = o.Manifest.GetImageManifest(manifestDir)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, err
                }</span>

                // read the config digest to get the detailed manifest
                // looking for the lable to search for a specific folder
                <span class="cov0" title="0">catalogDir := strings.Join([]string{dir, blobsDir, strings.Split(oci.Config.Digest, ":")[1]}, "/")
                ocs, err := o.Manifest.GetOperatorConfig(catalogDir)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, err
                }</span>

                <span class="cov0" title="0">label = ocs.Config.Labels.OperatorsOperatorframeworkIoIndexConfigsV1
                o.Log.Info("label %s", label)

                // untar all the blobs for the operator
                // if the layer with "label (from previous step) is found to a specific folder"
                fromDir := strings.Join([]string{dir, blobsDir}, "/")
                err = o.Manifest.ExtractLayersOCI(fromDir, cacheDir, label, oci)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, err
                }</span>

                // select all packages
                // this is the equivalent of the headOnly mode
                // only the latest version of each operator will be selected
                <span class="cov0" title="0">if len(op.Packages) == 0 </span><span class="cov0" title="0">{
                        relatedImages, err = o.Manifest.GetRelatedImagesFromCatalog(cacheDir, label)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // iterate through each package
                        relatedImages, err = o.Manifest.GetRelatedImagesFromCatalogByFilter(cacheDir, label, op, compare)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>
                }
                <span class="cov0" title="0">relatedImages["index"] = []v1alpha3.RelatedImage{
                        {
                                Name:  "index",
                                Image: op.Catalog,
                        },
                }</span>
        }

        <span class="cov0" title="0">o.Log.Info("related images length %d ", len(relatedImages))
        var count = 0
        for _, v := range relatedImages </span><span class="cov0" title="0">{
                count = count + len(v)
        }</span>
        <span class="cov0" title="0">o.Log.Info("images to copy (before duplicates) %d ", count)
        // check the mode
        if o.Opts.Mode == mirrorToDisk </span><span class="cov0" title="0">{

                allImages, err = o.prepareM2DCopyBatch(o.Log, dir, relatedImages)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, err
                }</span>
        }

        <span class="cov0" title="0">if o.Opts.Mode == diskToMirror </span><span class="cov0" title="0">{
                allImages, err = o.prepareD2MCopyBatch(o.Log, dir, relatedImages)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, err
                }</span>
        }
        <span class="cov0" title="0">return allImages, nil</span>
}

func (o *LocalStorageCollector) prepareD2MCopyBatch(log clog.PluggableLoggerInterface, dir string, images map[string][]v1alpha3.RelatedImage) ([]v1alpha3.CopyImageSchema, error) <span class="cov0" title="0">{
        var result []v1alpha3.CopyImageSchema
        for _, relatedImgs := range images </span><span class="cov0" title="0">{
                for _, img := range relatedImgs </span><span class="cov0" title="0">{
                        // TODO Make this more complete
                        // This logic will be useful for operators and releases
                        // strip the domain name from the img.Name
                        var src string
                        var dest string

                        domainAndPathComps := img.Image
                        // pathComponents := img.Name
                        // temporarily strip out the transport
                        transportAndRef := strings.Split(domainAndPathComps, "://")
                        if len(transportAndRef) &gt; 1 </span><span class="cov0" title="0">{
                                domainAndPathComps = transportAndRef[1]
                        }</span>
                        <span class="cov0" title="0">src = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, img.Image}, "/")

                        if isImageByDigest(img.Image) </span><span class="cov0" title="0">{
                                dest = strings.Join([]string{o.Opts.Destination, imageName(img.Image) + ":" + imageHash(img.Image)[:hashTruncLen]}, "/")
                        }</span> else<span class="cov0" title="0"> {
                                dest = strings.Join([]string{o.Opts.Destination, img.Image}, "/")
                        }</span>

                        // the following is for having the destination without the initial domain name =&gt; later
                        // domainAndPathCompsArray := strings.Split(domainAndPathComps, "/")
                        // if len(domainAndPathCompsArray) &gt; 2 {
                        //         pathComponents = strings.Join(domainAndPathCompsArray[1:], "/")
                        // } else {
                        //         return allImages, fmt.Errorf("unable to parse image %s correctly", img.Name)
                        // }
                        // src = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, pathComponents}, "/")
                        // dst = strings.Join([]string{o.Opts.Destination, pathComponents}, "/") // already has a transport protocol

                        <span class="cov0" title="0">if src == "" || dest == "" </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("unable to determine src %s or dst %s for %s", src, dest, img.Name)
                        }</span>

                        <span class="cov0" title="0">o.Log.Debug("source %s", src)
                        o.Log.Debug("destination %s", dest)
                        result = append(result, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>
                }
        }
        <span class="cov0" title="0">return result, nil</span>
}

func (o *LocalStorageCollector) prepareM2DCopyBatch(log clog.PluggableLoggerInterface, dir string, images map[string][]v1alpha3.RelatedImage) ([]v1alpha3.CopyImageSchema, error) <span class="cov0" title="0">{
        var result []v1alpha3.CopyImageSchema
        for _, relatedImgs := range images </span><span class="cov0" title="0">{
                for _, img := range relatedImgs </span><span class="cov0" title="0">{
                        imgRef := img.Image
                        var src string
                        var dest string
                        // no transport was provided, assume docker://
                        if !strings.Contains(src, "://") </span><span class="cov0" title="0">{
                                src = dockerProtocol + imgRef
                        }</span> else<span class="cov0" title="0"> {
                                transportAndRef := strings.Split(imgRef, "://")
                                // because we are reusing this to construct dest
                                imgRef = transportAndRef[1]
                        }</span>

                        <span class="cov0" title="0">if isImageByDigest(imgRef) </span><span class="cov0" title="0">{
                                dest = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, imageName(imgRef) + ":" + imageHash(imgRef)[:hashTruncLen]}, "/")
                        }</span> else<span class="cov0" title="0"> {
                                dest = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, imgRef}, "/")
                        }</span>

                        <span class="cov0" title="0">o.Log.Debug("source %s", src)
                        o.Log.Debug("destination %s", dest)
                        result = append(result, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>

                }
        }
        <span class="cov0" title="0">return result, nil</span>
}

func isImageByDigest(imgRef string) bool <span class="cov0" title="0">{
        return strings.Contains(imgRef, "@")
}</span>

func imageName(imgRef string) string <span class="cov0" title="0">{
        var imageName string
        imgSplit := strings.Split(imgRef, "@")
        if len(imgSplit) &gt; 1 </span><span class="cov0" title="0">{
                imageName = imgSplit[0]
        }</span>

        <span class="cov0" title="0">return imageName</span>
}

func imageHash(imgRef string) string <span class="cov0" title="0">{
        var hash string
        imgSplit := strings.Split(imgRef, "@")
        if len(imgSplit) &gt; 1 </span><span class="cov0" title="0">{
                hash = strings.Split(imgSplit[1], ":")[1]
        }</span>

        <span class="cov0" title="0">return hash</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package operator

import (
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
)


func New(log clog.PluggableLoggerInterface,
                config v1alpha2.ImageSetConfiguration,
                opts mirror.CopyOptions,
                mirror mirror.MirrorInterface,
                manifest manifest.ManifestInterface,
                localStorageFQDN string,
) CollectorInterface <span class="cov0" title="0">{
        if localStorageFQDN != "" </span><span class="cov0" title="0">{
                return &amp;LocalStorageCollector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest, LocalStorageFQDN: localStorageFQDN}
        }</span> else<span class="cov0" title="0"> {
                return &amp;Collector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest}
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package release

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/blang/semver/v4"
        "github.com/google/uuid"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"

        //nolint
        "golang.org/x/crypto/openpgp"
)

const (
        SignatureURL    string = "https://mirror.openshift.com/pub/openshift-v4/signatures/openshift/release/"
        SignatureDir    string = "/signatures/"
        ContentType     string = "Content-Type"
        ApplicationJson string = "application/json"
)

type CincinnatiInterface interface {
        GetReleaseReferenceImages(context.Context) []v1alpha3.CopyImageSchema
        NewOCPClient(uuid.UUID) (Client, error)
        NewOKDClient(uuid.UUID) (Client, error)
}

type SignatureInterface interface {
        GenerateReleaseSignatures(context.Context, []v1alpha3.CopyImageSchema) ([]v1alpha3.CopyImageSchema, error)
}

func NewCincinnati(log clog.PluggableLoggerInterface, config *v1alpha2.ImageSetConfiguration, opts *mirror.CopyOptions, c Client, b bool, sig SignatureInterface) CincinnatiInterface <span class="cov8" title="1">{
        return &amp;CincinnatiSchema{Log: log, Config: config, Opts: opts, Client: c, Fail: b, Signature: sig}
}</span>

func NewSignatureClient(log clog.PluggableLoggerInterface, config *v1alpha2.ImageSetConfiguration, opts *mirror.CopyOptions) SignatureInterface <span class="cov0" title="0">{
        return &amp;SignatureSchema{Log: log, Config: config, Opts: opts}
}</span>

type SignatureSchema struct {
        Log    clog.PluggableLoggerInterface
        Config *v1alpha2.ImageSetConfiguration
        Opts   *mirror.CopyOptions
}

type CincinnatiSchema struct {
        Log       clog.PluggableLoggerInterface
        Config    *v1alpha2.ImageSetConfiguration
        Opts      *mirror.CopyOptions
        Client    Client
        Signature SignatureInterface
        Fail      bool
}

var (
        pk = `-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBErgSTsBEACh2A4b0O9t+vzC9VrVtL1AKvUWi9OPCjkvR7Xd8DtJxeeMZ5eF
0HtzIG58qDRybwUe89FZprB1ffuUKzdE+HcL3FbNWSSOXVjZIersdXyH3NvnLLLF
0DNRB2ix3bXG9Rh/RXpFsNxDp2CEMdUvbYCzE79K1EnUTVh1L0Of023FtPSZXX0c
u7Pb5DI5lX5YeoXO6RoodrIGYJsVBQWnrWw4xNTconUfNPk0EGZtEnzvH2zyPoJh
XGF+Ncu9XwbalnYde10OCvSWAZ5zTCpoLMTvQjWpbCdWXJzCm6G+/hx9upke546H
5IjtYm4dTIVTnc3wvDiODgBKRzOl9rEOCIgOuGtDxRxcQkjrC+xvg5Vkqn7vBUyW
9pHedOU+PoF3DGOM+dqv+eNKBvh9YF9ugFAQBkcG7viZgvGEMGGUpzNgN7XnS1gj
/DPo9mZESOYnKceve2tIC87p2hqjrxOHuI7fkZYeNIcAoa83rBltFXaBDYhWAKS1
PcXS1/7JzP0ky7d0L6Xbu/If5kqWQpKwUInXtySRkuraVfuK3Bpa+X1XecWi24JY
HVtlNX025xx1ewVzGNCTlWn1skQN2OOoQTV4C8/qFpTW6DTWYurd4+fE0OJFJZQF
buhfXYwmRlVOgN5i77NTIJZJQfYFj38c/Iv5vZBPokO6mffrOTv3MHWVgQARAQAB
tDNSZWQgSGF0LCBJbmMuIChyZWxlYXNlIGtleSAyKSA8c2VjdXJpdHlAcmVkaGF0
LmNvbT6JAjYEEwECACAFAkrgSTsCGwMGCwkIBwMCBBUCCAMEFgIDAQIeAQIXgAAK
CRAZni+R/UMdUWzpD/9s5SFR/ZF3yjY5VLUFLMXIKUztNN3oc45fyLdTI3+UClKC
2tEruzYjqNHhqAEXa2sN1fMrsuKec61Ll2NfvJjkLKDvgVIh7kM7aslNYVOP6BTf
C/JJ7/ufz3UZmyViH/WDl+AYdgk3JqCIO5w5ryrC9IyBzYv2m0HqYbWfphY3uHw5
un3ndLJcu8+BGP5F+ONQEGl+DRH58Il9Jp3HwbRa7dvkPgEhfFR+1hI+Btta2C7E
0/2NKzCxZw7Lx3PBRcU92YKyaEihfy/aQKZCAuyfKiMvsmzs+4poIX7I9NQCJpyE
IGfINoZ7VxqHwRn/d5mw2MZTJjbzSf+Um9YJyA0iEEyD6qjriWQRbuxpQXmlAJbh
8okZ4gbVFv1F8MzK+4R8VvWJ0XxgtikSo72fHjwha7MAjqFnOq6eo6fEC/75g3NL
Ght5VdpGuHk0vbdENHMC8wS99e5qXGNDued3hlTavDMlEAHl34q2H9nakTGRF5Ki
JUfNh3DVRGhg8cMIti21njiRh7gyFI2OccATY7bBSr79JhuNwelHuxLrCFpY7V25
OFktl15jZJaMxuQBqYdBgSay2G0U6D1+7VsWufpzd/Abx1/c3oi9ZaJvW22kAggq
dzdA27UUYjWvx42w9menJwh/0jeQcTecIUd0d0rFcw/c1pvgMMl/Q73yzKgKY5kC
DQRJpAMwARAAtv3O2z9ZR0N10nMWyJNC0FntWDoom0AUS8H/EouT5LYLbj4m05Cq
WY8PKeA/nzO4w9VlM1BNF+7V4Npf3lJTDOHcOlyQENQJhDrZcEoO66zLU7zNAARL
SOypunwurFOkbQTHXKg9XB/+nW7H4fJrs51QO1JV/j0QR1c3Vs4+svIfOHQY6IM3
G2LvR3s6oI/5S84nKrEmT8/VHV4kU0QCIafFd9AQ/LkWmmtCgw5w+iMyb9w/T8UF
mxTOGddhjfS8nmapg+26Ss2Zlxv93a7311YrF2l6dzNO7dzZQWtw7fDRSCmdAxUV
wc+W788UVZnR+g7ZA1lwzzrflnZta2awjq8khaQWUEaR8NdnqNTNZYqwDSKL+2fl
dUIf2gcY+RFLt9rvWaYwDzzbUBehfyo2qBxx5hEALo+Ay3seC2OuOh79a3L9okBb
gnbyykBkohQa32R9I/yF9/9CV0JWc29zLjBT8S1xgKAFfVD/0sP1k5gLk8xVZhtd
1GBXjMK06DoqnF9lXCtGgtRQnEz9s+CVtz7Fr1PK1A0VGH6F6L3O3oOFZ+cB7dDQ
WLDYWIgAH99tAFCB80GWIt/CYFcLiXxbuN7SWROFYoPvkUKurbBMfRbc9xMEUXyf
c/ZhLxIonmZvr2zrzLyLophVT0gpix/myOuPSvHmZVUVrMdxFwlW9J0AEQEAAbQw
UmVkIEhhdCwgSW5jLiAoYmV0YSBrZXkgMikgPHNlY3VyaXR5QHJlZGhhdC5jb20+
iQI2BBMBAgAgBQJKUjPnAhsDBgsJCAcDAgQVAggDBBYCAwECHgECF4AACgkQk4qA
yvIVQev/bRAAtPips3inHl0Pxk1KFOo8vb7ZBQha5r/nO6JeF6XU7dEIagTsMupt
pilsJpvCn2H8tHAA0OMvxHKF5exbRQcGJpArhEBl4Uw5/Q71Y4aKCKufSxDAUDlv
O/UcMM0SGfHm24zFIwzxeTHz0Kj9iwbvTeCr15WaeL6MpMLrmifnG7CmUeqWetEU
Cjxyj/jYFBQtH33+12PXLjmWVhQHikYSzdiu250RysafpBC1m+kfWX62MGY1nDCD
203dZIROdy+DU36VnwJyUbZD0gzihBlZVS7S6uBxAMULdO5G7JaiEkVslxEd7kDi
Y+uA9WYiDM+rermeNuFROK8vawUdCc+eXDDMeTv54vcd8cxVIB/ErtsjNK94xEX9
uPrWzmj3+7Xm8seDinviVveYTVbLVlA8hm7OivahnyP6SArjtZzDBU6Ohqs0Og8C
2byfUHV6O7oxLckmZ37uNmsnGkPWSwtgzgkAlAWN+dB8ehS1tzueOkwL6U35NAes
fg1e5iUB+zBpkV0LBO0ywSSo6tvAp+LVadOD5sm0Mk8WXRgP/M2OqT5esclTB1ev
IUgShFU/65aLjh7sX3Zmb2tQ4Vb1Aul4+/okzE1SVAKv+FMp99T9TiZgNmtD0wgK
lpGyUoChXHLIz6E2y8sYbjEjZBGRR75Wa0ivb5z85n4kR9Dq8d8GKTE=
=syRO
-----END PGP PUBLIC KEY BLOCK-----`
)

func (o *CincinnatiSchema) NewOCPClient(uuid uuid.UUID) (Client, error) <span class="cov8" title="1">{
        if o.Fail </span><span class="cov8" title="1">{
                return o.Client, fmt.Errorf("forced cincinnati error")
        }</span>
        <span class="cov8" title="1">return o.Client, nil</span>
}

func (o *CincinnatiSchema) NewOKDClient(uuid uuid.UUID) (Client, error) <span class="cov0" title="0">{
        return o.Client, nil
}</span>

func (o *CincinnatiSchema) GetReleaseReferenceImages(ctx context.Context) []v1alpha3.CopyImageSchema <span class="cov8" title="1">{

        var (
                allImages []v1alpha3.CopyImageSchema
                errs      = []error{}
        )

        for _, arch := range o.Config.Mirror.Platform.Architectures </span><span class="cov8" title="1">{
                versionsByChannel := make(map[string]v1alpha2.ReleaseChannel, len(o.Config.Mirror.Platform.Channels))
                for _, ch := range o.Config.Mirror.Platform.Channels </span><span class="cov8" title="1">{
                        var client Client
                        var err error
                        switch ch.Type </span>{
                        case v1alpha2.TypeOCP:<span class="cov8" title="1">
                                client, err = o.NewOCPClient(o.Opts.UUID)
                                if err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, err)
                                }</span>
                        case v1alpha2.TypeOKD:<span class="cov0" title="0">
                                client, err = o.NewOKDClient(o.Opts.UUID)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, err)
                                }</span>
                        default:<span class="cov0" title="0">
                                errs = append(errs, fmt.Errorf("invalid platform type %v", ch.Type))
                                continue</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">if len(ch.MaxVersion) == 0 || len(ch.MinVersion) == 0 </span><span class="cov8" title="1">{
                                // Find channel maximum value and only set the minimum as well if heads-only is true
                                if len(ch.MaxVersion) == 0 </span><span class="cov8" title="1">{
                                        latest, err := GetChannelMinOrMax(ctx, client, arch, ch.Name, false)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }

                                        // Update version to release channel
                                        <span class="cov8" title="1">ch.MaxVersion = latest.String()
                                        o.Log.Info("detected minimum version as %s", ch.MaxVersion)
                                        if len(ch.MinVersion) == 0 &amp;&amp; ch.IsHeadsOnly() </span><span class="cov8" title="1">{
                                                //min, found := prevChannels[ch.Name]
                                                //if !found {
                                                // Starting at a new headsOnly channels
                                                min := latest.String()
                                                //}
                                                ch.MinVersion = min
                                                o.Log.Info("detected minimum version as %s\n", ch.MinVersion)
                                        }</span>
                                }

                                // Find channel minimum if full is true or just the minimum is not set
                                // in the config
                                <span class="cov8" title="1">if len(ch.MinVersion) == 0 </span><span class="cov8" title="1">{
                                        first, err := GetChannelMinOrMax(ctx, client, arch, ch.Name, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">ch.MinVersion = first.String()
                                        o.Log.Info("detected minimum version as %s\n", ch.MinVersion)</span>
                                }
                                <span class="cov8" title="1">versionsByChannel[ch.Name] = ch</span>
                        } else<span class="cov8" title="1"> {
                                // Range is set. Ensure full is true so this
                                // is skipped when processing release metadata.
                                o.Log.Info("processing minimum version %s and maximum version %s\n", ch.MinVersion, ch.MaxVersion)
                                ch.Full = true
                                versionsByChannel[ch.Name] = ch
                        }</span>

                        <span class="cov8" title="1">downloads, err := getChannelDownloads(ctx, o.Log, client, nil, ch, arch)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">allImages = append(allImages, downloads...)</span>
                }

                // Update cfg release channels with maximum and minimum versions
                // if applicable
                <span class="cov8" title="1">for i, ch := range o.Config.Mirror.Platform.Channels </span><span class="cov8" title="1">{
                        ch, found := versionsByChannel[ch.Name]
                        if found </span><span class="cov8" title="1">{
                                o.Config.Mirror.Platform.Channels[i] = ch
                        }</span>
                }

                <span class="cov8" title="1">if len(o.Config.Mirror.Platform.Channels) &gt; 1 </span><span class="cov8" title="1">{
                        client, err := NewOCPClient(o.Opts.UUID)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">newDownloads, err := getCrossChannelDownloads(ctx, o.Log, client, arch, o.Config.Mirror.Platform.Channels)
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("error calculating cross channel upgrades: %v", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">allImages = append(allImages, newDownloads...)</span>
                }
        }

        <span class="cov8" title="1">imgs, err := o.Signature.GenerateReleaseSignatures(ctx, allImages)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("error list %v ", err)
        }</span>

        <span class="cov8" title="1">for _, e := range errs </span><span class="cov8" title="1">{
                o.Log.Error("error list %v ", e)
        }</span>
        <span class="cov8" title="1">return imgs</span>
}

// getDownloads will prepare the downloads map for mirroring
func getChannelDownloads(ctx context.Context, log clog.PluggableLoggerInterface, c Client, lastChannels []v1alpha2.ReleaseChannel, channel v1alpha2.ReleaseChannel, arch string) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{
        var allImages []v1alpha3.CopyImageSchema

        var prevChannel v1alpha2.ReleaseChannel
        for _, ch := range lastChannels </span><span class="cov0" title="0">{
                if ch.Name == channel.Name </span><span class="cov0" title="0">{
                        prevChannel = ch
                }</span>
        }
        <span class="cov8" title="1">log.Trace("previous channel %v", prevChannel)
        // Plot between min and max of channel
        first, err := semver.Parse(channel.MinVersion)
        if err != nil </span><span class="cov0" title="0">{
                return allImages, err
        }</span>
        <span class="cov8" title="1">last, err := semver.Parse(channel.MaxVersion)
        if err != nil </span><span class="cov0" title="0">{
                return allImages, err
        }</span>

        <span class="cov8" title="1">var newDownloads []v1alpha3.CopyImageSchema
        if channel.ShortestPath </span><span class="cov8" title="1">{
                current, newest, updates, err := CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                if err != nil </span><span class="cov0" title="0">{
                        return allImages, err
                }</span>
                <span class="cov8" title="1">newDownloads = gatherUpdates(log, current, newest, updates)</span>

        } else<span class="cov8" title="1"> {
                lowRange, err := semver.ParseRange(fmt.Sprintf("&gt;=%s", first))
                if err != nil </span><span class="cov0" title="0">{
                        return allImages, err
                }</span>
                <span class="cov8" title="1">highRange, err := semver.ParseRange(fmt.Sprintf("&lt;=%s", last))
                if err != nil </span><span class="cov0" title="0">{
                        return allImages, err
                }</span>
                <span class="cov8" title="1">versions, err := GetUpdatesInRange(ctx, c, channel.Name, arch, highRange.AND(lowRange))
                if err != nil </span><span class="cov0" title="0">{
                        return allImages, err
                }</span>
                <span class="cov8" title="1">newDownloads = gatherUpdates(log, Update{}, Update{}, versions)</span>
        }
        <span class="cov8" title="1">allImages = append(allImages, newDownloads...)

        return allImages, nil</span>
}

// getCrossChannelDownloads will determine required downloads between channel versions (for OCP only)
func getCrossChannelDownloads(ctx context.Context, log clog.PluggableLoggerInterface, ocpClient Client, arch string, channels []v1alpha2.ReleaseChannel) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{
        // Strip any OKD channels from the list

        var ocpChannels []v1alpha2.ReleaseChannel
        for _, ch := range channels </span><span class="cov8" title="1">{
                if ch.Type == v1alpha2.TypeOCP </span><span class="cov8" title="1">{
                        ocpChannels = append(ocpChannels, ch)
                }</span>
        }
        // If no other channels exist, return no downloads
        <span class="cov8" title="1">if len(ocpChannels) == 0 </span><span class="cov0" title="0">{
                return []v1alpha3.CopyImageSchema{}, nil
        }</span>

        <span class="cov8" title="1">firstCh, first, err := FindRelease(ocpChannels, true)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.CopyImageSchema{}, fmt.Errorf("failed to find minimum release version: %v", err)
        }</span>
        <span class="cov8" title="1">lastCh, last, err := FindRelease(ocpChannels, false)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.CopyImageSchema{}, fmt.Errorf("failed to find maximum release version: %v", err)
        }</span>
        <span class="cov8" title="1">current, newest, updates, err := CalculateUpgrades(ctx, ocpClient, arch, firstCh, lastCh, first, last)
        if err != nil </span><span class="cov8" title="1">{
                return []v1alpha3.CopyImageSchema{}, fmt.Errorf("failed to get upgrade graph: %v", err)
        }</span>
        <span class="cov0" title="0">return gatherUpdates(log, current, newest, updates), nil</span>
}

// gatherUpdates
func gatherUpdates(log clog.PluggableLoggerInterface, current, newest Update, updates []Update) []v1alpha3.CopyImageSchema <span class="cov8" title="1">{
        var allImages []v1alpha3.CopyImageSchema
        for _, update := range updates </span><span class="cov8" title="1">{
                log.Info("Found update %s\n", update.Version)
                allImages = append(allImages, v1alpha3.CopyImageSchema{Source: update.Image, Destination: ""})
        }</span>

        <span class="cov8" title="1">if current.Image != "" </span><span class="cov8" title="1">{
                allImages = append(allImages, v1alpha3.CopyImageSchema{Source: current.Image, Destination: ""})
        }</span>

        <span class="cov8" title="1">if newest.Image != "" </span><span class="cov8" title="1">{
                allImages = append(allImages, v1alpha3.CopyImageSchema{Source: newest.Image, Destination: ""})
        }</span>

        <span class="cov8" title="1">return allImages</span>
}

// GenerateReleaseSignatures
func (o *SignatureSchema) GenerateReleaseSignatures(ctx context.Context, rd []v1alpha3.CopyImageSchema) ([]v1alpha3.CopyImageSchema, error) <span class="cov0" title="0">{

        var data []byte
        var err error
        var imgs []v1alpha3.CopyImageSchema
        // set up http object
        tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: false},
        }
        httpClient := &amp;http.Client{Transport: tr}

        for _, image := range rd </span><span class="cov0" title="0">{
                digest := strings.Split(image.Source, ":")[1]
                // check if the image is in the cache else
                // do a lookup and download it to cache
                data, err = os.ReadFile(o.Opts.Global.Dir + SignatureDir + digest)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                o.Log.Warn("signature for %s not in cache", digest)
                        }</span>
                }

                <span class="cov0" title="0">o.Log.Info("signature %s", digest)

                // we have the current digest in cache
                if len(data) == 0 </span><span class="cov0" title="0">{
                        req, _ := http.NewRequest("GET", SignatureURL+"sha256="+digest+"/signature-1", nil)
                        //req.Header.Set("Authorization", "Basic "+generic.Token)
                        req.Header.Set(ContentType, ApplicationJson)
                        resp, err := httpClient.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                o.Log.Error("http request %v", err)
                        }</span>
                        <span class="cov0" title="0">defer resp.Body.Close()
                        if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                                o.Log.Debug("response from signature lookup %d", resp.StatusCode)

                                data, err = io.ReadAll(resp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        o.Log.Error("%v", err)
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(data) &gt; 0 </span><span class="cov0" title="0">{
                        keyring, err := openpgp.ReadArmoredKeyRing(bytes.NewReader([]byte(pk)))
                        //keyring, err := openpgp.ReadKeyRing(bytes.NewReader([]byte(data)))
                        if err != nil </span><span class="cov0" title="0">{
                                o.Log.Error("%v", err)
                        }</span>
                        <span class="cov0" title="0">o.Log.Debug("keyring %v", keyring)

                        md, err := openpgp.ReadMessage(bytes.NewReader(data), keyring, nil, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                o.Log.Error("%v could not read the message:", err)
                        }</span>
                        <span class="cov0" title="0">if !md.IsSigned </span><span class="cov0" title="0">{
                                o.Log.Error("not signed")
                        }</span>
                        <span class="cov0" title="0">content, err := io.ReadAll(md.UnverifiedBody)
                        if err != nil </span><span class="cov0" title="0">{
                                o.Log.Error("%v", err)
                        }</span>
                        <span class="cov0" title="0">if md.SignatureError != nil </span><span class="cov0" title="0">{
                                o.Log.Error("signature error:", md.SignatureError)
                        }</span>
                        <span class="cov0" title="0">if md.SignedBy == nil </span><span class="cov0" title="0">{
                                o.Log.Error("invalid signature")
                        }</span>

                        <span class="cov0" title="0">o.Log.Trace("field isEncrypted %v", md.IsEncrypted)
                        o.Log.Trace("field EencryptedToKeyIds %v", md.EncryptedToKeyIds)
                        o.Log.Trace("field IsSymmetricallyEncrypted %v", md.IsSymmetricallyEncrypted)
                        o.Log.Trace("field DecryptedWith %v", md.DecryptedWith)
                        o.Log.Trace("field IsSigned %v", md.IsSigned)
                        o.Log.Trace("field SignedByKeyId %v", md.SignedByKeyId)
                        o.Log.Trace("field SignedBy %v", md.SignedBy)
                        o.Log.Trace("field LiteralData %v", md.LiteralData)
                        o.Log.Trace("field SignatureError %v", md.SignatureError)
                        o.Log.Trace("field Signature %v", md.Signature)
                        // o.Log.Trace("field SignatureV3 %v", md.SignatureV3.IssuerKeyId)
                        // o.Log.Trace("field SignatureV3 %v", md.SignatureV3.CreationTime)

                        if md.Signature != nil </span><span class="cov0" title="0">{
                                if md.Signature.SigLifetimeSecs != nil </span><span class="cov0" title="0">{
                                        expiry := md.Signature.CreationTime.Add(time.Duration(*md.Signature.SigLifetimeSecs) * time.Second)
                                        if time.Now().After(expiry) </span><span class="cov0" title="0">{
                                                o.Log.Debug("signature expired on %v ", expiry)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if md.SignatureV3 == nil </span><span class="cov0" title="0">{
                                o.Log.Error("unexpected openpgp.MessageDetails: neither Signature nor SignatureV3 is set")
                        }</span>

                        <span class="cov0" title="0">o.Log.Info("content %s", string(content))
                        // update the image with the actaul reference from the contents json
                        var signSchema *v1alpha3.SignatureContentSchema
                        err = json.Unmarshal(content, &amp;signSchema)
                        if err != nil </span><span class="cov0" title="0">{
                                o.Log.Error("could not unmarshal json %v", err)
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>
                        <span class="cov0" title="0">image.Source = signSchema.Critical.Identity.DockerReference
                        o.Log.Info("image found : %s", signSchema.Critical.Identity.DockerReference)
                        o.Log.Info("public Key : %s", strings.ToUpper(fmt.Sprintf("%x", md.SignedBy.PublicKey.Fingerprint)))

                        // write signature to cache
                        ferr := os.WriteFile(o.Opts.Global.Dir+SignatureDir+digest, data, 0644)
                        if ferr != nil </span><span class="cov0" title="0">{
                                o.Log.Error("%v", ferr)
                        }</span>
                        <span class="cov0" title="0">imgs = append(imgs, image)</span>
                } else<span class="cov0" title="0"> {
                        o.Log.Warn("no signature found for %s", digest)
                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf("no signature found for %s image %s", digest, image.Source)
                }</span>
        }
        <span class="cov0" title="0">return imgs, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package release

import (
        "crypto/tls"
        "crypto/x509"
        "net/http"
        "net/url"
        "os"

        "github.com/google/uuid"
        "k8s.io/klog/v2"
)

// Client is a Cincinnati client which can be used to fetch update graphs from
// an upstream Cincinnati stack.
type Client interface {
        GetURL() *url.URL
        SetQueryParams(arch, channel, version string)
        GetID() uuid.UUID
        GetTransport() *http.Transport
}

var _ Client = &amp;ocpClient{}

type ocpClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOCPClient creates a new OCP Cincinnati client with the given client identifier.
func NewOCPClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        var updateGraphURL string
        if updateURLOverride := os.Getenv("UPDATE_URL_OVERRIDE"); len(updateURLOverride) != 0 </span><span class="cov8" title="1">{
                klog.Info("Usage of the UPDATE_URL_OVERRIDE environment variable is unsupported")
                updateGraphURL = updateURLOverride
        }</span> else<span class="cov8" title="1"> {
                updateGraphURL = UpdateURL
        }</span>
        <span class="cov8" title="1">upstream, err := url.Parse(updateGraphURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;ocpClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *ocpClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *ocpClient) GetTransport() *http.Transport <span class="cov8" title="1">{
        return c.transport
}</span>

func (c *ocpClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *ocpClient) SetQueryParams(arch, channel, version string) <span class="cov8" title="1">{
        queryParams := c.url.Query()
        queryParams.Add("id", c.id.String())
        params := map[string]string{
                "arch":    arch,
                "channel": channel,
                "version": version,
        }
        for key, value := range params </span><span class="cov8" title="1">{
                if value != "" </span><span class="cov8" title="1">{
                        queryParams.Add(key, value)
                }</span>
        }
        <span class="cov8" title="1">c.url.RawQuery = queryParams.Encode()</span>
}

var _ Client = &amp;okdClient{}

type okdClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOKDClient creates a new OKD Cincinnati client with the given client identifier.
func NewOKDClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        upstream, err := url.Parse(OkdUpdateURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;okdClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *okdClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *okdClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *okdClient) GetTransport() *http.Transport <span class="cov0" title="0">{
        return c.transport
}</span>

func (c *okdClient) SetQueryParams(_, _, _ string) {<span class="cov8" title="1">
        // Do nothing
}</span>

func getTLSConfig() (*tls.Config, error) <span class="cov8" title="1">{
        certPool, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config := &amp;tls.Config{
                RootCAs:    certPool,
                MinVersion: tls.VersionTLS12,
        }
        return config, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package release

import (
        "bufio"
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
)

const (
        indexJson                   string = "manifest.json"
        operatorImageExtractDir     string = "hold-operator"
        workingDir                  string = "working-dir"
        dockerProtocol              string = "docker://"
        ociProtocol                 string = "oci://"
        ociProtocolTrimmed          string = "oci:"
        dirProtocol                 string = "dir://"
        dirProtocolTrimmed          string = "dir:"
        releaseImageDir             string = "release-images"
        releaseIndex                string = "release-index"
        releaseFiltersDir           string = "release-filters"
        operatorImageDir            string = "operator-images"
        releaseImageExtractDir      string = "hold-release"
        releaseManifests            string = "release-manifests"
        imageReferences             string = "image-references"
        releaseImageExtractFullPath string = releaseManifests + "/" + imageReferences
        blobsDir                    string = "blobs/sha256"
        errMsg                      string = "[ReleaseImageCollector] %v "
        diskToMirror                string = "diskToMirror"
        mirrorToDisk                string = "mirrorToDisk"
        logFile                     string = "logs/release.log"
)

type CollectorInterface interface {
        ReleaseImageCollector(ctx context.Context) ([]v1alpha3.CopyImageSchema, error)
}

func New(log clog.PluggableLoggerInterface,
        config v1alpha2.ImageSetConfiguration,
        opts mirror.CopyOptions,
        mirror mirror.MirrorInterface,
        manifest manifest.ManifestInterface,
        cincinnati CincinnatiInterface,
) CollectorInterface <span class="cov0" title="0">{
        return &amp;Collector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest, Cincinnati: cincinnati}
}</span>

type Collector struct {
        Log        clog.PluggableLoggerInterface
        Mirror     mirror.MirrorInterface
        Manifest   manifest.ManifestInterface
        Config     v1alpha2.ImageSetConfiguration
        Opts       mirror.CopyOptions
        Cincinnati CincinnatiInterface
}

// ReleaseImageCollector - this looks into the operator index image
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded (preserve originator format could be dockckerv2 or oci)
// and the index.json is inspected once unmarshalled, the links to manifests are then inspected
func (o *Collector) ReleaseImageCollector(ctx context.Context) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{

        var allImages []v1alpha3.CopyImageSchema
        var imageIndexDir string

        if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                releases := o.Cincinnati.GetReleaseReferenceImages(ctx)
                f, err := os.Create(logFile)
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error("[ReleaseImageCollector] %v", err)
                }</span>

                <span class="cov8" title="1">writer := bufio.NewWriter(f)
                defer f.Close()
                for _, value := range releases </span><span class="cov8" title="1">{
                        hld := strings.Split(value.Source, "/")
                        imageIndexDir = strings.Replace(hld[len(hld)-1], ":", "/", -1)
                        cacheDir := strings.Join([]string{o.Opts.Global.Dir, releaseImageExtractDir, imageIndexDir}, "/")
                        dir := strings.Join([]string{o.Opts.Global.Dir, releaseImageDir, imageIndexDir}, "/")
                        if _, err := os.Stat(dir); errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                                o.Log.Info("copying  %s ", value.Source)
                                err := os.MkdirAll(dir, 0755)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                                }</span>
                                <span class="cov8" title="1">src := dockerProtocol + value.Source
                                dest := ociProtocolTrimmed + dir
                                err = o.Mirror.Run(ctx, src, dest, "copy", &amp;o.Opts, *writer)
                                if err != nil </span><span class="cov8" title="1">{
                                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                                }</span>
                                <span class="cov8" title="1">o.Log.Debug("copied release index image %s ", value.Source)

                                // TODO: create common function to show logs
                                f, _ := os.ReadFile(logFile)
                                lines := strings.Split(string(f), "\n")
                                for _, s := range lines </span><span class="cov8" title="1">{
                                        if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                                o.Log.Debug(" %s ", strings.ToLower(s))
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                o.Log.Info("cache release-index directory exists %s", cacheDir)
                        }</span>

                        <span class="cov8" title="1">oci, err := o.Manifest.GetImageIndex(dir)
                        if err != nil </span><span class="cov8" title="1">{
                                o.Log.Error("[ReleaseImageCollector] %v ", err)
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>

                        //read the link to the manifest
                        <span class="cov8" title="1">if len(oci.Manifests) == 0 </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, "image index not found ")
                        }</span>
                        <span class="cov8" title="1">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
                        o.Log.Debug("image index %v", manifest)

                        manifestDir := strings.Join([]string{dir, blobsDir, manifest}, "/")
                        mfst, err := o.Manifest.GetImageManifest(manifestDir)
                        if err != nil </span><span class="cov8" title="1">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>
                        <span class="cov8" title="1">o.Log.Debug("manifest %v ", oci.Config.Digest)

                        fromDir := strings.Join([]string{dir, blobsDir}, "/")
                        err = o.Manifest.ExtractLayersOCI(fromDir, cacheDir, releaseManifests, mfst)
                        if err != nil </span><span class="cov8" title="1">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>
                        <span class="cov8" title="1">o.Log.Debug("extracted layer %s ", cacheDir)

                        // overkill but its used for consistency
                        releaseDir := strings.Join([]string{cacheDir, releaseImageExtractFullPath}, "/")
                        allRelatedImages, err := o.Manifest.GetReleaseSchema(releaseDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>

                        <span class="cov8" title="1">tmpImages, err := batcWorkerConverter(o.Log, dir, allRelatedImages)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>

                        // need to append images
                        <span class="cov8" title="1">allImages = append(allImages, tmpImages...)</span>
                }
        }
        <span class="cov8" title="1">if o.Opts.Mode == diskToMirror &amp;&amp; strings.Contains(o.Config.Mirror.Platform.Release, dirProtocol) </span><span class="cov0" title="0">{
                // we know the directory format is
                // release-images/name/version/
                // we can do some replacing from the directory passed as string
                // so tha twe can access the image-references
                str := strings.Replace(o.Config.Mirror.Platform.Release, "release-images", "hold-release", 1)
                // remove the file prefix
                str = strings.Replace(str, "dir://", "", 1)

                // get all release images from manifest (json)
                allRelatedImages, err := o.Manifest.GetReleaseSchema(str + "/" + releaseImageExtractFullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                }</span>

                // set up a regex for the manifest.json (checked in each directory)
                <span class="cov0" title="0">regex, e := regexp.Compile(indexJson)
                if e != nil </span><span class="cov0" title="0">{
                        o.Log.Error("%v", e)
                }</span>

                // walk through the directory structure to look for manifest.json files
                // get the base directory and do a lookup on the actual image to mirror
                <span class="cov0" title="0">imagesDir := strings.Replace(o.Config.Mirror.Platform.Release, "dir://", "", 1)
                imagesDir = imagesDir + "/images"
                errFP := filepath.Walk(imagesDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err == nil &amp;&amp; regex.MatchString(info.Name()) </span><span class="cov0" title="0">{
                                component := strings.Split(filepath.Dir(path), "/")
                                img := findRelatedImage(component[len(component)-1], allRelatedImages)
                                if len(img) &gt; 0 </span><span class="cov0" title="0">{
                                        src := dirProtocolTrimmed + filepath.Dir(path)
                                        dest := o.Opts.Destination + "/" + img
                                        allImages = append(allImages, v1alpha3.CopyImageSchema{Source: src, Destination: dest})
                                }</span> else<span class="cov0" title="0"> {
                                        o.Log.Warn("component not found %s", component[len(component)-1])
                                }</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if errFP != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, e
                }</span>
        }
        <span class="cov8" title="1">return allImages, nil</span>
}

// batchWorkerConverter convert RelatedImages to strings for batch worker
func batcWorkerConverter(log clog.PluggableLoggerInterface, dir string, images []v1alpha3.RelatedImage) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{
        var result []v1alpha3.CopyImageSchema
        for _, img := range images </span><span class="cov8" title="1">{
                src := dockerProtocol + img.Image
                dest := dirProtocolTrimmed + strings.Join([]string{dir, "images", img.Name}, "/")
                // do a lookup on dist first
                if _, err := os.Stat(dir + "/images/" + img.Name); errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                        err := os.MkdirAll(dir+"/images/"+img.Name, 0750)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("[batchWorkerConverter] %v", err)
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>
                        <span class="cov8" title="1">log.Debug("source %s ", src)
                        log.Debug("destination %s ", dest)
                        result = append(result, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>
                } else<span class="cov0" title="0"> {
                        log.Info("image in cache %s ", dir+"/images/"+img.Name)
                }</span>

        }
        <span class="cov8" title="1">return result, nil</span>
}

// findRelatedImage
func findRelatedImage(name string, imgs []v1alpha3.RelatedImage) string <span class="cov0" title="0">{
        for _, img := range imgs </span><span class="cov0" title="0">{
                if name == img.Name </span><span class="cov0" title="0">{
                        strip := strings.Split(img.Image, "/")
                        return strings.Join(strip[1:], "/")
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package release

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/blang/semver/v4"
        "k8s.io/klog/v2"
)

const (
        // GraphMediaType is the media-type specified in the HTTP Accept header
        // of requests sent to the Cincinnati-v1 Graph API.
        GraphMediaType = "application/json"

        // Timeout when calling upstream Cincinnati stack.
        getUpdatesTimeout = time.Minute * 60
        // UpdateURL is the Cincinnati endpoint for the OpenShift platform.
        UpdateURL = "https://api.openshift.com/api/upgrades_info/v1/graph"
        // OkdUpdateURL is the Cincinnati endpoint for the OKD platform.
        OkdUpdateURL = "https://origin-release.ci.openshift.org/graph"

        ChannelInfo = "channel %q: %v"
)

// Error is returned when are unable to get updates.
type Error struct {
        // Reason is the reason suggested for the Cincinnati calculation error.
        Reason string

        // Message is the message suggested for Cincinnati calculation error..
        Message string

        // cause is the upstream error, if any, being wrapped by this error.
        cause error
}

// Error serializes the error as a string, to satisfy the error interface.
func (err *Error) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", err.Reason, err.Message)
}</span>

// Update is a single node from the update graph.
type Update node

// GetUpdates fetches the requested update payload from the specified
// upstream Cincinnati stack given the current version, architecture, and channel.
// The shortest path is calculated between the current and requested version from the graph edge
// data.
func GetUpdates(ctx context.Context, c Client, arch string, channel string, version semver.Version, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        var current Update
        var requested Update
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, version.String())

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("version %s in channel %s: %v", version.String(), channel, err),
                        cause:   err,
                }
        }</span>

        // Find the current version within the graph.
        <span class="cov8" title="1">var currentIdx int
        found := false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if version.EQ(node.Version) </span><span class="cov8" title="1">{
                        currentIdx = i
                        current = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("current version %s not found in the %q channel", version, channel),
                }
        }</span>

        <span class="cov8" title="1">var destinationIdx int
        found = false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if reqVer.EQ(node.Version) </span><span class="cov8" title="1">{
                        destinationIdx = i
                        requested = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("requested version %s not found in the %q channel", reqVer, channel),
                }
        }</span>

        <span class="cov8" title="1">edgesByOrigin := make(map[int][]int, len(graph.Nodes))
        for _, edge := range graph.Edges </span><span class="cov8" title="1">{
                edgesByOrigin[edge.Origin] = append(edgesByOrigin[edge.Origin], edge.Destination)
        }</span>

        // Sort destination by semver to ensure deterministic result
        <span class="cov8" title="1">for origin, destinations := range edgesByOrigin </span><span class="cov8" title="1">{
                sort.Slice(destinations, func(i, j int) bool </span><span class="cov8" title="1">{
                        return graph.Nodes[destinations[i]].Version.GT(graph.Nodes[destinations[j]].Version)
                }</span>)
                <span class="cov8" title="1">edgesByOrigin[origin] = destinations</span>
        }

        <span class="cov8" title="1">shortestPath := func(g map[int][]int, start, end int) []int </span><span class="cov8" title="1">{
                prev := map[int]int{}
                visited := map[int]struct{}{}
                queue := []int{start}
                visited[start] = struct{}{}
                prev[start] = -1

                for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                        node := queue[0]
                        queue = queue[1:]
                        if node == end </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">for _, neighbor := range g[node] </span><span class="cov8" title="1">{
                                if _, ok := visited[neighbor]; !ok </span><span class="cov8" title="1">{
                                        prev[neighbor] = node
                                        queue = append(queue, neighbor)
                                        visited[neighbor] = struct{}{}
                                }</span>
                        }
                }

                // No path to end
                <span class="cov8" title="1">if _, ok := visited[end]; !ok </span><span class="cov8" title="1">{
                        return []int{}
                }</span>

                <span class="cov8" title="1">path := []int{end}
                for next := prev[end]; next != -1; next = prev[next] </span><span class="cov8" title="1">{
                        path = append(path, next)
                }</span>

                // Reverse path.
                <span class="cov8" title="1">for i, j := 0, len(path)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                        path[i], path[j] = path[j], path[i]
                }</span>

                <span class="cov8" title="1">return path</span>
        }

        <span class="cov8" title="1">nextIdxs := shortestPath(edgesByOrigin, currentIdx, destinationIdx)

        var updates []Update
        for _, i := range nextIdxs </span><span class="cov8" title="1">{
                updates = append(updates, Update(graph.Nodes[i]))
        }</span>

        <span class="cov8" title="1">return current, requested, updates, nil</span>
}

// CalculateUpgrades fetches and calculates all the update payloads from the specified
// upstream Cincinnati stack given the current and target version and channel.
func CalculateUpgrades(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        if sourceChannel == targetChannel </span><span class="cov8" title="1">{
                return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)
        }</span>

        // Check the major and minor versions are the same with different
        // channel prefixes
        <span class="cov8" title="1">source, target, _, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                isBlocked, err := handleBlockedEdges(ctx, c, arch, targetChannel, startVer)
                if err != nil </span><span class="cov0" title="0">{
                        return Update{}, Update{}, nil, err
                }</span>
                <span class="cov8" title="1">if isBlocked </span><span class="cov0" title="0">{
                        // If blocked path is found, just return the requested version and any accumulated
                        // upgrades to the caller
                        klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                        return GetUpdates(ctx, c, arch, targetChannel, reqVer, reqVer)
                }</span>
                <span class="cov8" title="1">return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)</span>
        }

        // Perform initial calculation for the source channel and
        // recurse through the rest until the target or a blocked
        // edge is hit.
        <span class="cov8" title="1">latest, err := GetChannelMinOrMax(ctx, c, arch, sourceChannel, false)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, fmt.Errorf(ChannelInfo, sourceChannel, err)
        }</span>
        <span class="cov8" title="1">current, _, upgrades, err := GetUpdates(ctx, c, arch, sourceChannel, startVer, latest)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, fmt.Errorf(ChannelInfo, sourceChannel, err)
        }</span>

        <span class="cov8" title="1">requested, newUpgrades, err := calculate(ctx, c, arch, sourceChannel, targetChannel, latest, reqVer)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">upgrades = append(upgrades, newUpgrades...)

        var finalUpgrades []Update
        seen := make(map[string]struct{}, len(upgrades))
        for _, upgrade := range upgrades </span><span class="cov8" title="1">{
                if _, ok := seen[upgrade.Image]; !ok </span><span class="cov8" title="1">{
                        finalUpgrades = append(finalUpgrades, upgrade)
                        seen[upgrade.Image] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">return current, requested, finalUpgrades, nil</span>
}

// calculate will calculate Cincinnati upgrades between channels by finding the latest versions in the source channels
// and incrementing the minor version until the target channel is reached.
func calculate(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (requested Update, upgrades []Update, err error) <span class="cov8" title="1">{
        source, target, prefix, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        // We immediately bump the source channel since current source channel upgrades have
        // already been calculated
        <span class="cov8" title="1">source.Minor++
        currChannel := fmt.Sprintf("%s-%v.%v", prefix, source.Major, source.Minor)

        var targetVer semver.Version
        if source.EQ(target) </span><span class="cov8" title="1">{
                // If this is the target channel major.minor get
                // requested version, so we don't exceed the maximum version
                // Set the target channel to make sure we have the intended
                // channel prefix
                targetVer = reqVer
                currChannel = targetChannel
        }</span> else<span class="cov8" title="1"> {
                targetVer, err = GetChannelMinOrMax(ctx, c, arch, currChannel, false)
                if err != nil </span><span class="cov0" title="0">{
                        return requested, upgrades, err
                }</span>
        }

        <span class="cov8" title="1">isBlocked, err := handleBlockedEdges(ctx, c, arch, currChannel, startVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">if isBlocked </span><span class="cov8" title="1">{
                // If blocked path is found, just return the requested version and any accumulated
                // upgrades to the caller
                _, requested, _, err = GetUpdates(ctx, c, arch, targetChannel, targetVer, targetVer)
                //Warnf is 5?
                klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">klog.V(1).Infof("Getting updates for version %s in channel %s", startVer.String(), currChannel)
        _, requested, upgrades, err = GetUpdates(ctx, c, arch, currChannel, startVer, targetVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                return requested, upgrades, nil
        }</span>

        <span class="cov8" title="1">currRequested, currUpgrades, err := calculate(ctx, c, arch, currChannel, targetChannel, targetVer, reqVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">requested = currRequested
        upgrades = append(upgrades, currUpgrades...)

        return requested, upgrades, nil</span>
}

// handleBlockedEdges will check for the starting version in the current channel
// if it does not exist the version is blocked.
func handleBlockedEdges(ctx context.Context, c Client, arch, targetChannel string, startVer semver.Version) (bool, error) <span class="cov8" title="1">{
        chanVersions, err := GetVersions(ctx, c, arch, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return true, err
        }</span>
        <span class="cov8" title="1">for _, v := range chanVersions </span><span class="cov8" title="1">{
                if v.EQ(startVer) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// getSemverFromChannel will return the major and minor version from the source and target channels. The prefix returned is
// for the source channels for cross channel calculations.
func getSemverFromChannels(sourceChannel, targetChannel string) (source, target semver.Version, prefix string, err error) <span class="cov8" title="1">{
        // Get semver representation of source and target channel versions
        sourceIdx := strings.LastIndex(sourceChannel, "-")
        if sourceIdx == -1 </span><span class="cov0" title="0">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", sourceChannel)
        }</span>
        <span class="cov8" title="1">targetIdx := strings.LastIndex(targetChannel, "-")
        if targetIdx == -1 </span><span class="cov8" title="1">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", targetChannel)
        }</span>
        <span class="cov8" title="1">source, err = semver.Parse(fmt.Sprintf("%s.0", sourceChannel[sourceIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">target, err = semver.Parse(fmt.Sprintf("%s.0", targetChannel[targetIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">prefix = sourceChannel[:sourceIdx]
        return source, target, prefix, nil</span>
}

// GetChannelMinOrMax fetches the minimum or maximum version from the specified
// upstream Cincinnati stack given architecture and channel.
func GetChannelMinOrMax(ctx context.Context, c Client, arch string, channel string, min bool) (semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return semver.Version{}, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all versions within the graph.
        <span class="cov8" title="1">var versionMatcher *regexp.Regexp
        if versionFilter := os.Getenv("VERSION_FILTER"); len(versionFilter) != 0 </span><span class="cov0" title="0">{
                klog.Info("Usage of the VERSION_FILTER environment variable is unsupported")
                versionMatcher, err = regexp.Compile(versionFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return semver.Version{}, &amp;Error{
                                Reason:  "InvalidVersionFilter",
                                Message: fmt.Sprintf("Version filter '%s' is not a valid regular expression", versionFilter),
                                cause:   err,
                        }
                }</span>
        }

        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if versionMatcher == nil || versionMatcher.MatchString(node.Version.String()) </span><span class="cov8" title="1">{
                        Vers = append(Vers, node.Version)
                }</span>
        }

        <span class="cov8" title="1">semver.Sort(Vers)

        if len(Vers) == 0 </span><span class="cov8" title="1">{
                return semver.Version{}, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found for %q in the %q channel", arch, channel),
                }
        }</span>

        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                return Vers[0], nil
        }</span>

        <span class="cov8" title="1">return Vers[len(Vers)-1], nil</span>
}

// GetChannels fetches the channels containing update payloads from the specified
// upstream Cincinnati stack.
func GetChannels(ctx context.Context, c Client, channel string) (map[string]struct{}, error) <span class="cov0" title="0">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams("", channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>

        <span class="cov0" title="0">channels := make(map[string]struct{})

        for _, node := range graph.Nodes </span><span class="cov0" title="0">{
                values := node.Metadata["io.openshift.upgrades.graph.release.channels"]

                for _, value := range strings.Split(values, ",") </span><span class="cov0" title="0">{
                        channels[value] = struct{}{}
                }</span>
        }

        <span class="cov0" title="0">return channels, nil</span>
}

// GetVersions will return all update payloads from the specified
// upstream Cincinnati stack given architecture and channel.
func GetVersions(ctx context.Context, c Client, arch, channel string) ([]semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>
        // Find the all versions within the graph.
        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{

                Vers = append(Vers, node.Version)
        }</span>

        <span class="cov8" title="1">if len(Vers) == 0 </span><span class="cov8" title="1">{
                return nil, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found in the %q channel", channel),
                }
        }</span>

        <span class="cov8" title="1">semver.Sort(Vers)

        return Vers, nil</span>
}

// GetUpdatesInRange will return all update payload within a semver range for a specified channel and architecture.
func GetUpdatesInRange(ctx context.Context, c Client, channel, arch string, updateRange semver.Range) ([]Update, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all updates within the range
        <span class="cov8" title="1">var updates []Update
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if updateRange(node.Version) </span><span class="cov8" title="1">{
                        updates = append(updates, Update(node))
                }</span>

        }
        <span class="cov8" title="1">return updates, nil</span>
}

// getGraphData fetches the update graph from the upstream Cincinnati stack given the current version and channel
func getGraphData(ctx context.Context, c Client) (graph graph, err error) <span class="cov8" title="1">{
        transport := c.GetTransport()
        uri := c.GetURL()
        // Download the update graph.
        req, err := http.NewRequest("GET", uri.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "InvalidRequest", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">req.Header.Add("Accept", GraphMediaType)
        if transport != nil &amp;&amp; transport.TLSClientConfig != nil </span><span class="cov8" title="1">{
                if c.GetTransport().TLSClientConfig.ClientCAs == nil </span><span class="cov8" title="1">{
                        klog.V(5).Infof("Using a root CA pool with 0 root CA subjects to request updates from %s", uri)
                }</span> //else {
                //klog.V(5).Infof("Using a root CA pool with %n root CA subjects to request updates from %s", len(transport.TLSClientConfig.RootCAs.Subjects()), uri)
                //}
        }

        <span class="cov8" title="1">if transport != nil &amp;&amp; transport.Proxy != nil </span><span class="cov8" title="1">{
                proxy, err := transport.Proxy(req)
                if err == nil &amp;&amp; proxy != nil </span><span class="cov0" title="0">{
                        klog.Infof("Using proxy %s to request updates from %s", proxy.Host, uri)
                }</span>
        }

        <span class="cov8" title="1">client := http.Client{}
        if transport != nil </span><span class="cov8" title="1">{
                client.Transport = transport
        }</span>
        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, getUpdatesTimeout)
        defer cancel()
        resp, err := client.Do(req.WithContext(timeoutCtx))
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "RemoteFailed", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: fmt.Sprintf("unexpected HTTP status: %s", resp.Status)}
        }</span>

        // Parse the graph.
        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">if err = json.Unmarshal(body, &amp;graph); err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseInvalid", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">return graph, nil</span>
}

type graph struct {
        Nodes []node
        Edges []edge
}

type node struct {
        Version  semver.Version    `json:"version"`
        Image    string            `json:"payload"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

type edge struct {
        Origin      int
        Destination int
}

// UnmarshalJSON unmarshals an edge in the update graph. The edge's JSON
// representation is a two-element array of indices, but Go's representation is
// a struct with two elements so this custom unmarshal method is required.
func (e *edge) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var fields []int
        if err := json.Unmarshal(data, &amp;fields); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(fields) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("expected 2 fields, found %d", len(fields))
        }</span>

        <span class="cov8" title="1">e.Origin = fields[0]
        e.Destination = fields[1]

        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package release

import (
        "errors"
        "sort"

        "github.com/blang/semver/v4"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
)

// ErrNoPreviousRelease is returned when no releases can be found in the
// release channels.
var ErrNoPreviousRelease = errors.New("no previous release downloads detected")

// FindRelease will find the minimum or maximum release for a set of ReleaseChannels
func FindRelease(channels []v1alpha2.ReleaseChannel, min bool) (string, semver.Version, error) <span class="cov8" title="1">{
        vers, err := findReleases(channels, min)
        if err != nil </span><span class="cov8" title="1">{
                return "", semver.Version{}, err
        }</span>

        <span class="cov8" title="1">keys := make([]string, 0, len(vers))
        for k := range vers </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].GT(vers[keys[j]])
                }</span>)
        } else<span class="cov8" title="1"> {
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].LT(vers[keys[j]])
                }</span>)
        }

        <span class="cov8" title="1">return keys[len(keys)-1], vers[keys[len(keys)-1]], nil</span>
}

func findReleases(channels []v1alpha2.ReleaseChannel, min bool) (map[string]semver.Version, error) <span class="cov8" title="1">{
        vers := make(map[string]semver.Version, len(channels))
        if len(channels) == 0 </span><span class="cov8" title="1">{
                return vers, ErrNoPreviousRelease
        }</span>

        <span class="cov8" title="1">for _, ch := range channels </span><span class="cov8" title="1">{

                ver := ch.MaxVersion
                if min </span><span class="cov8" title="1">{
                        ver = ch.MinVersion
                }</span>
                <span class="cov8" title="1">parsedVer, err := semver.Parse(ver)
                if err != nil </span><span class="cov0" title="0">{
                        return vers, err
                }</span>
                <span class="cov8" title="1">vers[ch.Name] = parsedVer</span>
        }

        <span class="cov8" title="1">return vers, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package release

import (
        "bufio"
        "context"
        "crypto/md5"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/v2/pkg/api/v1alpha3"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "github.com/openshift/oc-mirror/v2/pkg/manifest"
        "github.com/openshift/oc-mirror/v2/pkg/mirror"
)

type releasesForFilter struct {
        Filter   v1alpha2.Platform          `json:"filter"`
        Releases []v1alpha3.CopyImageSchema `json:"releases"`
}

const (
        fileProtocol string = "file://"
)

func NewWithLocalStorage(log clog.PluggableLoggerInterface,
        config v1alpha2.ImageSetConfiguration,
        opts mirror.CopyOptions,
        mirror mirror.MirrorInterface,
        manifest manifest.ManifestInterface,
        cincinnati CincinnatiInterface,
        localStorageFQDN string,
) CollectorInterface <span class="cov0" title="0">{
        return &amp;LocalStorageCollector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest, Cincinnati: cincinnati, LocalStorageFQDN: localStorageFQDN}
}</span>

type LocalStorageCollector struct {
        Log              clog.PluggableLoggerInterface
        Mirror           mirror.MirrorInterface
        Manifest         manifest.ManifestInterface
        Config           v1alpha2.ImageSetConfiguration
        Opts             mirror.CopyOptions
        Cincinnati       CincinnatiInterface
        LocalStorageFQDN string
}

func (o *LocalStorageCollector) ReleaseImageCollector(ctx context.Context) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{
        var allImages []v1alpha3.CopyImageSchema
        var imageIndexDir string
        filterCopy := o.Config.Mirror.Platform.DeepCopy()
        if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                releases := o.Cincinnati.GetReleaseReferenceImages(ctx)

                releasesForFilter := releasesForFilter{
                        Filter: filterCopy,
                        //TODO check if here I cannot directly use the releases from L56
                        Releases: []v1alpha3.CopyImageSchema{},
                }

                f, err := os.Create(logFile)
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error("[ReleaseImageCollector] %v", err)
                }</span>

                <span class="cov8" title="1">writer := bufio.NewWriter(f)
                defer f.Close()
                for _, value := range releases </span><span class="cov8" title="1">{
                        hld := strings.Split(value.Source, "/")
                        imageIndexDir = strings.Replace(hld[len(hld)-1], ":", "/", -1)
                        cacheDir := filepath.Join(o.Opts.Global.Dir, releaseImageExtractDir, imageIndexDir)
                        dir := filepath.Join(o.Opts.Global.Dir, releaseImageDir, imageIndexDir)
                        if _, err := os.Stat(dir); errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                                o.Log.Info("copying  %s ", value.Source)
                                err := os.MkdirAll(dir, 0755)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                                }</span>
                                <span class="cov8" title="1">src := dockerProtocol + value.Source
                                dest := ociProtocolTrimmed + dir
                                err = o.Mirror.Run(ctx, src, dest, "copy", &amp;o.Opts, *writer)
                                if err != nil </span><span class="cov8" title="1">{
                                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                                }</span>
                                //Save what has been copied so that we can reuse it during Disk To Mirror flow
                                <span class="cov0" title="0">r := v1alpha3.CopyImageSchema{
                                        Source:      src,
                                        Destination: dest,
                                }
                                releasesForFilter.Releases = append(releasesForFilter.Releases, r)
                                o.Log.Debug("copied release index image %s ", value.Source)

                                // TODO: create common function to show logs
                                f, _ := os.ReadFile(logFile)
                                lines := strings.Split(string(f), "\n")
                                for _, s := range lines </span><span class="cov0" title="0">{
                                        if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                                o.Log.Debug(" %s ", strings.ToLower(s))
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                o.Log.Info("cache release-index directory exists %s", cacheDir)
                        }</span>

                        <span class="cov8" title="1">oci, err := o.Manifest.GetImageIndex(dir)
                        if err != nil </span><span class="cov8" title="1">{
                                o.Log.Error("[ReleaseImageCollector] %v ", err)
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>

                        //read the link to the manifest
                        <span class="cov8" title="1">if len(oci.Manifests) == 0 </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, "image index not found ")
                        }</span>
                        <span class="cov8" title="1">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
                        o.Log.Debug("image index %v", manifest)

                        manifestDir := strings.Join([]string{dir, blobsDir, manifest}, "/")
                        mfst, err := o.Manifest.GetImageManifest(manifestDir)
                        if err != nil </span><span class="cov8" title="1">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>
                        <span class="cov8" title="1">o.Log.Debug("manifest %v ", oci.Config.Digest)

                        fromDir := strings.Join([]string{dir, blobsDir}, "/")
                        err = o.Manifest.ExtractLayersOCI(fromDir, cacheDir, releaseManifests, mfst)
                        if err != nil </span><span class="cov8" title="1">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>
                        <span class="cov8" title="1">o.Log.Debug("extracted layer %s ", cacheDir)

                        // overkill but its used for consistency
                        releaseDir := strings.Join([]string{cacheDir, releaseImageExtractFullPath}, "/")
                        allRelatedImages, err := o.Manifest.GetReleaseSchema(releaseDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>
                        //add the release image itself
                        <span class="cov8" title="1">allRelatedImages = append(allRelatedImages, v1alpha3.RelatedImage{Image: value.Source, Name: value.Source})
                        tmpAllImages, err := o.prepareM2DCopyBatch(o.Log, allRelatedImages)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>
                        <span class="cov8" title="1">allImages = append(allImages, tmpAllImages...)</span>

                }
                // save the releasesForFilter to json cache,
                // so that it can be used during diskToMirror flow
                <span class="cov8" title="1">err = o.saveReleasesForFilter(releasesForFilter, filepath.Join(o.Opts.Global.Dir, releaseFiltersDir))
                if err != nil </span><span class="cov0" title="0">{
                        return []v1alpha3.CopyImageSchema{}, fmt.Errorf("[ReleaseImageCollector] unable to save cincinatti response: %v", err)
                }</span>
        } else<span class="cov8" title="1"> if o.Opts.Mode == diskToMirror </span><span class="cov8" title="1">{

                releases, err := o.identifyReleaseFolders()
                if err != nil </span><span class="cov0" title="0">{
                        return allImages, err
                }</span>
                <span class="cov8" title="1">o.Log.Debug("found %d releases that match the filter", len(releases))
                for _, releaseDir := range releases </span><span class="cov8" title="1">{

                        // get all release images from manifest (json)
                        imageReferencesFile := filepath.Join(releaseDir, releaseManifests, imageReferences)
                        allRelatedImages, err := o.Manifest.GetReleaseSchema(imageReferencesFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, fmt.Errorf(errMsg, err)
                        }</span>
                        // TODO
                        //allRelatedImages = append(allRelatedImages, v1alpha3.RelatedImage{Image: value.Source, Name: value.Source})

                        <span class="cov8" title="1">tmpAllImages, err := o.prepareD2MCopyBatch(o.Log, allRelatedImages)
                        if err != nil </span><span class="cov0" title="0">{
                                return []v1alpha3.CopyImageSchema{}, err
                        }</span>
                        <span class="cov8" title="1">allImages = append(allImages, tmpAllImages...)</span>
                }
        }

        <span class="cov8" title="1">return allImages, nil</span>
}

func (o *LocalStorageCollector) prepareD2MCopyBatch(log clog.PluggableLoggerInterface, images []v1alpha3.RelatedImage) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{
        var result []v1alpha3.CopyImageSchema
        for _, img := range images </span><span class="cov8" title="1">{
                // TODO Make this more complete
                // This logic will be useful for operators and releases
                // strip the domain name from the img.Name
                src := ""
                dst := ""

                domainAndPathComps := img.Image
                // pathComponents := img.Name
                // temporarily strip out the transport
                transportAndRef := strings.Split(domainAndPathComps, "://")
                if len(transportAndRef) &gt; 1 </span><span class="cov0" title="0">{
                        domainAndPathComps = transportAndRef[1]
                }</span>
                <span class="cov8" title="1">src = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, img.Image}, "/")
                dst = strings.Join([]string{o.Opts.Destination, img.Image}, "/")

                // the following is for having the destination without the initial domain name =&gt; later
                // domainAndPathCompsArray := strings.Split(domainAndPathComps, "/")
                // if len(domainAndPathCompsArray) &gt; 2 {
                //         pathComponents = strings.Join(domainAndPathCompsArray[1:], "/")
                // } else {
                //         return allImages, fmt.Errorf("unable to parse image %s correctly", img.Name)
                // }
                // src = dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, pathComponents}, "/")
                // dst = strings.Join([]string{o.Opts.Destination, pathComponents}, "/") // already has a transport protocol

                if src == "" || dst == "" </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("unable to determine src %s or dst %s for %s", src, dst, img.Name)
                }</span>

                <span class="cov8" title="1">o.Log.Debug("source %s", src)
                o.Log.Debug("destination %s", dst)
                result = append(result, v1alpha3.CopyImageSchema{Source: src, Destination: dst})</span>

        }
        <span class="cov8" title="1">return result, nil</span>
}

func (o *LocalStorageCollector) prepareM2DCopyBatch(log clog.PluggableLoggerInterface, images []v1alpha3.RelatedImage) ([]v1alpha3.CopyImageSchema, error) <span class="cov8" title="1">{
        var result []v1alpha3.CopyImageSchema
        for _, img := range images </span><span class="cov8" title="1">{
                imgName := img.Image
                src := ""
                if !strings.Contains(src, "://") </span><span class="cov8" title="1">{ // no transport was provided, assume docker://
                        src = dockerProtocol + imgName
                }</span> else<span class="cov0" title="0"> {
                        transportAndRef := strings.Split(imgName, "://")
                        imgName = transportAndRef[1] // because we are reusing this to construct dest
                }</span>

                <span class="cov8" title="1">dest := dockerProtocol + strings.Join([]string{o.LocalStorageFQDN, imgName}, "/")
                o.Log.Debug("source %s", src)
                o.Log.Debug("destination %s", dest)
                result = append(result, v1alpha3.CopyImageSchema{Source: src, Destination: dest})</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (o *LocalStorageCollector) identifyReleaseFolders() ([]string, error) <span class="cov8" title="1">{
        //Find the filter file, containing all the images that correspond to the filter
        rff := releasesForFilter{
                Filter: o.Config.Mirror.Platform,
        }
        filter := fmt.Sprintf("%v", rff.Filter)
        filterFileName := fmt.Sprintf("%x", md5.Sum([]byte(filter)))[0:32]
        filterFilePath := filepath.Join(o.Opts.Global.Dir, strings.TrimPrefix(o.Opts.Global.From, fileProtocol), releaseFiltersDir, filterFileName)
        dat, err := os.ReadFile(filterFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read file %s: %v", filterFilePath, err)
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(dat, &amp;rff)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to unmarshall contents of %s: %v", filterFilePath, err)
        }</span>

        <span class="cov8" title="1">releaseImages := rff.Releases
        releaseFolders := []string{}
        for _, img := range releaseImages </span><span class="cov8" title="1">{
                releasePath := strings.TrimPrefix(img.Destination, ociProtocol)
                releasePath = strings.TrimPrefix(releasePath, ociProtocolTrimmed)
                releaseHoldPath := strings.Replace(releasePath, releaseImageDir, releaseImageExtractDir, 1)
                releaseFolders = append(releaseFolders, releaseHoldPath)
        }</span>
        <span class="cov8" title="1">return releaseFolders, nil</span>
}

func (o *LocalStorageCollector) saveReleasesForFilter(r releasesForFilter, to string) error <span class="cov8" title="1">{
        toJson, err := json.Marshal(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">filter := fmt.Sprintf("%v", r.Filter)
        filterFileName := fmt.Sprintf("%x", md5.Sum([]byte(filter)))[0:32]

        if _, err := os.Stat(to); errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                o.Log.Info("copying  cincinatti response to %s", to)
                err := os.MkdirAll(to, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">filterFile, err := os.Create(filepath.Join(to, filterFileName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer filterFile.Close()

        _, err = filterFile.Write([]byte(toJson))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
