
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/openshift/oc-mirror/pkg/api/v1alpha1/config_types.go (91.7%)</option>
				
				<option value="file1">github.com/openshift/oc-mirror/pkg/api/v1alpha1/include_config.go (0.0%)</option>
				
				<option value="file2">github.com/openshift/oc-mirror/pkg/api/v1alpha1/metadata_types.go (34.5%)</option>
				
				<option value="file3">github.com/openshift/oc-mirror/pkg/api/v1alpha1/storage_config_types.go (0.0%)</option>
				
				<option value="file4">github.com/openshift/oc-mirror/pkg/api/v1alpha2/types_config.go (78.7%)</option>
				
				<option value="file5">github.com/openshift/oc-mirror/pkg/api/v1alpha2/types_image.go (0.0%)</option>
				
				<option value="file6">github.com/openshift/oc-mirror/pkg/api/v1alpha2/types_include_config.go (63.6%)</option>
				
				<option value="file7">github.com/openshift/oc-mirror/pkg/api/v1alpha2/types_metadata.go (0.0%)</option>
				
				<option value="file8">github.com/openshift/oc-mirror/pkg/api/v1alpha2/types_platform.go (0.0%)</option>
				
				<option value="file9">github.com/openshift/oc-mirror/pkg/api/v1alpha2/types_storage_config.go (0.0%)</option>
				
				<option value="file10">github.com/openshift/oc-mirror/pkg/archive/archive.go (40.2%)</option>
				
				<option value="file11">github.com/openshift/oc-mirror/pkg/bundle/files.go (63.1%)</option>
				
				<option value="file12">github.com/openshift/oc-mirror/pkg/bundle/workspace.go (0.0%)</option>
				
				<option value="file13">github.com/openshift/oc-mirror/pkg/cincinnati/cincinnati.go (79.9%)</option>
				
				<option value="file14">github.com/openshift/oc-mirror/pkg/cincinnati/client.go (75.0%)</option>
				
				<option value="file15">github.com/openshift/oc-mirror/pkg/cincinnati/find.go (95.8%)</option>
				
				<option value="file16">github.com/openshift/oc-mirror/pkg/cli/mirror/additional.go (73.3%)</option>
				
				<option value="file17">github.com/openshift/oc-mirror/pkg/cli/mirror/blocked.go (87.5%)</option>
				
				<option value="file18">github.com/openshift/oc-mirror/pkg/cli/mirror/catalog_images.go (0.0%)</option>
				
				<option value="file19">github.com/openshift/oc-mirror/pkg/cli/mirror/cincinnati_graph_image.go (0.0%)</option>
				
				<option value="file20">github.com/openshift/oc-mirror/pkg/cli/mirror/create.go (51.6%)</option>
				
				<option value="file21">github.com/openshift/oc-mirror/pkg/cli/mirror/describe/describe.go (54.5%)</option>
				
				<option value="file22">github.com/openshift/oc-mirror/pkg/cli/mirror/fbc_operators.go (84.9%)</option>
				
				<option value="file23">github.com/openshift/oc-mirror/pkg/cli/mirror/helm.go (39.8%)</option>
				
				<option value="file24">github.com/openshift/oc-mirror/pkg/cli/mirror/initcmd/initcmd.go (75.8%)</option>
				
				<option value="file25">github.com/openshift/oc-mirror/pkg/cli/mirror/list/list.go (0.0%)</option>
				
				<option value="file26">github.com/openshift/oc-mirror/pkg/cli/mirror/list/operators.go (12.2%)</option>
				
				<option value="file27">github.com/openshift/oc-mirror/pkg/cli/mirror/list/releases.go (38.5%)</option>
				
				<option value="file28">github.com/openshift/oc-mirror/pkg/cli/mirror/list/updates.go (4.7%)</option>
				
				<option value="file29">github.com/openshift/oc-mirror/pkg/cli/mirror/manifests.go (70.2%)</option>
				
				<option value="file30">github.com/openshift/oc-mirror/pkg/cli/mirror/mirror.go (20.5%)</option>
				
				<option value="file31">github.com/openshift/oc-mirror/pkg/cli/mirror/operator.go (18.9%)</option>
				
				<option value="file32">github.com/openshift/oc-mirror/pkg/cli/mirror/options.go (0.0%)</option>
				
				<option value="file33">github.com/openshift/oc-mirror/pkg/cli/mirror/pack.go (70.6%)</option>
				
				<option value="file34">github.com/openshift/oc-mirror/pkg/cli/mirror/prune.go (69.7%)</option>
				
				<option value="file35">github.com/openshift/oc-mirror/pkg/cli/mirror/publish.go (11.1%)</option>
				
				<option value="file36">github.com/openshift/oc-mirror/pkg/cli/mirror/release.go (25.2%)</option>
				
				<option value="file37">github.com/openshift/oc-mirror/pkg/cli/mirror/sequence.go (82.4%)</option>
				
				<option value="file38">github.com/openshift/oc-mirror/pkg/cli/mirror/util.go (51.4%)</option>
				
				<option value="file39">github.com/openshift/oc-mirror/pkg/cli/mirror/version/version.go (9.1%)</option>
				
				<option value="file40">github.com/openshift/oc-mirror/pkg/config/defaults.go (100.0%)</option>
				
				<option value="file41">github.com/openshift/oc-mirror/pkg/config/load.go (46.9%)</option>
				
				<option value="file42">github.com/openshift/oc-mirror/pkg/config/validate.go (95.0%)</option>
				
				<option value="file43">github.com/openshift/oc-mirror/pkg/image/association_builder.go (74.1%)</option>
				
				<option value="file44">github.com/openshift/oc-mirror/pkg/image/association_set.go (54.6%)</option>
				
				<option value="file45">github.com/openshift/oc-mirror/pkg/image/builder/image_builder.go (75.1%)</option>
				
				<option value="file46">github.com/openshift/oc-mirror/pkg/image/convert.go (74.5%)</option>
				
				<option value="file47">github.com/openshift/oc-mirror/pkg/image/credentials.go (68.0%)</option>
				
				<option value="file48">github.com/openshift/oc-mirror/pkg/image/digest.go (87.5%)</option>
				
				<option value="file49">github.com/openshift/oc-mirror/pkg/image/image.go (68.6%)</option>
				
				<option value="file50">github.com/openshift/oc-mirror/pkg/image/mapping.go (75.0%)</option>
				
				<option value="file51">github.com/openshift/oc-mirror/pkg/image/resolve.go (72.7%)</option>
				
				<option value="file52">github.com/openshift/oc-mirror/pkg/metadata/storage/local.go (70.1%)</option>
				
				<option value="file53">github.com/openshift/oc-mirror/pkg/metadata/storage/registry.go (75.2%)</option>
				
				<option value="file54">github.com/openshift/oc-mirror/pkg/metadata/storage/storage.go (85.7%)</option>
				
				<option value="file55">github.com/openshift/oc-mirror/pkg/metadata/store.go (63.6%)</option>
				
				<option value="file56">github.com/openshift/oc-mirror/pkg/operator/catalog_dir.go (66.7%)</option>
				
				<option value="file57">github.com/openshift/oc-mirror/pkg/operator/declcfg_to_includecfg.go (89.3%)</option>
				
				<option value="file58">github.com/openshift/oc-mirror/pkg/operator/diff/diff.go (86.2%)</option>
				
				<option value="file59">github.com/openshift/oc-mirror/pkg/operator/diff/internal/diff.go (89.4%)</option>
				
				<option value="file60">github.com/openshift/oc-mirror/pkg/operator/diff/internal/diff_include.go (76.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package v1alpha1

import (
        "bytes"
        "encoding/json"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/yaml"
)

// ImageSetConfiguration object kind.
const ImageSetConfigurationKind = "ImageSetConfiguration"

// ImageSetConfiguration configures image set creation.
type ImageSetConfiguration struct {
        metav1.TypeMeta `json:",inline"`

        ImageSetConfigurationSpec `json:",inline"`
}

type ImageSetConfigurationSpec struct {
        Mirror Mirror `json:"mirror"`
        // ArchiveSize is the size of the segmented archive in GB
        ArchiveSize int64 `json:"archiveSize,omitempty"`
        // StorageConfig for reading/writing metadata and files.
        StorageConfig StorageConfig `json:"storageConfig"`
}

type Mirror struct {
        OCP              OCP                `json:"ocp,omitempty"`
        Operators        []Operator         `json:"operators,omitempty"`
        AdditionalImages []AdditionalImages `json:"additionalImages,omitempty"`
        Helm             Helm               `json:"helm,omitempty"`
        BlockedImages    []BlockedImages    `json:"blockedImages,omitempty"`
        Samples          []SampleImages     `json:"samples,omitempty"`
}

type OCP struct {
        Graph    bool             `json:"graph,omitempty"`
        Channels []ReleaseChannel `json:"channels,omitempty"`
}

type ReleaseChannel struct {
        Name string `json:"name"`
        // Deprecated: ReleaseChannel should implement MinVersion and MaxVersion.
        Versions []string `json:"versions"`
}

// Operator configures operator catalog mirroring.
type Operator struct {
        // Mirror specific operator packages, channels, and versions, and their dependencies.
        // If HeadsOnly is true, these objects are mirrored on top of heads of all channels.
        // Otherwise, only these specific objects are mirrored.
        IncludeConfig `json:",inline"`

        // Catalog image to mirror. This image must be pullable and available for subsequent
        // pulls on later mirrors.
        // This image should be an exact image pin (registry/namespace/name@sha256:&lt;hash&gt;)
        // but is not required to be.
        Catalog string `json:"catalog"`
        // HeadsOnly mode mirrors only channel heads of all packages in the catalog.
        // Channels specified in DiffIncludeConfig will override this setting;
        // heads will still be included, but prior versions may also be included.
        // The default is true.
        HeadsOnly *bool `json:"headsOnly,omitempty"`
        // SkipDependencies will not include dependencies
        // of bundles included in the diff if true.
        SkipDependencies bool `json:"skipDeps,omitempty"`
}

func (o Operator) IsHeadsOnly() bool <span class="cov8" title="1">{
        if o.HeadsOnly == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return *o.HeadsOnly</span>
}

type Helm struct {
        // Repo is the helm repository containing the charts
        Repos []Repo `json:"repos,omitempty"`
        // Local is the configuration for locally stored helm charts
        Local []Chart `json:"local,omitempty"`
}

// Repo is the configuration for a Helm Repo
type Repo struct {
        // URL is the url of the helm repository
        URL string `json:"url"`
        // Name is the name of the helm repository
        Name string `json:"name"`
        // Charts is a list of charts to pull from the repo
        Charts []Chart `json:"charts"`
}

// Chart is the information an individual Helm chart
type Chart struct {
        Name    string `json:"name"`
        Version string `json:"version,omitempty"`
        Path    string `json:"path,omitempty"`
        // ImagePaths are custom JSON paths for images location
        // in the helm manifest or templates
        ImagePaths []string `json:"imagepaths,omitempty"`
}

// Image contains image pull information.
type Image struct {
        // Name of the image. This should be an exact image pin (registry/namespace/name@sha256:&lt;hash&gt;)
        // but is not required to be.
        Name string `json:"name"`
}

type AdditionalImages struct {
        Image `json:",inline"`
}

type BlockedImages struct {
        Image `json:",inline"`
}

type SampleImages struct {
        Image `json:",inline"`
}

func LoadConfig(data []byte) (c ImageSetConfiguration, err error) <span class="cov8" title="1">{

        gvk := GroupVersion.WithKind(ImageSetConfigurationKind)

        if data, err = yaml.YAMLToJSON(data); err != nil </span><span class="cov0" title="0">{
                return c, fmt.Errorf("yaml to json %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;c); err != nil </span><span class="cov8" title="1">{
                return c, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">c.SetGroupVersionKind(gvk)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package v1alpha1

import (
        "fmt"

        "github.com/blang/semver/v4"
        "github.com/openshift/oc-mirror/pkg/operator/diff"
)

type IncludeConfig struct {
        // Packages to include.
        Packages []IncludePackage `json:"packages" yaml:"packages"`
}

// IncludePackage contains a name (required) and channels and/or versions
// (optional) to include in the diff. The full package is only included if no channels
// or versions are specified.
type IncludePackage struct {
        // Name of package.
        Name string `json:"name" yaml:"name"`
        // Channels to include.
        Channels []IncludeChannel `json:"channels,omitempty" yaml:"channels,omitempty"`

        // All channels containing these bundles are parsed for an upgrade graph.
        IncludeBundle `json:",inline"`
}

// IncludeChannel contains a name (required) and versions (optional)
// to include in the diff. The full channel is only included if no versions are specified.
type IncludeChannel struct {
        // Name of channel.
        Name string `json:"name" yaml:"name"`

        IncludeBundle `json:",inline"`
}

type IncludeBundle struct {
        // StartingVersion to include, plus all versions in the upgrade graph to the channel head.
        StartingVersion semver.Version `json:"startingVersion,omitempty" yaml:"startingVersion,omitempty"`
        // StartingBundle to include, plus all bundles in the upgrade graph to the channel head.
        // Set this field only if the named bundle has no semantic version metadata.
        StartingBundle string `json:"startingBundle,omitempty" yaml:"startingBundle,omitempty"`
}

func (ic *IncludeConfig) ConvertToDiffIncludeConfig() (dic diff.DiffIncludeConfig, err error) <span class="cov0" title="0">{
        if ic == nil </span><span class="cov0" title="0">{
                return dic, nil
        }</span>

        <span class="cov0" title="0">for pkgIdx, pkg := range ic.Packages </span><span class="cov0" title="0">{
                if pkg.Name == "" </span><span class="cov0" title="0">{
                        return dic, fmt.Errorf("package %d requires a name", pkgIdx)
                }</span>
                <span class="cov0" title="0">if err := pkg.IncludeBundle.validate(); err != nil </span><span class="cov0" title="0">{
                        return dic, fmt.Errorf("package %s: %v", pkg.Name, err)
                }</span>

                <span class="cov0" title="0">dpkg := diff.DiffIncludePackage{Name: pkg.Name}
                switch </span>{
                case !pkg.StartingVersion.EQ(semver.Version{}):<span class="cov0" title="0">
                        dpkg.Versions = []semver.Version{pkg.StartingVersion}</span>
                case pkg.StartingBundle != "":<span class="cov0" title="0">
                        dpkg.Bundles = []string{pkg.StartingBundle}</span>
                }
                <span class="cov0" title="0">dic.Packages = append(dic.Packages, dpkg)

                for chIdx, ch := range pkg.Channels </span><span class="cov0" title="0">{
                        if ch.Name == "" </span><span class="cov0" title="0">{
                                return dic, fmt.Errorf("package %s: channel %d requires a name", pkg.Name, chIdx)
                        }</span>
                        <span class="cov0" title="0">if err := ch.IncludeBundle.validate(); err != nil </span><span class="cov0" title="0">{
                                return dic, fmt.Errorf("channel %s: %v", ch.Name, err)
                        }</span>

                        <span class="cov0" title="0">dch := diff.DiffIncludeChannel{Name: ch.Name}
                        switch </span>{
                        case !ch.StartingVersion.EQ(semver.Version{}):<span class="cov0" title="0">
                                dch.Versions = []semver.Version{ch.StartingVersion}</span>
                        case ch.StartingBundle != "":<span class="cov0" title="0">
                                dch.Bundles = []string{ch.StartingBundle}</span>
                        }
                        <span class="cov0" title="0">dpkg.Channels = append(dpkg.Channels, dch)</span>
                }
        }

        <span class="cov0" title="0">return dic, nil</span>
}

func (b IncludeBundle) validate() error <span class="cov0" title="0">{
        if !b.StartingVersion.EQ(semver.Version{}) &amp;&amp; b.StartingBundle != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("starting version and bundle are mutually exclusive")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package v1alpha1

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "sort"

        "github.com/google/uuid"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Metadata object kind.
const MetadataKind = "Metadata"

// Metadata configures image set creation.
type Metadata struct {
        metav1.TypeMeta `json:",inline"`

        MetadataSpec `json:",inline"`
}

type MetadataSpec struct {
        // Uid uniquely identifies this metadata object.
        Uid uuid.UUID `json:"uid"`
        // SingleUse will ignore the past runs if set to true
        SingleUse bool `json:"singleUse"`
        // Past is a slice containing information for
        // all mirrors created for an imageset
        PastMirrors PastMirrors `json:"pastMirrors"`
        // PastFiles is a slice containing information for
        // all files created for an imageset
        PastBlobs []Blob `json:"pastBlobs"`
}

type PastMirror struct {
        Timestamp int        `json:"timestamp"`
        Sequence  int        `json:"sequence"`
        Manifests []Manifest `json:"manifests"`
        Blobs     []Blob     `json:"blobs"`
        Mirror    Mirror     `json:"mirror"`
        // Operators are metadata about the set of mirrored operators in a mirror operation.
        Operators []OperatorMetadata `json:"operators,omitempty"`
}

var _ sort.Interface = PastMirrors{}

// PastMirrors is a sortable slice of PastMirrors.
// Deprecated: PastMirrors is deprecated in favor of tracking one Past Mirror
type PastMirrors []PastMirror

func (pms PastMirrors) Len() int           <span class="cov8" title="1">{ return len(pms) }</span>
func (pms PastMirrors) Swap(i, j int)      <span class="cov0" title="0">{ pms[i], pms[j] = pms[j], pms[i] }</span>
func (pms PastMirrors) Less(i, j int) bool <span class="cov8" title="1">{ return pms[i].Sequence &lt; pms[j].Sequence }</span>

type Blob struct {
        ID string `json:"id"`
        // NamespaceName of image that owns this blob.
        // Required for blob lookups during the publish step.
        NamespaceName string `json:"namespaceName"`
}

type Manifest struct {
        Name  string `json:"name"`
        Image string `json:"image"`
        // NamespaceName of image that owns this manifest.
        NamespaceName string `json:"namespaceName"`
}

// OperatorMetadata holds an Operator's post-mirror metadata.
type OperatorMetadata struct {
        // Catalog references a catalog name from the mirror spec.
        Catalog string `json:"catalog"`
        // ImagePin is the resolved sha256 image name of Catalog.
        // This image will be pulled using the pull secret
        // in the metadata's Mirror config for this catalog.
        ImagePin string `json:"imagePin"`
}

var _ io.Writer = &amp;InlinedIndex{}

type InlinedIndex json.RawMessage

func (index *InlinedIndex) Write(data []byte) (int, error) <span class="cov0" title="0">{
        msg := json.RawMessage{}
        if err := msg.UnmarshalJSON(data); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">*index = InlinedIndex(msg)
        return len(data), nil</span>
}

func (index InlinedIndex) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(index)
}</span>

func NewMetadata() Metadata <span class="cov0" title="0">{
        return Metadata{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: GroupVersion.String(),
                        Kind:       MetadataKind,
                },
        }
}</span>

func LoadMetadata(data []byte) (m Metadata, err error) <span class="cov8" title="1">{

        gvk := GroupVersion.WithKind(MetadataKind)

        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;m); err != nil </span><span class="cov8" title="1">{
                return m, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">m.SetGroupVersionKind(gvk)

        // Make sure sequences are sorted in ascending order before returning m.
        sort.Sort(m.PastMirrors)

        return m, nil</span>
}

func (m *Metadata) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{

        gvk := GroupVersion.WithKind(MetadataKind)
        m.SetGroupVersionKind(gvk)

        // Make sure sequences are sorted in ascending order before writing m.
        sort.Sort(m.PastMirrors)

        buf := &amp;bytes.Buffer{}
        enc := json.NewEncoder(buf)
        // Use anonymous struct to avoid recursive marshal calls.
        var tmp struct {
                metav1.TypeMeta `json:",inline"`
                MetadataSpec    `json:",inline"`
        }
        tmp.TypeMeta = m.TypeMeta
        tmp.MetadataSpec = m.MetadataSpec
        if err := enc.Encode(tmp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encode %s: %v", gvk, err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package v1alpha1

// StorageConfig configures how metadata is stored.
type StorageConfig struct {
        Registry *RegistryConfig `json:"registry,omitempty"`
        Local    *LocalConfig    `json:"local,omitempty"`
}

// RegistryConfig configures a registry-based storage.
type RegistryConfig struct {
        // ImageURL at which the image can be pulled.
        ImageURL string `json:"imageURL"`
        SkipTLS  bool   `json:"skipTLS"`
}

// LocalConfig configure a local directory storage
type LocalConfig struct {
        Path string `json:"path"`
}

// IsSet will determine whether StorageConfig
// is empty or has backends set
func (s StorageConfig) IsSet() bool <span class="cov0" title="0">{
        if s.Registry != nil || s.Local != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package v1alpha2

import (
        "path"
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        // ImageSetConfiguration object kind.
        ImageSetConfigurationKind = "ImageSetConfiguration"
        OCITransportPrefix        = "oci:"
)

// ImageSetConfiguration configures image set creation.
type ImageSetConfiguration struct {
        metav1.TypeMeta `json:",inline"`
        // ImageSetConfigurationSpec defines the global configuration for an imageset.
        ImageSetConfigurationSpec `json:",inline"`
}

// ImageSetConfigurationSpec defines the global configuration for an imageset.
type ImageSetConfigurationSpec struct {
        // Mirror defines the configuration for content types within the imageset.
        Mirror Mirror `json:"mirror"`
        // ArchiveSize is the size of the segmented archive in GB
        ArchiveSize int64 `json:"archiveSize,omitempty"`
        // StorageConfig for reading/writing metadata and files.
        StorageConfig StorageConfig `json:"storageConfig"`
}

// Mirror defines the configuration for content types within the imageset.
type Mirror struct {
        // Platform defines the configuration for OpenShift and OKD platform types.
        Platform Platform `json:"platform,omitempty"`
        // Operators defines the configuration for Operator content types.
        Operators []Operator `json:"operators,omitempty"`
        // AdditionalImages defines the configuration for a list
        // of individual image content types.
        AdditionalImages []Image `json:"additionalImages,omitempty"`
        // Helm define the configuration for Helm content types.
        Helm Helm `json:"helm,omitempty"`
        // BlockedImages define a list of images that will be blocked
        // from the mirroring process if they exist in other content
        // types in the configuration.
        BlockedImages []Image `json:"blockedImages,omitempty"`
        // Samples defines the configuration for Sample content types.
        // This is currently not implemented.
        Samples []SampleImages `json:"samples,omitempty"`
}

// Platform defines the configuration for OpenShift and OKD platform types.
type Platform struct {
        // Graph defines whether Cincinnati graph data will
        // downloaded and publish
        Graph bool `json:"graph,omitempty"`
        // Channels defines the configuration for individual
        // OCP and OKD channels
        Channels []ReleaseChannel `json:"channels,omitempty"`
        // Architectures defines one or more architectures
        // to mirror for the release image. This is defined at the
        // platform level to enable cross-channel upgrades.
        Architectures []string `json:"architectures,omitempty"`
}

// ReleaseChannel defines the configuration for individual
// OCP and OKD channels
type ReleaseChannel struct {
        Name string `json:"name"`
        // Type of the platform in the context of this tool.
        // See the PlatformType enum for options. OCP is the default.
        Type PlatformType `json:"type"`
        // MinVersion is minimum version in the
        // release channel to mirror
        MinVersion string `json:"minVersion,omitempty"`
        // MaxVersion is maximum version in the
        // release channel to mirror
        MaxVersion string `json:"maxVersion,omitempty"`
        // ShortestPath mode calculates the shortest path
        // between the min and mav version
        ShortestPath bool `json:"shortestPath,omitempty"`
        // Full mode set the MinVersion to the
        // first release in the channel and the MaxVersion
        // to the last release in the channel.
        Full bool `json:"full,omitempty"`
}

// IsHeadsOnly determine if the mode set mirrors only channel head.
// Setting MaxVersion will override this setting.
func (r ReleaseChannel) IsHeadsOnly() bool <span class="cov0" title="0">{
        return !r.Full
}</span>

// Operator defines the configuration for operator catalog mirroring.
type Operator struct {
        // Mirror specific operator packages, channels, and versions, and their dependencies.
        // If HeadsOnly is true, these objects are mirrored on top of heads of all channels.
        // Otherwise, only these specific objects are mirrored.
        IncludeConfig `json:",inline"`
        // Catalog image to mirror. This image must be pullable and available for subsequent
        // pulls on later mirrors.
        // This image should be an exact image pin (registry/namespace/name@sha256:&lt;hash&gt;)
        // but is not required to be.
        Catalog string `json:"catalog"`
        // TargetName is the target image name the catalog will be built with. If unset,
        // the catalog will be published with the provided name in the Catalog
        // field.
        // Deprecated in oc-mirror 4.13, to be replaced with TargetCatalog.
        TargetName string `json:"targetName,omitempty"`
        // TargetCatalog replaces TargetName and allows for specifying the exact URL of the target
        // catalog, including any path-components (organization, namespace) of the target catalog's location
        // on the disconnected registry.
        // This answer some customers requests regarding restrictions on where images can be placed.
        // The targetCatalog field consists of an optional namespace followed by the target image name,
        // described in extended Backus–Naur form below:
        //     target-catalog = [namespace '/'] target-name
        //     target-name    = path-component
        //     namespace      = path-component ['/' path-component]*
        //     path-component = alpha-numeric [separator alpha-numeric]*
        //     alpha-numeric  = /[a-z0-9]+/
        //     separator      = /[_.]|__|[-]*/
        // TargetCatalog will be preferred over TargetName if both are specified in te ImageSetConfig.
        TargetCatalog string `json:"targetCatalog,omitempty"`
        // TargetTag is the tag the catalog image will be built with. If unset,
        // the catalog will be publish with the provided tag in the Catalog
        // field or a tag calculated from the partial digest.
        TargetTag string `json:"targetTag,omitempty"`
        // Full defines whether all packages within the catalog
        // or specified IncludeConfig will be mirrored or just channel heads.
        Full bool `json:"full,omitempty"`
        // SkipDependencies will not include dependencies
        // of bundles included in the diff if true.
        SkipDependencies bool `json:"skipDependencies,omitempty"`
        // OriginalRef is used when the Catalog is an OCI FBC (File Based Catalog) location.
        // It contains the reference to the original repo on a remote registry
        // Deprecated in oc-mirror 4.13, and will no longer be used.
        OriginalRef string `json:"originalRef,omitempty"`
}

// GetUniqueName determines the catalog name that will
// be tracked in the metadata and built. This depends on what fields
// are set between Catalog, TargetCatalog (and soon deprecated
// TargetName), and TargetTag.
func (o Operator) GetUniqueName() (string, error) <span class="cov8" title="1">{
        ctlgRef := o.Catalog
        if o.TargetCatalog == "" &amp;&amp; o.TargetName == "" &amp;&amp; o.TargetTag == "" </span><span class="cov8" title="1">{
                return TrimProtocol(ctlgRef), nil
        }</span>

        <span class="cov8" title="1">reg, ns, name, tag, id := ParseImageReference(ctlgRef)

        if o.TargetTag != "" </span><span class="cov0" title="0">{
                tag = o.TargetTag
                id = ""
        }</span>
        <span class="cov8" title="1">uniqueName := ""

        if o.TargetCatalog != "" </span><span class="cov8" title="1">{
                // TargetCatalog takes precedence over TargetName, and replaces the catalog component-paths (URL)
                if !o.IsFBCOCI() &amp;&amp; reg != "" </span><span class="cov8" title="1">{
                        // reg is included in the name only in case of registry based catalogs.
                        // the parsed reg is not relevant in case of OCI, because the parsed ref is simply a filesystem path here
                        uniqueName += reg
                }</span>
                <span class="cov8" title="1">uniqueName = path.Join(uniqueName, o.TargetCatalog)</span>
        } else<span class="cov0" title="0"> {
                uniqueName = path.Join(uniqueName, reg, ns)

                if o.TargetName != "" </span><span class="cov0" title="0">{
                        name = o.TargetName
                }</span>
                <span class="cov0" title="0">uniqueName = path.Join(uniqueName, name)</span>
        }
        <span class="cov8" title="1">if tag != "" </span><span class="cov8" title="1">{
                uniqueName = uniqueName + ":" + tag
        }</span> else<span class="cov0" title="0"> {
                if id != "" </span><span class="cov0" title="0">{
                        uniqueName = uniqueName + "@sha256:" + id
                }</span>
        }
        <span class="cov8" title="1">return uniqueName, nil</span>
}

// parseImageName returns the registry, organisation, repository, tag and digest
// from the imageName.
// It can handle both remote and local images.
func ParseImageReference(imageName string) (string, string, string, string, string) <span class="cov8" title="1">{
        registry, namespace, repo, tag, sha := "", "", "", "", ""
        imageName = TrimProtocol(imageName)
        imageName = strings.TrimPrefix(imageName, "/")
        imageName = strings.TrimSuffix(imageName, "/")
        pathComponents := strings.Split(imageName, "/")

        // For more than 2 pathComponents, the first must be the registry
        if len(pathComponents) &gt; 1 </span><span class="cov8" title="1">{
                registry = pathComponents[0]
        }</span>
        // For more than 3 pathComponents, everything in between registry (first) and
        // repository (last) is considered to be namespace or organisation
        <span class="cov8" title="1">if len(pathComponents) &gt; 2 </span><span class="cov8" title="1">{
                namespace = strings.Join(pathComponents[1:len(pathComponents)-1], "/")
        }</span>

        // It is best to split first on digest, as the `:` might
        // exist for the tag or for the digest
        <span class="cov8" title="1">img := strings.Split(pathComponents[len(pathComponents)-1], "@sha256:")
        // The first element in the slice will always exist (repository)
        repo = img[0]
        if len(img) &gt; 1 </span><span class="cov8" title="1">{
                sha = img[1]
        }</span>

        // We check now for the existance of a tag
        <span class="cov8" title="1">if strings.Contains(repo, ":") </span><span class="cov8" title="1">{
                nm := strings.Split(repo, ":")
                repo = nm[0]
                tag = nm[1]
        }</span>

        <span class="cov8" title="1">return registry, namespace, repo, tag, sha</span>
}

// trimProtocol removes oci://, file:// or docker:// from
// the parameter imageName
func TrimProtocol(imageName string) string <span class="cov8" title="1">{
        imageName = strings.TrimPrefix(imageName, OCITransportPrefix)
        imageName = strings.TrimPrefix(imageName, "file:")
        imageName = strings.TrimPrefix(imageName, "docker:")
        imageName = strings.TrimPrefix(imageName, "//")

        return imageName
}</span>

// IsHeadsOnly determine if the mode set mirrors only channel heads of all packages in the catalog.
// Channels specified in DiffIncludeConfig will override this setting;
// heads will still be included, but prior versions may also be included.
func (o Operator) IsHeadsOnly() bool <span class="cov0" title="0">{
        return !o.Full
}</span>

func (o Operator) IsFBCOCI() bool <span class="cov8" title="1">{
        return strings.HasPrefix(o.Catalog, OCITransportPrefix)
}</span>

// Helm defines the configuration for Helm chart download
// and image mirroring
type Helm struct {
        // Repositories are the Helm repositories containing the charts
        Repositories []Repository `json:"repositories,omitempty"`
        // Local is the configuration for locally stored helm charts
        Local []Chart `json:"local,omitempty"`
}

// Repository defines the configuration for a Helm repository.
type Repository struct {
        // URL is the url of the Helm repository
        URL string `json:"url"`
        // Name is the name of the Helm repository
        Name string `json:"name"`
        // Charts is a list of charts to pull from the repo
        Charts []Chart `json:"charts"`
}

// Chart is the information an individual Helm chart
type Chart struct {
        // Chart is the chart name as define
        // in the Chart.yaml or in the Helm repo.
        Name string `json:"name"`
        // Version is the chart version as define in the
        // Chart.yaml or in the Helm repo.
        Version string `json:"version,omitempty"`
        // Path defines the path on disk where the
        // chart is stored.
        // This is applicable for a local chart.
        Path string `json:"path,omitempty"`
        // ImagePaths are custom JSON paths for images location
        // in the helm manifest or templates
        ImagePaths []string `json:"imagePaths,omitempty"`
}

// Image contains image pull information.
type Image struct {
        // Name of the image. This should be an exact image pin (registry/namespace/name@sha256:&lt;hash&gt;)
        // but is not required to be.
        Name string `json:"name"`
}

// SampleImages define the configuration
// for Sameple content types.
// Not implemented.
type SampleImages struct {
        Image `json:",inline"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package v1alpha2

import (
        "encoding/json"
        "errors"
        "fmt"
)

// ImageType defines the content type for mirrored images
type ImageType int

const (
        TypeInvalid ImageType = iota
        TypeOCPRelease
        TypeOCPReleaseContent
        TypeCincinnatiGraph
        TypeOperatorCatalog
        TypeOperatorBundle
        TypeOperatorRelatedImage
        TypeGeneric
)

// ImageTypeString defines the string
// respresentation of every ImageType.
var imageTypeStrings = map[ImageType]string{
        TypeOCPReleaseContent:    "ocpReleaseContent",
        TypeCincinnatiGraph:      "cincinnatiGraph",
        TypeOCPRelease:           "ocpRelease",
        TypeOperatorCatalog:      "operatorCatalog",
        TypeOperatorBundle:       "operatorBundle",
        TypeOperatorRelatedImage: "operatorRelatedImage",
        TypeGeneric:              "generic",
}

var imageStringsType = map[string]ImageType{
        "ocpReleaseContent":    TypeOCPReleaseContent,
        "cincinnatiGraph":      TypeCincinnatiGraph,
        "ocpRelease":           TypeOCPRelease,
        "operatorCatalog":      TypeOperatorCatalog,
        "operatorBundle":       TypeOperatorBundle,
        "operatorRelatedImage": TypeOperatorRelatedImage,
        "generic":              TypeGeneric,
}

// String returns the string representation
// of an Image Type
func (it ImageType) String() string <span class="cov0" title="0">{
        return imageTypeStrings[it]
}</span>

// MarshalJSON marshals the ImageType as a quoted json string
func (it ImageType) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if err := it.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return json.Marshal(it.String())</span>
}

// UnmarshalJSON unmarshals a quoted json string to the ImageType
func (it *ImageType) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        var j string
        if err := json.Unmarshal(b, &amp;j); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*it = imageStringsType[j]
        return nil</span>
}

func (it ImageType) validate() error <span class="cov0" title="0">{
        if _, found := imageTypeStrings[it]; found </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">switch it </span>{
        case TypeInvalid:<span class="cov0" title="0">
                // TypeInvalid is the default value for the concrete type, which means the field was not set.
                return errors.New("must set image type")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown image type %v", it)</span>
        }
}

// Association between an image and its children, either image layers or child manifests.
type Association struct {
        // Name of the image.
        Name string `json:"name"`
        // Path to image in new location (archive or registry)
        Path string `json:"path"`
        // ID of the image. Joining this value with "manifests" and Path
        // will produce a path to the image's manifest.
        ID string `json:"id"`
        // TagSymlink of the blob specified by ID.
        // This value must be a filename on disk in the "blobs" dir
        TagSymlink string `json:"tagSymlink"`
        // Type of the image in the context of this tool.
        // See the ImageType enum for options.
        Type ImageType `json:"type"`
        // ManifestDigests of images if the image is a docker manifest list or OCI index.
        // These manifests refer to image manifests by content SHA256 digest.
        // LayerDigests and Manifests are mutually exclusive.
        ManifestDigests []string `json:"manifestDigests,omitempty"`
        // LayerDigests of a single manifest if the image is not a docker manifest list
        // or OCI index. These digests refer to image layer blobs by content SHA256 digest.
        // LayerDigests and Manifests are mutually exclusive.
        LayerDigests []string `json:"layerDigests,omitempty"`
}

// Validate checks that the Association fields are set as expected
func (a Association) Validate() error <span class="cov0" title="0">{

        if len(a.ManifestDigests) != 0 &amp;&amp; len(a.LayerDigests) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("image %q: child descriptors cannot contain both manifests and image layers", a.Name)
        }</span>
        <span class="cov0" title="0">if len(a.ManifestDigests) == 0 &amp;&amp; len(a.LayerDigests) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("image %q: child descriptors must contain at least one manifest or image layer", a.Name)
        }</span>

        <span class="cov0" title="0">if a.ID == "" &amp;&amp; a.TagSymlink == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("image %q: tag or ID must be set", a.Name)
        }</span>

        <span class="cov0" title="0">return a.Type.validate()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package v1alpha2

import (
        "encoding/gob"
        "fmt"
        "io"

        "github.com/blang/semver/v4"
        "github.com/openshift/oc-mirror/pkg/operator/diff"
)

// IncludeConfig defines a list of packages for
// operator version selection.
type IncludeConfig struct {
        // Packages to include.
        Packages []IncludePackage `json:"packages" yaml:"packages"`
}

// IncludePackage contains a name (required) and channels and/or versions
// (optional) to include in the diff. The full package is only included if no channels
// or versions are specified.
type IncludePackage struct {
        // Name of package.
        Name string `json:"name" yaml:"name"`
        // Channels to include.
        Channels []IncludeChannel `json:"channels,omitempty" yaml:"channels,omitempty"`

        // All channels containing these bundles are parsed for an upgrade graph.
        IncludeBundle `json:",inline"`
}

// IncludeChannel contains a name (required) and versions (optional)
// to include in the diff. The full channel is only included if no versions are specified.
type IncludeChannel struct {
        // Name of channel.
        Name string `json:"name" yaml:"name"`

        IncludeBundle `json:",inline"`
}

// IncludeBundle contains a name (required) and versions (optional) to
// include in the diff. The full package or channel is only included if no
// versions are specified.
type IncludeBundle struct {
        // MinVersion to include, plus all versions in the upgrade graph to the MaxVersion.
        MinVersion string `json:"minVersion,omitempty" yaml:"minVersion,omitempty"`
        // MaxVersion to include as the channel head version.
        MaxVersion string `json:"maxVersion,omitempty" yaml:"maxVersion,omitempty"`
        // MinBundle to include, plus all bundles in the upgrade graph to the channel head.
        // Set this field only if the named bundle has no semantic version metadata.
        MinBundle string `json:"minBundle,omitempty" yaml:"minBundle,omitempty"`
}

// ConvertToDiffIncludeConfig converts an IncludeConfig to a DiffIncludeConfig type to
// interact with `operator-registry` libraries.
func (ic *IncludeConfig) ConvertToDiffIncludeConfig() (dic diff.DiffIncludeConfig, err error) <span class="cov8" title="1">{
        if ic == nil || len(ic.Packages) == 0 </span><span class="cov0" title="0">{
                return dic, nil
        }</span>

        <span class="cov8" title="1">for pkgIdx, pkg := range ic.Packages </span><span class="cov8" title="1">{
                if pkg.Name == "" </span><span class="cov8" title="1">{
                        return dic, fmt.Errorf("package %d requires a name", pkgIdx)
                }</span>
                <span class="cov8" title="1">if err := pkg.IncludeBundle.validate(); err != nil </span><span class="cov0" title="0">{
                        return dic, fmt.Errorf("package %s: %v", pkg.Name, err)
                }</span>

                <span class="cov8" title="1">dpkg := diff.DiffIncludePackage{Name: pkg.Name}
                switch </span>{
                case pkg.MinVersion != "" &amp;&amp; pkg.MaxVersion != "":<span class="cov8" title="1">
                        dpkg.Range = fmt.Sprintf("&gt;=%s &lt;=%s", pkg.MinVersion, pkg.MaxVersion)</span>
                case pkg.MinVersion != "":<span class="cov8" title="1">
                        minVer, err := semver.Parse(pkg.MinVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return dic, fmt.Errorf("package %s: %v", pkg.Name, err)
                        }</span>
                        <span class="cov8" title="1">dpkg.Versions = []semver.Version{minVer}</span>
                case pkg.MaxVersion != "":<span class="cov8" title="1">
                        dpkg.Range = fmt.Sprintf("&lt;=%s", pkg.MaxVersion)</span>
                case pkg.MinBundle != "":<span class="cov8" title="1">
                        dpkg.Bundles = []string{pkg.MinBundle}</span>
                }

                <span class="cov8" title="1">for chIdx, ch := range pkg.Channels </span><span class="cov8" title="1">{
                        if ch.Name == "" </span><span class="cov0" title="0">{
                                return dic, fmt.Errorf("package %s: channel %d requires a name", pkg.Name, chIdx)
                        }</span>
                        <span class="cov8" title="1">if err := ch.IncludeBundle.validate(); err != nil </span><span class="cov0" title="0">{
                                return dic, fmt.Errorf("channel %s: %v", ch.Name, err)
                        }</span>

                        <span class="cov8" title="1">dch := diff.DiffIncludeChannel{Name: ch.Name}
                        switch </span>{
                        case ch.MinVersion != "" &amp;&amp; ch.MaxVersion != "":<span class="cov8" title="1">
                                dch.Range = fmt.Sprintf("&gt;=%s &lt;=%s", ch.MinVersion, ch.MaxVersion)</span>
                        case ch.MinVersion != "":<span class="cov8" title="1">
                                ver, err := semver.Parse(ch.MinVersion)
                                if err != nil </span><span class="cov0" title="0">{
                                        return dic, fmt.Errorf("channel %s: %v", ch.Name, err)
                                }</span>
                                <span class="cov8" title="1">dch.Versions = []semver.Version{ver}</span>
                        case ch.MaxVersion != "":<span class="cov8" title="1">
                                dch.Range = fmt.Sprintf("&lt;=%s", ch.MaxVersion)</span>
                        case ch.MinBundle != "":<span class="cov0" title="0">
                                dch.Bundles = []string{ch.MinBundle}</span>
                        }
                        <span class="cov8" title="1">dpkg.Channels = append(dpkg.Channels, dch)</span>
                }
                <span class="cov8" title="1">dic.Packages = append(dic.Packages, dpkg)</span>
        }

        <span class="cov8" title="1">return dic, nil</span>
}

// Encode IncludeConfig in an efficient, opaque format.
func (ic *IncludeConfig) Encode(w io.Writer) error <span class="cov0" title="0">{
        enc := gob.NewEncoder(w)
        if err := enc.Encode(ic); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error encoding include config: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Decode IncludeConfig from an opaque format. Only usable if Include Config
// was encoded with Encode().
func (ic *IncludeConfig) Decode(r io.Reader) error <span class="cov0" title="0">{
        dec := gob.NewDecoder(r)
        if err := dec.Decode(ic); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error decoding include config: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b IncludeBundle) validate() error <span class="cov8" title="1">{
        if b.MinVersion != "" &amp;&amp; b.MinBundle != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("minimum version and bundle are mutually exclusive")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package v1alpha2

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"

        "github.com/google/uuid"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// MetadataKind object kind.
const MetadataKind = "Metadata"

// Metadata configures image set creation.
type Metadata struct {
        metav1.TypeMeta `json:",inline"`
        // MetadataSpec defines the global specified for Metadata types.
        MetadataSpec `json:",inline"`
}

// MetadataSpec defines the global configuration specified for Metadata types.
type MetadataSpec struct {
        // Uid uniquely identifies this metadata object.
        Uid uuid.UUID `json:"uid"`
        // SingleUse will ignore the past runs if set to true
        SingleUse bool `json:"singleUse"`
        // PastMirror contains the previous mirrored content
        PastMirror PastMirror `json:"pastMirror"`
        // PastAssociations define the history about the set of mirrored images including
        // child manifest and layer digest information
        PastAssociations []Association `json:"pastAssociations,omitempty"`
}

// PastMirror defines the specification for previously mirrored content.
type PastMirror struct {
        // TimeStamp defines when the mirrored was processed.
        Timestamp int `json:"timestamp"`
        // Sequence defines the serial number
        // assigned to the processed mirror.
        Sequence int `json:"sequence"`
        // Mirror defines the mirror defined
        // in the ImageSetConfigurationSpec provided
        // during the mirror processing.
        Mirror Mirror `json:"mirror"`
        // Operators are metadata about the set of mirrored operators in a mirror operation.
        Operators []OperatorMetadata `json:"operators,omitempty"`
        // Platforms are metadata about the set of mirrored platform release channels in a mirror operation.
        Platforms []PlatformMetadata `json:"platforms,omitempty"`
        // Associations are metadata about the set of mirrored images including
        // child manifest and layer digest information
        Associations []Association `json:"associations,omitempty"`
}

// OperatorMetadata holds an Operator's post-mirror metadata.
type OperatorMetadata struct {
        // Catalog references a catalog name from the mirror spec.
        Catalog string `json:"catalog"`
        // ImagePin is the resolved sha256 image name of Catalog.
        // This image will be pulled using the pull secret
        // in the metadata's Mirror config for this catalog.
        ImagePin string `json:"imagePin"`
        // IncludeConfig in OperatorMetadata holds the starting
        // versions of all heads-only mirrored catalogs. It will
        // be validated against the current catalog during each run
        // and updated.
        IncludeConfig `json:",inline"`
}

// PlatformMetadata holds a Platform's post-mirror metadata.
type PlatformMetadata struct {
        // ReleaseChannel references a channel name from the mirror spec.
        ReleaseChannel string `json:"channel"`
        // MinVersion in PlatformMetadata holds the starting
        // versions of all newly mirrored channels. This will
        // be populated the first time a channel is mirrored
        // and copied the remaining runs.
        MinVersion string `json:"minVersion"`
}

var _ io.Writer = &amp;InlinedIndex{}

type InlinedIndex json.RawMessage

func (index *InlinedIndex) Write(data []byte) (int, error) <span class="cov0" title="0">{
        msg := json.RawMessage{}
        if err := msg.UnmarshalJSON(data); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">*index = InlinedIndex(msg)
        return len(data), nil</span>
}

func (index InlinedIndex) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(index)
}</span>

// NewMetadata returns an empty
// instance of Metadata with the type metadata defined.
func NewMetadata() Metadata <span class="cov0" title="0">{
        return Metadata{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: GroupVersion.String(),
                        Kind:       MetadataKind,
                },
        }
}</span>

func (m *Metadata) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{

        gvk := GroupVersion.WithKind(MetadataKind)
        m.SetGroupVersionKind(gvk)

        buf := &amp;bytes.Buffer{}
        enc := json.NewEncoder(buf)
        // Use anonymous struct to avoid recursive marshal calls.
        var tmp struct {
                metav1.TypeMeta `json:",inline"`
                MetadataSpec    `json:",inline"`
        }
        tmp.TypeMeta = m.TypeMeta
        tmp.MetadataSpec = m.MetadataSpec
        if err := enc.Encode(tmp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encode %s: %v", gvk, err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package v1alpha2

import (
        "encoding/json"
        "errors"
)

// DefaultPlatformArchitecture defines the default
// architecture used by mirroring platform
// release payloads.
const DefaultPlatformArchitecture = "amd64"

// PlatformType defines the content type for platforms
type PlatformType int

// TypeOCP is default
const (
        TypeOCP PlatformType = iota
        TypeOKD
)

var platformTypeStrings = map[PlatformType]string{
        TypeOCP: "ocp",
        TypeOKD: "okd",
}

var platformStringsType = map[string]PlatformType{
        "ocp": TypeOCP,
        "okd": TypeOKD,
}

// String returns the string representation
// of an PlatformType
func (pt PlatformType) String() string <span class="cov0" title="0">{
        return platformTypeStrings[pt]
}</span>

// MarshalJSON marshals the PlatformType as a quoted json string
func (pt PlatformType) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if err := pt.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return json.Marshal(pt.String())</span>
}

// UnmarshalJSON unmarshals a quoted json string to the PlatformType
func (pt *PlatformType) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        var j string
        if err := json.Unmarshal(b, &amp;j); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*pt = platformStringsType[j]
        return nil</span>
}

func (pt PlatformType) validate() error <span class="cov0" title="0">{
        if _, ok := platformTypeStrings[pt]; !ok </span><span class="cov0" title="0">{
                return errors.New("unknown platform type")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package v1alpha2

// StorageConfig configures how metadata is stored.
type StorageConfig struct {
        // Registry defines the configuration for registry
        // storage types.
        Registry *RegistryConfig `json:"registry,omitempty"`
        // Local defines the configuration for local
        // storage types.
        Local *LocalConfig `json:"local,omitempty"`
}

// RegistryConfig configures a registry-based storage.
type RegistryConfig struct {
        // ImageURL at which the image can be pulled.
        ImageURL string `json:"imageURL"`
        // SkipTLS defines whether to use TLS validation
        // when interacting the the defined registry.
        SkipTLS bool `json:"skipTLS"`
}

// LocalConfig configure a local directory storage
type LocalConfig struct {
        Path string `json:"path"`
}

// IsSet will determine whether StorageConfig
// is empty or has backends set
func (s StorageConfig) IsSet() bool <span class="cov0" title="0">{
        if s.Registry != nil || s.Local != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package archive

import (
        "archive/tar"
        "context"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "strings"

        "github.com/mholt/archiver/v3"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
)

// Archiver defines the methods require to interface with an
// imageset archive.
type Archiver interface {
        String() string
        Archive([]string, string) error
        Extract(string, string, string) error
        Unarchive(string, string) error
        Write(archiver.File) error
        Create(io.Writer) error
        Close() error
        Walk(string, archiver.WalkFunc) error
        Open(io.Reader, int64) error
        Read() (archiver.File, error)
        CheckPath(string, string) error
}

type packager struct {
        manifest    map[string]struct{}
        blobs       map[string]struct{}
        packedBlobs map[string]struct{}
        Archiver
}

// NewArchiver creates a new archiver for tar archive manipultation
func NewArchiver() Archiver <span class="cov8" title="1">{
        return &amp;archiver.Tar{
                OverwriteExisting:      true,
                MkdirAll:               true,
                ImplicitTopLevelFolder: false,
                StripComponents:        0,
                ContinueOnError:        false,
        }
}</span>

// NewPackager create a new packager for imageset building.
func NewPackager(manifests []string, blobs []string) *packager <span class="cov8" title="1">{
        manifestSetToArchive := make(map[string]struct{}, len(manifests))
        blobSetToArchive := make(map[string]struct{}, len(blobs))

        for _, manifest := range manifests </span><span class="cov8" title="1">{
                manifestSetToArchive[manifest] = struct{}{}
        }</span>

        <span class="cov8" title="1">for _, blob := range blobs </span><span class="cov8" title="1">{
                blobSetToArchive[blob] = struct{}{}
        }</span>

        <span class="cov8" title="1">return &amp;packager{
                manifest:    manifestSetToArchive,
                blobs:       blobSetToArchive,
                packedBlobs: make(map[string]struct{}, len(blobs)),
                Archiver:    NewArchiver(),
        }</span>
}

// CreateSplitArchive will create one or more archives from the provided source directory.
func (p *packager) CreateSplitArchive(ctx context.Context, backend storage.Backend, maxSplitSize int64, destDir, sourceDir, prefix string, skipCleanup bool) error <span class="cov8" title="1">{

        // Declare split variables
        splitNum := 0
        splitSize := int64(0)
        splitPath := filepath.Join(destDir, fmt.Sprintf("%s_%06d.%s", prefix, splitNum, p.String()))

        splitFile, err := p.createArchive(splitPath)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating archive %s: %v", splitPath, err)
        }</span>

        <span class="cov8" title="1">sourceInfo, err := os.Stat(sourceDir)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: stat: %v", sourceDir, err)
        }</span>

        // write metadata to first archive
        <span class="cov8" title="1">if err := packMetadata(ctx, p, backend); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("writing metadata to archive %s failed: %v", splitPath, err)
        }</span>

        <span class="cov8" title="1">walkErr := filepath.Walk(sourceDir, func(fpath string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("traversing %s: %v", fpath, err)
                }</span>
                <span class="cov8" title="1">if info == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no file info")
                }</span>

                // pack the image associations and the metadata
                <span class="cov8" title="1">if includeFile(fpath) </span><span class="cov0" title="0">{
                        p.manifest[fpath] = struct{}{}
                }</span>

                <span class="cov8" title="1">var nameInArchive string

                switch </span>{
                case pack(p.manifest, fpath):<span class="cov0" title="0">
                        nameInArchive, err = archiver.NameInArchive(sourceInfo, sourceDir, fpath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("creating %s: %v", nameInArchive, err)
                        }</span>
                case pack(p.blobs, info.Name()) &amp;&amp; !pack(p.packedBlobs, info.Name()):<span class="cov0" title="0">
                        nameInArchive = blobInArchive(info.Name())
                        p.packedBlobs[info.Name()] = struct{}{}</span>

                default:<span class="cov8" title="1">
                        klog.V(1).Infof("File %s will not be archived, skipping...", fpath)
                        return nil</span>
                }

                <span class="cov0" title="0">var file io.ReadCloser
                if info.Mode().IsRegular() </span><span class="cov0" title="0">{
                        file, err = os.Open(filepath.Clean(fpath))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: opening: %v", fpath, err)
                        }</span>
                        <span class="cov0" title="0">defer file.Close()</span>
                }

                <span class="cov0" title="0">f := archiver.File{
                        FileInfo: archiver.FileInfo{
                                FileInfo:   info,
                                CustomName: nameInArchive,
                        },
                        ReadCloser: file,
                }

                // If the file is too large create a new one
                if info.Size()+splitSize &gt; maxSplitSize </span><span class="cov0" title="0">{

                        // Close current tar archive
                        if err := p.Close(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := splitFile.Close(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Increment split number and reset splitSize
                        <span class="cov0" title="0">splitNum += 1
                        splitSize = int64(0)
                        splitPath = filepath.Join(destDir, fmt.Sprintf("%s_%06d.%s", prefix, splitNum, p.String()))

                        // Create a new tar archive for writing
                        splitFile, err = p.createArchive(splitPath)

                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error creating archive %s: %v", splitPath, err)
                        }</span>
                }

                // Write file to current archive file
                <span class="cov0" title="0">if err = p.Write(f); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: writing: %s", fpath, err)
                }</span>

                // Delete file after written to archive
                <span class="cov0" title="0">if shouldRemove(fpath, info) &amp;&amp; !skipCleanup </span><span class="cov0" title="0">{
                        if err := os.Remove(fpath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">klog.V(1).Infof("File %s added to archive", fpath)

                splitSize += info.Size()

                return nil</span>
        })

        // Close final archive
        <span class="cov8" title="1">if err := p.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := splitFile.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return walkErr</span>
}

// Unarchive will extract files unless excluded to destination directory
func Unarchive(a Archiver, source, destination string, excludePaths []string) error <span class="cov0" title="0">{
        // Reconcile files to be unarchived
        var files []string
        err := a.Walk(source, func(f archiver.File) error </span><span class="cov0" title="0">{
                header, ok := f.Header.(*tar.Header)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected header to be *tar.Header but was %T", f.Header)
                }</span>
                // Only extract files that are not in the exclude paths
                <span class="cov0" title="0">if !shouldExclude(excludePaths, header.Name) &amp;&amp; !f.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, header.Name)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract files that have not been excluded
        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                if err := a.Extract(source, f, destination); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createArchive is a helper function that prepares a new split archive
func (p *packager) createArchive(splitPath string) (splitFile *os.File, err error) <span class="cov8" title="1">{

        // create a new target file
        splitFile, err = os.Create(filepath.Clean(splitPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating %s: %v", splitPath, err)
        }</span>

        // Create a new tar archive for writing
        <span class="cov8" title="1">klog.Infof("Creating archive %s", splitPath)
        if err = p.Create(splitFile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating archive %s: %v", splitPath, err)
        }</span>

        <span class="cov8" title="1">return splitFile, nil</span>
}

func pack(search map[string]struct{}, file string) bool <span class="cov8" title="1">{
        _, archive := search[file]
        return archive
}</span>

func blobInArchive(file string) string <span class="cov0" title="0">{
        return filepath.Join("blobs", file)
}</span>

func includeFile(fpath string) bool <span class="cov8" title="1">{
        includeFiles := map[string]struct{}{
                config.InternalDir:         {},
                config.CatalogsDir:         {},
                config.HelmDir:             {},
                config.ReleaseSignatureDir: {},
                config.GraphDataDir:        {},
        }
        split := strings.Split(filepath.Clean(fpath), string(filepath.Separator))
        _, found := includeFiles[split[0]]
        return found
}</span>

func shouldRemove(fpath string, info fs.FileInfo) bool <span class="cov0" title="0">{
        return !includeFile(fpath) &amp;&amp; !info.IsDir()
}</span>

// within returns true if sub is within or equal to parent.
func within(parent, sub string) bool <span class="cov0" title="0">{
        rel, err := filepath.Rel(parent, sub)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return !strings.Contains(rel, "..")</span>
}

// shouldExclude will check whether the files should
// be excluded from the extracting processing
func shouldExclude(exclude []string, file string) bool <span class="cov0" title="0">{
        for _, path := range exclude </span><span class="cov0" title="0">{
                if within(path, file) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func packMetadata(ctx context.Context, arc Archiver, backend storage.Backend) error <span class="cov8" title="1">{

        info, err := backend.Stat(ctx, config.MetadataBasePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">file, err := backend.Open(ctx, config.MetadataBasePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        f := archiver.File{
                FileInfo: archiver.FileInfo{
                        FileInfo:   info,
                        CustomName: config.MetadataBasePath,
                },
                ReadCloser: file,
        }
        return arc.Write(f)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package bundle

import (
        "archive/tar"
        "context"
        "errors"
        "fmt"
        "io/fs"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"

        "github.com/mholt/archiver/v3"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/archive"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
)

// ReconcileV2Dir gathers all manifests and blobs that were collected during a run
// and checks against the current list.
// This function is used to prepare a list of files that need to added to the Imageset.
func ReconcileV2Dir(assocs image.AssociationSet, filenames map[string]string) (manifests []string, blobs []string, err error) <span class="cov8" title="1">{

        foundFiles := map[string]struct{}{}

        // Checking against all digest because mirroring
        // by digest can cause the manifest to pop up in the blobs
        // directory
        // TODO(jpower432): Investigate why this happens.
        // Happens with oc image mirror as well.
        for _, digest := range assocs.GetDigests() </span><span class="cov8" title="1">{
                foundFiles[digest] = struct{}{}
        }</span>

        <span class="cov8" title="1">for rootOnDisk, rootInArchive := range filenames </span><span class="cov8" title="1">{

                if rootInArchive == "" </span><span class="cov0" title="0">{
                        rootInArchive = filepath.Base(rootInArchive)
                }</span>

                <span class="cov8" title="1">if filepath.Base(rootOnDisk) != config.V2Dir </span><span class="cov8" title="1">{
                        return manifests, blobs, fmt.Errorf("path %q is not a v2 directory", rootOnDisk)
                }</span>

                <span class="cov8" title="1">err = filepath.WalkDir(rootOnDisk, func(filename string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">info, err := d.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Rename manifests to ensure the match the files processed
                        // during archiving
                        <span class="cov8" title="1">nameInArchive := filepath.Join(rootInArchive, strings.TrimPrefix(filename, rootOnDisk))

                        dir := filepath.Dir(filename)
                        switch filepath.Base(dir) </span>{
                        case config.BlobDir:<span class="cov8" title="1">
                                if info.Mode().IsRegular() </span><span class="cov8" title="1">{
                                        if _, found := foundFiles[info.Name()]; found </span><span class="cov8" title="1">{
                                                klog.V(1).Infof("Blob %s exists in imageset, skipping...", info.Name())
                                                return nil
                                        }</span>
                                        <span class="cov8" title="1">blobs = append(blobs, info.Name())
                                        foundFiles[info.Name()] = struct{}{}
                                        klog.V(1).Infof("Adding blob %s", info.Name())</span>
                                }
                        default:<span class="cov8" title="1">
                                // Skips the blob dir which
                                // does not come up as its own base dir
                                if info.Name() == config.BlobDir </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">m := info.Mode()
                                if m.IsRegular() || m&amp;fs.ModeSymlink != 0 </span><span class="cov8" title="1">{
                                        manifests = append(manifests, nameInArchive)
                                }</span>
                        }

                        <span class="cov8" title="1">return nil</span>
                })
        }

        <span class="cov8" title="1">return manifests, blobs, err</span>
}

// ReadImageSet set will create a map with all the files located in the archives
func ReadImageSet(a archive.Archiver, from string) (map[string]string, error) <span class="cov8" title="1">{

        filesinArchive := make(map[string]string)

        file, err := os.Stat(from)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if file.IsDir() </span><span class="cov0" title="0">{

                // Walk the directory and load the files from the archives
                // into the map
                var match int
                err = filepath.Walk(from, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{

                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("traversing %s: %v", path, err)
                        }</span>
                        <span class="cov0" title="0">if info == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("no file info")
                        }</span>

                        <span class="cov0" title="0">extension := filepath.Ext(path)
                        extension = strings.TrimPrefix(extension, ".")
                        if extension == a.String() </span><span class="cov0" title="0">{
                                klog.V(1).Infof("Found archive %s", path)
                                return a.Walk(path, func(f archiver.File) error </span><span class="cov0" title="0">{
                                        switch t := f.Header.(type) </span>{
                                        case *tar.Header:<span class="cov0" title="0">
                                                name := filepath.Clean(t.Name)
                                                filesinArchive[name] = path
                                                match++
                                                return nil</span>
                                        default:<span class="cov0" title="0">
                                                return fmt.Errorf("file type not currently implemented %v", t)</span>
                                        }
                                })
                        }

                        <span class="cov0" title="0">return nil</span>
                })

                // Make sure the directory is not empty
                <span class="cov0" title="0">if match == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no archives found in directory %s", from)
                }</span>

        } else<span class="cov8" title="1"> {
                // Walk the archive and load the file names into the map
                err = a.Walk(from, func(f archiver.File) error </span><span class="cov8" title="1">{
                        switch t := f.Header.(type) </span>{
                        case *tar.Header:<span class="cov8" title="1">
                                name := filepath.Clean(t.Name)
                                filesinArchive[name] = from
                                return nil</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("file type not currently implemented %v", t)</span>
                        }
                })
        }

        <span class="cov8" title="1">return filesinArchive, err</span>
}

// ReadMetadataFromFile will return the metadata from a given imageset
func ReadMetadataFromFile(ctx context.Context, archivePath string) (v1alpha2.Metadata, error) <span class="cov8" title="1">{
        a := archive.NewArchiver()
        meta := v1alpha2.NewMetadata()

        // Get archive with metadata
        filesInArchive, err := ReadImageSet(a, archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>

        // Create workspace to work from
        <span class="cov8" title="1">tmpdir, err := ioutil.TempDir(".", "metadata")
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>
        <span class="cov8" title="1">defer os.RemoveAll(tmpdir)

        archive, ok := filesInArchive[config.MetadataBasePath]
        if !ok </span><span class="cov0" title="0">{
                return meta, errors.New("metadata is not in archive")
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("Extracting incoming metadata")
        if err := a.Extract(archive, config.MetadataBasePath, tmpdir); err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>

        <span class="cov8" title="1">workspace, err := storage.NewLocalBackend(tmpdir)

        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>

        <span class="cov8" title="1">if err := workspace.ReadMetadata(ctx, &amp;meta, config.MetadataBasePath); err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>

        <span class="cov8" title="1">return meta, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package bundle

import (
        "os"
        "path/filepath"

        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/config"
)

// MakeWorkspaceDir creates the initial
// directories needed for image processing.
func MakeWorkspaceDirs(rootDir string) error <span class="cov0" title="0">{
        paths := []string{
                filepath.Join(config.SourceDir, config.PublishDir),
                filepath.Join(config.SourceDir, config.V2Dir),
                filepath.Join(config.SourceDir, config.HelmDir),
                filepath.Join(config.SourceDir, config.ReleaseSignatureDir),
        }
        for _, p := range paths </span><span class="cov0" title="0">{
                dir := filepath.Join(rootDir, p)
                if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        klog.Infof("Creating directory: %v", dir)
                        err := os.MkdirAll(dir, os.ModePerm)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        klog.Infof("Found: %v", dir)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cincinnati

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/blang/semver/v4"
        "k8s.io/klog/v2"
)

const (
        // GraphMediaType is the media-type specified in the HTTP Accept header
        // of requests sent to the Cincinnati-v1 Graph API.
        GraphMediaType = "application/json"

        // Timeout when calling upstream Cincinnati stack.
        getUpdatesTimeout = time.Minute * 60
        // UpdateURL is the Cincinnati endpoint for the OpenShift platform.
        UpdateURL = "https://api.openshift.com/api/upgrades_info/v1/graph"
        // OkdUpdateURL is the Cincinnati endpoint for the OKD platform.
        OkdUpdateURL = "https://origin-release.ci.openshift.org/graph"
)

// Error is returned when are unable to get updates.
type Error struct {
        // Reason is the reason suggested for the Cincinnati calculation error.
        Reason string

        // Message is the message suggested for Cincinnati calculation error..
        Message string

        // cause is the upstream error, if any, being wrapped by this error.
        cause error
}

// Error serializes the error as a string, to satisfy the error interface.
func (err *Error) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", err.Reason, err.Message)
}</span>

// Update is a single node from the update graph.
type Update node

// GetUpdates fetches the requested update payload from the specified
// upstream Cincinnati stack given the current version, architecture, and channel.
// The shortest path is calculated between the current and requested version from the graph edge
// data.
func GetUpdates(ctx context.Context, c Client, arch string, channel string, version semver.Version, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        var current Update
        var requested Update
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, version.String())

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("version %s in channel %s: %v", version.String(), channel, err),
                        cause:   err,
                }
        }</span>

        // Find the current version within the graph.
        <span class="cov8" title="1">var currentIdx int
        found := false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if version.EQ(node.Version) </span><span class="cov8" title="1">{
                        currentIdx = i
                        current = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("current version %s not found in the %q channel", version, channel),
                }
        }</span>

        <span class="cov8" title="1">var destinationIdx int
        found = false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if reqVer.EQ(node.Version) </span><span class="cov8" title="1">{
                        destinationIdx = i
                        requested = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("requested version %s not found in the %q channel", reqVer, channel),
                }
        }</span>

        <span class="cov8" title="1">edgesByOrigin := make(map[int][]int, len(graph.Nodes))
        for _, edge := range graph.Edges </span><span class="cov8" title="1">{
                edgesByOrigin[edge.Origin] = append(edgesByOrigin[edge.Origin], edge.Destination)
        }</span>

        // Sort destination by semver to ensure deterministic result
        <span class="cov8" title="1">for origin, destinations := range edgesByOrigin </span><span class="cov8" title="1">{
                sort.Slice(destinations, func(i, j int) bool </span><span class="cov8" title="1">{
                        return graph.Nodes[destinations[i]].Version.GT(graph.Nodes[destinations[j]].Version)
                }</span>)
                <span class="cov8" title="1">edgesByOrigin[origin] = destinations</span>
        }

        <span class="cov8" title="1">shortestPath := func(g map[int][]int, start, end int) []int </span><span class="cov8" title="1">{
                prev := map[int]int{}
                visited := map[int]struct{}{}
                queue := []int{start}
                visited[start] = struct{}{}
                prev[start] = -1

                for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                        node := queue[0]
                        queue = queue[1:]
                        if node == end </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">for _, neighbor := range g[node] </span><span class="cov8" title="1">{
                                if _, ok := visited[neighbor]; !ok </span><span class="cov8" title="1">{
                                        prev[neighbor] = node
                                        queue = append(queue, neighbor)
                                        visited[neighbor] = struct{}{}
                                }</span>
                        }
                }

                // No path to end
                <span class="cov8" title="1">if _, ok := visited[end]; !ok </span><span class="cov8" title="1">{
                        return []int{}
                }</span>

                <span class="cov8" title="1">path := []int{end}
                for next := prev[end]; next != -1; next = prev[next] </span><span class="cov8" title="1">{
                        path = append(path, next)
                }</span>

                // Reverse path.
                <span class="cov8" title="1">for i, j := 0, len(path)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                        path[i], path[j] = path[j], path[i]
                }</span>

                <span class="cov8" title="1">return path</span>
        }

        <span class="cov8" title="1">nextIdxs := shortestPath(edgesByOrigin, currentIdx, destinationIdx)

        var updates []Update
        for _, i := range nextIdxs </span><span class="cov8" title="1">{
                updates = append(updates, Update(graph.Nodes[i]))
        }</span>

        <span class="cov8" title="1">return current, requested, updates, nil</span>
}

// CalculateUpgrades fetches and calculates all the update payloads from the specified
// upstream Cincinnati stack given the current and target version and channel.
func CalculateUpgrades(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        if sourceChannel == targetChannel </span><span class="cov0" title="0">{
                return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)
        }</span>

        // Check the major and minor versions are the same with different
        // channel prefixes
        <span class="cov8" title="1">source, target, _, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                isBlocked, err := handleBlockedEdges(ctx, c, arch, targetChannel, startVer)
                if err != nil </span><span class="cov0" title="0">{
                        return Update{}, Update{}, nil, err
                }</span>
                <span class="cov8" title="1">if isBlocked </span><span class="cov0" title="0">{
                        // If blocked path is found, just return the requested version and any accumulated
                        // upgrades to the caller
                        klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                        return GetUpdates(ctx, c, arch, targetChannel, reqVer, reqVer)
                }</span>
                <span class="cov8" title="1">return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)</span>
        }

        // Perform initial calculation for the source channel and
        // recurse through the rest until the target or a blocked
        // edge is hit.
        <span class="cov8" title="1">latest, err := GetChannelMinOrMax(ctx, c, arch, sourceChannel, false)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, fmt.Errorf("channel %q: %v", sourceChannel, err)
        }</span>
        <span class="cov8" title="1">current, _, upgrades, err := GetUpdates(ctx, c, arch, sourceChannel, startVer, latest)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, fmt.Errorf("channel %q: %v", sourceChannel, err)
        }</span>

        <span class="cov8" title="1">requested, newUpgrades, err := calculate(ctx, c, arch, sourceChannel, targetChannel, latest, reqVer)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">upgrades = append(upgrades, newUpgrades...)

        var finalUpgrades []Update
        seen := make(map[string]struct{}, len(upgrades))
        for _, upgrade := range upgrades </span><span class="cov8" title="1">{
                if _, ok := seen[upgrade.Image]; !ok </span><span class="cov8" title="1">{
                        finalUpgrades = append(finalUpgrades, upgrade)
                        seen[upgrade.Image] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">return current, requested, finalUpgrades, nil</span>
}

// calculate will calculate Cincinnati upgrades between channels by finding the latest versions in the source channels
// and incrementing the minor version until the target channel is reached.
func calculate(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (requested Update, upgrades []Update, err error) <span class="cov8" title="1">{
        source, target, prefix, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        // We immediately bump the source channel since current source channel upgrades have
        // already been calculated
        <span class="cov8" title="1">source.Minor++
        currChannel := fmt.Sprintf("%s-%v.%v", prefix, source.Major, source.Minor)

        var targetVer semver.Version
        if source.EQ(target) </span><span class="cov8" title="1">{
                // If this is the target channel major.minor get
                // requested version, so we don't exceed the maximum version
                // Set the target channel to make sure we have the intended
                // channel prefix
                targetVer = reqVer
                currChannel = targetChannel
        }</span> else<span class="cov8" title="1"> {
                targetVer, err = GetChannelMinOrMax(ctx, c, arch, currChannel, false)
                if err != nil </span><span class="cov0" title="0">{
                        return requested, upgrades, err
                }</span>
        }

        <span class="cov8" title="1">isBlocked, err := handleBlockedEdges(ctx, c, arch, currChannel, startVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">if isBlocked </span><span class="cov8" title="1">{
                // If blocked path is found, just return the requested version and any accumulated
                // upgrades to the caller
                _, requested, _, err = GetUpdates(ctx, c, arch, targetChannel, targetVer, targetVer)
                //Warnf is 5?
                klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">klog.V(1).Infof("Getting updates for version %s in channel %s", startVer.String(), currChannel)
        _, requested, upgrades, err = GetUpdates(ctx, c, arch, currChannel, startVer, targetVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                return requested, upgrades, nil
        }</span>

        <span class="cov8" title="1">currRequested, currUpgrades, err := calculate(ctx, c, arch, currChannel, targetChannel, targetVer, reqVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">requested = currRequested
        upgrades = append(upgrades, currUpgrades...)

        return requested, upgrades, nil</span>
}

// handleBlockedEdges will check for the starting version in the current channel
// if it does not exist the version is blocked.
func handleBlockedEdges(ctx context.Context, c Client, arch, targetChannel string, startVer semver.Version) (bool, error) <span class="cov8" title="1">{
        chanVersions, err := GetVersions(ctx, c, arch, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return true, err
        }</span>
        <span class="cov8" title="1">for _, v := range chanVersions </span><span class="cov8" title="1">{
                if v.EQ(startVer) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// getSemverFromChannel will return the major and minor version from the source and target channels. The prefix returned is
// for the source channels for cross channel calculations.
func getSemverFromChannels(sourceChannel, targetChannel string) (source, target semver.Version, prefix string, err error) <span class="cov8" title="1">{
        // Get semver representation of source and target channel versions
        sourceIdx := strings.LastIndex(sourceChannel, "-")
        if sourceIdx == -1 </span><span class="cov0" title="0">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", sourceChannel)
        }</span>
        <span class="cov8" title="1">targetIdx := strings.LastIndex(targetChannel, "-")
        if targetIdx == -1 </span><span class="cov8" title="1">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", targetChannel)
        }</span>
        <span class="cov8" title="1">source, err = semver.Parse(fmt.Sprintf("%s.0", sourceChannel[sourceIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">target, err = semver.Parse(fmt.Sprintf("%s.0", targetChannel[targetIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">prefix = sourceChannel[:sourceIdx]
        return source, target, prefix, nil</span>
}

// GetChannelMinOrMax fetches the minimum or maximum version from the specified
// upstream Cincinnati stack given architecture and channel.
func GetChannelMinOrMax(ctx context.Context, c Client, arch string, channel string, min bool) (semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return semver.Version{}, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all versions within the graph.
        <span class="cov8" title="1">var versionMatcher *regexp.Regexp
        if versionFilter := os.Getenv("VERSION_FILTER"); len(versionFilter) != 0 </span><span class="cov0" title="0">{
                klog.Info("Usage of the VERSION_FILTER environment variable is unsupported")
                versionMatcher, err = regexp.Compile(versionFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return semver.Version{}, &amp;Error{
                                Reason:  "InvalidVersionFilter",
                                Message: fmt.Sprintf("Version filter '%s' is not a valid regular expression", versionFilter),
                                cause:   err,
                        }
                }</span>
        }

        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if versionMatcher == nil || versionMatcher.MatchString(node.Version.String()) </span><span class="cov8" title="1">{
                        Vers = append(Vers, node.Version)
                }</span>
        }

        <span class="cov8" title="1">semver.Sort(Vers)

        if len(Vers) == 0 </span><span class="cov0" title="0">{
                return semver.Version{}, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found for %q in the %q channel", arch, channel),
                }
        }</span>

        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                return Vers[0], nil
        }</span>

        <span class="cov8" title="1">return Vers[len(Vers)-1], nil</span>
}

// GetChannels fetches the channels containing update payloads from the specified
// upstream Cincinnati stack.
func GetChannels(ctx context.Context, c Client, channel string) (map[string]struct{}, error) <span class="cov0" title="0">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams("", channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>

        <span class="cov0" title="0">channels := make(map[string]struct{})

        for _, node := range graph.Nodes </span><span class="cov0" title="0">{
                values := node.Metadata["io.openshift.upgrades.graph.release.channels"]

                for _, value := range strings.Split(values, ",") </span><span class="cov0" title="0">{
                        channels[value] = struct{}{}
                }</span>
        }

        <span class="cov0" title="0">return channels, nil</span>
}

// GetVersions will return all update payloads from the specified
// upstream Cincinnati stack given architecture and channel.
func GetVersions(ctx context.Context, c Client, arch, channel string) ([]semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>
        // Find the all versions within the graph.
        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{

                Vers = append(Vers, node.Version)
        }</span>

        <span class="cov8" title="1">if len(Vers) == 0 </span><span class="cov8" title="1">{
                return nil, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found in the %q channel", channel),
                }
        }</span>

        <span class="cov8" title="1">semver.Sort(Vers)

        return Vers, nil</span>
}

// GetUpdatesInRange will return all update payload within a semver range for a specified channel and architecture.
func GetUpdatesInRange(ctx context.Context, c Client, channel, arch string, updateRange semver.Range) ([]Update, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all updates within the range
        <span class="cov8" title="1">var updates []Update
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if updateRange(node.Version) </span><span class="cov8" title="1">{
                        updates = append(updates, Update(node))
                }</span>

        }
        <span class="cov8" title="1">return updates, nil</span>
}

// getGraphData fetches the update graph from the upstream Cincinnati stack given the current version and channel
func getGraphData(ctx context.Context, c Client) (graph graph, err error) <span class="cov8" title="1">{
        transport := c.GetTransport()
        uri := c.GetURL()
        // Download the update graph.
        req, err := http.NewRequest("GET", uri.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "InvalidRequest", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">req.Header.Add("Accept", GraphMediaType)
        if transport != nil &amp;&amp; transport.TLSClientConfig != nil </span><span class="cov0" title="0">{
                if c.GetTransport().TLSClientConfig.ClientCAs == nil </span><span class="cov0" title="0">{
                        klog.V(5).Infof("Using a root CA pool with 0 root CA subjects to request updates from %s", uri)
                }</span> else<span class="cov0" title="0"> {

                        klog.V(5).Infof("Using a root CA pool with %n root CA subjects to request updates from %s", len(transport.TLSClientConfig.RootCAs.Subjects()), uri)
                }</span>
        }

        <span class="cov8" title="1">if transport != nil &amp;&amp; transport.Proxy != nil </span><span class="cov0" title="0">{
                proxy, err := transport.Proxy(req)
                if err == nil &amp;&amp; proxy != nil </span><span class="cov0" title="0">{
                        klog.Infof("Using proxy %s to request updates from %s", proxy.Host, uri)
                }</span>
        }

        <span class="cov8" title="1">client := http.Client{}
        if transport != nil </span><span class="cov8" title="1">{
                client.Transport = transport
        }</span>
        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, getUpdatesTimeout)
        defer cancel()
        resp, err := client.Do(req.WithContext(timeoutCtx))
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "RemoteFailed", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: fmt.Sprintf("unexpected HTTP status: %s", resp.Status)}
        }</span>

        // Parse the graph.
        <span class="cov8" title="1">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">if err = json.Unmarshal(body, &amp;graph); err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseInvalid", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">return graph, nil</span>
}

type graph struct {
        Nodes []node
        Edges []edge
}

type node struct {
        Version  semver.Version    `json:"version"`
        Image    string            `json:"payload"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

type edge struct {
        Origin      int
        Destination int
}

// UnmarshalJSON unmarshals an edge in the update graph. The edge's JSON
// representation is a two-element array of indices, but Go's representation is
// a struct with two elements so this custom unmarshal method is required.
func (e *edge) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var fields []int
        if err := json.Unmarshal(data, &amp;fields); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(fields) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("expected 2 fields, found %d", len(fields))
        }</span>

        <span class="cov8" title="1">e.Origin = fields[0]
        e.Destination = fields[1]

        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cincinnati

import (
        "crypto/tls"
        "crypto/x509"
        "net/http"
        "net/url"
        "os"

        "github.com/google/uuid"
        "k8s.io/klog/v2"
)

// Client is a Cincinnati client which can be used to fetch update graphs from
// an upstream Cincinnati stack.
type Client interface {
        GetURL() *url.URL
        SetQueryParams(arch, channel, version string)
        GetID() uuid.UUID
        GetTransport() *http.Transport
}

var _ Client = &amp;ocpClient{}

type ocpClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOCPClient creates a new OCP Cincinnati client with the given client identifier.
func NewOCPClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        var updateGraphURL string
        if updateURLOverride := os.Getenv("UPDATE_URL_OVERRIDE"); len(updateURLOverride) != 0 </span><span class="cov0" title="0">{
                klog.Info("Usage of the UPDATE_URL_OVERRIDE environment variable is unsupported")
                updateGraphURL = updateURLOverride
        }</span> else<span class="cov8" title="1"> {
                updateGraphURL = UpdateURL
        }</span>
        <span class="cov8" title="1">upstream, err := url.Parse(updateGraphURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;ocpClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *ocpClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *ocpClient) GetTransport() *http.Transport <span class="cov0" title="0">{
        return c.transport
}</span>

func (c *ocpClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *ocpClient) SetQueryParams(arch, channel, version string) <span class="cov8" title="1">{
        queryParams := c.url.Query()
        queryParams.Add("id", c.id.String())
        params := map[string]string{
                "arch":    arch,
                "channel": channel,
                "version": version,
        }
        for key, value := range params </span><span class="cov8" title="1">{
                if value != "" </span><span class="cov8" title="1">{
                        queryParams.Add(key, value)
                }</span>
        }
        <span class="cov8" title="1">c.url.RawQuery = queryParams.Encode()</span>
}

var _ Client = &amp;okdClient{}

type okdClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOKDClient creates a new OKD Cincinnati client with the given client identifier.
func NewOKDClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        var updateGraphURL string
        if updateURLOverride := os.Getenv("UPDATE_URL_OVERRIDE"); len(updateURLOverride) != 0 </span><span class="cov0" title="0">{
                klog.Info("Usage of the UPDATE_URL_OVERRIDE environment variable is unsupported")
                updateGraphURL = updateURLOverride
        }</span> else<span class="cov8" title="1"> {
                updateGraphURL = OkdUpdateURL
        }</span>

        <span class="cov8" title="1">upstream, err := url.Parse(updateGraphURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;okdClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *okdClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *okdClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *okdClient) GetTransport() *http.Transport <span class="cov0" title="0">{
        return c.transport
}</span>

func (c *okdClient) SetQueryParams(_, _, _ string) {<span class="cov8" title="1">
        // Do nothing
}</span>

func getTLSConfig() (*tls.Config, error) <span class="cov8" title="1">{
        certPool, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config := &amp;tls.Config{
                RootCAs:    certPool,
                MinVersion: tls.VersionTLS12,
        }
        return config, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cincinnati

import (
        "errors"
        "sort"

        "github.com/blang/semver/v4"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
)

// ErrNoPreviousRelease is returned when no releases can be found in the
// release channels.
var ErrNoPreviousRelease = errors.New("no previous release downloads detected")

// FindRelease will find the minimum or maximum release for a set of ReleaseChannels
func FindRelease(channels []v1alpha2.ReleaseChannel, min bool) (string, semver.Version, error) <span class="cov8" title="1">{
        vers, err := findReleases(channels, min)
        if err != nil </span><span class="cov8" title="1">{
                return "", semver.Version{}, err
        }</span>

        <span class="cov8" title="1">keys := make([]string, 0, len(vers))
        for k := range vers </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].GT(vers[keys[j]])
                }</span>)
        } else<span class="cov8" title="1"> {
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].LT(vers[keys[j]])
                }</span>)
        }

        <span class="cov8" title="1">return keys[len(keys)-1], vers[keys[len(keys)-1]], nil</span>
}

func findReleases(channels []v1alpha2.ReleaseChannel, min bool) (map[string]semver.Version, error) <span class="cov8" title="1">{
        vers := make(map[string]semver.Version, len(channels))
        if len(channels) == 0 </span><span class="cov8" title="1">{
                return vers, ErrNoPreviousRelease
        }</span>

        <span class="cov8" title="1">for _, ch := range channels </span><span class="cov8" title="1">{

                ver := ch.MaxVersion
                if min </span><span class="cov8" title="1">{
                        ver = ch.MinVersion
                }</span>
                <span class="cov8" title="1">parsedVer, err := semver.Parse(ver)
                if err != nil </span><span class="cov0" title="0">{
                        return vers, err
                }</span>
                <span class="cov8" title="1">vers[ch.Name] = parsedVer</span>
        }

        <span class="cov8" title="1">return vers, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"

        "github.com/containerd/containerd/errdefs"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        "github.com/operator-framework/operator-registry/pkg/image/containerdregistry"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/image"
)

type AdditionalOptions struct {
        *MirrorOptions
}

func NewAdditionalOptions(mo *MirrorOptions) *AdditionalOptions <span class="cov8" title="1">{
        opts := &amp;AdditionalOptions{MirrorOptions: mo}
        return opts
}</span>

// Plan provides an image mapping with source and destination for provided AdditionalImages
func (o *AdditionalOptions) Plan(ctx context.Context, imageList []v1alpha2.Image) (image.TypedImageMapping, error) <span class="cov8" title="1">{
        mmappings := make(image.TypedImageMapping, len(imageList))
        resolver, err := containerdregistry.NewResolver("", o.SourceSkipTLS, o.SourcePlainHTTP, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating image resolver: %v", err)
        }</span>
        <span class="cov8" title="1">for _, img := range imageList </span><span class="cov8" title="1">{
                // Get source image information
                srcRef, err := image.ParseReference(img.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return mmappings, fmt.Errorf("error parsing source image %s: %v", img.Name, err)
                }</span>
                <span class="cov8" title="1">srcRef.Ref = srcRef.Ref.DockerClientDefaults()

                // Instead of returning an error, just log it.
                isSkipErr := func(err error) bool </span><span class="cov0" title="0">{
                        return o.ContinueOnError || (o.SkipMissing &amp;&amp; errors.Is(err, errdefs.ErrNotFound))
                }</span>

                <span class="cov8" title="1">ref := srcRef.Ref.Exact()
                if !image.IsImagePinned(ref) </span><span class="cov8" title="1">{
                        srcImage, err := image.ResolveToPin(ctx, resolver, ref)
                        if err != nil </span><span class="cov0" title="0">{
                                if !isSkipErr(err) </span><span class="cov0" title="0">{
                                        return mmappings, err
                                }</span>
                                <span class="cov0" title="0">klog.Warning(err)
                                continue</span>
                        }
                        <span class="cov8" title="1">pinnedRef, err := image.ParseReference(srcImage)
                        if err != nil </span><span class="cov0" title="0">{
                                return mmappings, fmt.Errorf("error parsing source image %s: %v", img.Name, err)
                        }</span>
                        <span class="cov8" title="1">srcRef.Ref.ID = pinnedRef.Ref.ID</span>
                }

                // Set destination image information as file by default
                <span class="cov8" title="1">dstRef := srcRef
                dstRef.Type = imagesource.DestinationFile
                // The registry component is not included in the final path.
                dstRef.Ref.Registry = ""

                mmappings.Add(srcRef, dstRef, v1alpha2.TypeGeneric)</span>
        }

        <span class="cov8" title="1">return mmappings, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package mirror

import (
        "fmt"
        "regexp"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
)

type ErrBlocked struct {
        image string
}

func (e ErrBlocked) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("image %s blocked", e.image)
}</span>

// IsBlocked will return a boolean value on whether an image
// is specified as blocked in the ImageSetConfigSpec
func isBlocked(blocked []v1alpha2.Image, imgRef string) (bool, error) <span class="cov8" title="1">{
        for _, img := range blocked </span><span class="cov8" title="1">{
                matcher, err := regexp.Compile(img.Name)
                if err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("error parsing blocked image regular expression %s: %v", img.Name, err)
                }</span>

                <span class="cov8" title="1">if matcher.MatchString(imgRef) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package mirror

import (
        "archive/tar"
        "context"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "os"
        "os/exec"
        "path"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/google/go-containerregistry/pkg/crane"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/layout"
        "github.com/google/go-containerregistry/pkg/v1/mutate"
        "github.com/openshift/library-go/pkg/image/reference"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        "github.com/operator-framework/operator-registry/pkg/containertools"
        "github.com/operator-framework/operator-registry/pkg/image/containerdregistry"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/image/builder"
)

const (
        opmCachePrefix  = "/tmp/cache"
        opmBinarySuffix = "opm"
        cacheFolderUID  = 1001
        cacheFolderGID  = 0
)

type NoCacheArgsErrorType struct{}

var NoCacheArgsError = NoCacheArgsErrorType{}

func (m NoCacheArgsErrorType) Error() string <span class="cov0" title="0">{
        return "catalog container image command does not specify cache arguments - no cache generation will be attempted"
}</span>

// unpackCatalog will unpack file-based catalogs if they exists
func (o *MirrorOptions) unpackCatalog(dstDir string, filesInArchive map[string]string) (bool, error) <span class="cov0" title="0">{
        var found bool
        if err := unpack(config.CatalogsDir, dstDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                nferr := &amp;ErrArchiveFileNotFound{}
                if errors.As(err, &amp;nferr) || errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        klog.V(2).Info("No catalogs found in archive, skipping catalog rebuild")
                        return found, nil
                }</span>
                <span class="cov0" title="0">return found, err</span>
        }
        <span class="cov0" title="0">found = true
        return found, nil</span>
}

/*
rebuildCatalogs will modify an OCI catalog in &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/layout with
the index.json files found in &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/index/index.json

# Arguments

• ctx: cancellation context

• dstDir: the path to where the config.SourceDir resides

# Returns

• image.TypedImageMapping: the source/destination mapping for the catalog

• error: non-nil if error occurs, nil otherwise
*/
func (o *MirrorOptions) rebuildCatalogs(ctx context.Context, dstDir string) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        refs := image.TypedImageMapping{}
        var err error

        mirrorRef := imagesource.TypedImageReference{Type: imagesource.DestinationRegistry}
        mirrorRef.Ref, err = reference.Parse(o.ToMirror)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dstDir = filepath.Clean(dstDir)
        catalogsByImage := map[image.TypedImage]string{}
        if err := filepath.Walk(dstDir, func(fpath string, info fs.FileInfo, err error) error </span><span class="cov0" title="0">{

                // Skip the layouts dir because we only need
                // to process the parent directory one time
                if filepath.Base(fpath) == config.LayoutsDir </span><span class="cov0" title="0">{
                        return filepath.SkipDir
                }</span>

                <span class="cov0" title="0">if err != nil || info == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // From the index path determine the artifacts (index and layout) directory.
                // Using that path to determine the corresponding catalog image for processing.
                <span class="cov0" title="0">slashPath := filepath.ToSlash(fpath)
                if base := path.Base(slashPath); base == "index.json" </span><span class="cov0" title="0">{
                        // remove the index.json from the path
                        // results in &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/index
                        slashPath = path.Dir(slashPath)
                        // remove the index folder from the path
                        // results in &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;
                        slashPath = strings.TrimSuffix(slashPath, config.IndexDir)

                        // remove the &lt;some path&gt;/src/catalogs from the path to arrive at &lt;repoPath&gt;
                        repoPath := strings.TrimPrefix(slashPath, fmt.Sprintf("%s/%s/", dstDir, config.CatalogsDir))
                        // get the repo namespace and id (where ID is a SHA or tag)
                        // example: foo.com/foo/bar/&lt;id&gt;
                        regRepoNs, id := path.Split(path.Dir(repoPath))
                        regRepoNs = path.Clean(regRepoNs)
                        // reconstitute the path into a valid docker ref
                        var img string
                        if strings.Contains(id, ":") </span><span class="cov0" title="0">{
                                // Digest.
                                img = fmt.Sprintf("%s@%s", regRepoNs, id)
                        }</span> else<span class="cov0" title="0"> {
                                // Tag.
                                img = fmt.Sprintf("%s:%s", regRepoNs, id)
                        }</span>
                        <span class="cov0" title="0">ctlgRef := image.TypedImage{}
                        ctlgRef.Type = imagesource.DestinationRegistry
                        sourceRef, err := image.ParseReference(img)
                        // since we can't really tell if the "img" reference originated from an actual docker
                        // reference or from an OCI file path that approximates a docker reference, ParseReference
                        // might not lowercase the name and namespace values which is required by the
                        // docker reference spec (see https://github.com/distribution/distribution/blob/main/reference/reference.go).
                        // Therefore we lower case name and namespace here to make sure it's done.
                        sourceRef.Ref.Name = strings.ToLower(sourceRef.Ref.Name)
                        sourceRef.Ref.Namespace = strings.ToLower(sourceRef.Ref.Namespace)

                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error parsing index dir path %q as image %q: %v", fpath, img, err)
                        }</span>
                        <span class="cov0" title="0">ctlgRef.Ref = sourceRef.Ref
                        // Update registry so the existing catalog image can be pulled.
                        ctlgRef.Ref.Registry = mirrorRef.Ref.Registry
                        ctlgRef.Ref.Namespace = path.Join(o.UserNamespace, ctlgRef.Ref.Namespace)
                        ctlgRef = ctlgRef.SetDefaults()
                        // Unset the ID when passing to the image builder.
                        // Tags are needed here since the digest will be recalculated.
                        ctlgRef.Ref.ID = ""

                        catalogsByImage[ctlgRef] = slashPath

                        // Add to mapping for ICSP generation
                        refs.Add(sourceRef, ctlgRef.TypedImageReference, v1alpha2.TypeOperatorCatalog)</span>
                }
                <span class="cov0" title="0">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>

        // update the catalogs in the OCI layout directory and push them to their destination
        <span class="cov0" title="0">if err := o.processCatalogRefs(ctx, catalogsByImage); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // use the resolver to obtain the digests of the newly pushed images
        <span class="cov0" title="0">resolver, err := containerdregistry.NewResolver("", o.DestSkipTLS, o.DestPlainHTTP, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating image resolver: %v", err)
        }</span>

        // Resolve the image's digest for ICSP creation.
        <span class="cov0" title="0">for source, dest := range refs </span><span class="cov0" title="0">{
                _, desc, err := resolver.Resolve(ctx, dest.Ref.Exact())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error retrieving digest for catalog image %q: %v", dest.Ref.Exact(), err)
                }</span>
                <span class="cov0" title="0">dest.Ref.ID = desc.Digest.String()
                refs[source] = dest</span>
        }

        <span class="cov0" title="0">return refs, nil</span>
}

/*
processCatalogRefs uses the image builder to update a given image using the data provided in catalogRefs.

# Arguments

• ctx: cancellation context

• catalogsByImage: key is catalog destination reference, value is &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;

# Returns

• error: non-nil if error occurs, nil otherwise
*/
func (o *MirrorOptions) processCatalogRefs(ctx context.Context, catalogsByImage map[image.TypedImage]string) error <span class="cov0" title="0">{
        for ctlgRef, artifactDir := range catalogsByImage </span><span class="cov0" title="0">{
                // Always build the catalog image with the new declarative config catalog
                // using the original catalog as the base image
                var layoutPath layout.Path
                refExact := ctlgRef.Ref.Exact()

                var destInsecure bool
                if o.DestPlainHTTP || o.DestSkipTLS </span><span class="cov0" title="0">{
                        destInsecure = true
                }</span>

                // Check push permissions before trying to resolve for Quay compatibility
                <span class="cov0" title="0">nameOpts := getNameOpts(destInsecure)
                remoteOpts := getRemoteOpts(ctx, destInsecure)
                imgBuilder := builder.NewImageBuilder(nameOpts, remoteOpts)

                klog.Infof("Rendering catalog image %q with file-based catalog ", refExact)

                layersToAdd := []v1.Layer{}
                layersToDelete := []v1.Layer{}
                withCacheRegeneration := true
                _, err := os.Stat(filepath.Join(artifactDir, config.OPMCacheLocationPlaceholder))
                if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        withCacheRegeneration = false
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to determine location of cache for image %s. Cache generation failed: %v", ctlgRef, err)
                }</span>

                <span class="cov0" title="0">configLayerToAdd, err := builder.LayerFromPathWithUidGid("/configs", filepath.Join(artifactDir, config.IndexDir), 0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating add layer: %v", err)
                }</span>
                <span class="cov0" title="0">layersToAdd = append(layersToAdd, configLayerToAdd)

                // Since we are defining the FBC as index.json,
                // remove anything that may currently exist
                deletedConfigLayer, err := deleteLayer("/.wh.configs")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating deleted layer: %v", err)
                }</span>
                <span class="cov0" title="0">layersToDelete = append(layersToDelete, deletedConfigLayer)

                if withCacheRegeneration </span><span class="cov0" title="0">{

                        opmCmdPath := filepath.Join(artifactDir, config.OpmBinDir, "opm")
                        _, err = os.Stat(opmCmdPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot find opm in the extracted catalog %v for %s on %s: %v", ctlgRef, runtime.GOOS, runtime.GOARCH, err)
                        }</span>
                        <span class="cov0" title="0">absConfigPath, err := filepath.Abs(filepath.Join(artifactDir, config.IndexDir))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error getting absolute path for catalog's index %v: %v", filepath.Join(artifactDir, config.IndexDir), err)
                        }</span>
                        <span class="cov0" title="0">absCachePath, err := filepath.Abs(filepath.Join(artifactDir, config.TmpDir))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error getting absolute path for catalog's cache %v: %v", filepath.Join(artifactDir, config.TmpDir), err)
                        }</span>
                        <span class="cov0" title="0">cmd := exec.Command(opmCmdPath, "serve", absConfigPath, "--cache-dir", absCachePath, "--cache-only")
                        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error regenerating the cache for %v: %v", ctlgRef, err)
                        }</span>
                        // Fix OCPBUGS-17546:
                        // Add the cache under /cache in a new layer (instead of white-out /tmp/cache, which resulted in crashLoopBackoff only on some clusters)
                        <span class="cov0" title="0">cacheLayerToAdd, err := builder.LayerFromPathWithUidGid("/cache", filepath.Join(artifactDir, config.TmpDir), cacheFolderUID, cacheFolderGID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error creating add layer: %v", err)
                        }</span>
                        <span class="cov0" title="0">layersToAdd = append(layersToAdd, cacheLayerToAdd)</span>
                }

                // Deleted layers must be added first in the slice
                // so that the /configs and /tmp directories are deleted
                // and then added back from the layers rebuilt from the new FBC.
                <span class="cov0" title="0">layers := []v1.Layer{}
                layers = append(layers, layersToDelete...)
                layers = append(layers, layersToAdd...)

                layoutDir := filepath.Join(artifactDir, config.LayoutsDir)
                layoutPath, err = imgBuilder.CreateLayout("", layoutDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating OCI layout: %v", err)
                }</span>

                <span class="cov0" title="0">update := func(cfg *v1.ConfigFile) </span><span class="cov0" title="0">{
                        labels := map[string]string{
                                containertools.ConfigsLocationLabel: "/configs",
                        }
                        cfg.Config.Labels = labels
                        // Although it was prefered to keep the entrypoint and command as it was
                        // we couldnt reuse /tmp/cache as the cache directory (OCPBUGS-17546)
                        if withCacheRegeneration </span><span class="cov0" title="0">{
                                cfg.Config.Cmd = []string{"serve", "/configs", "--cache-dir=/cache"}
                        }</span> else<span class="cov0" title="0"> { // this means that no cache was found in the original catalog (old catalog with opm &lt; 1.25)
                                cfg.Config.Cmd = []string{"serve", "/configs"}
                        }</span>
                }
                <span class="cov0" title="0">if err := imgBuilder.Run(ctx, refExact, layoutPath, update, layers...); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error building catalog layers: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// extractOPMAndCache is usually called after rendering catalog's declarative config.
// it uses crane modules to pull the catalog image, select the manifest that corresponds to the
// current platform architecture. It then extracts from that image any files that are suffixed `*opm` for later
// use upon rebuilding the catalog: This is because the opm binary can be called `opm` but also
// `darwin-amd64-opm` etc.
func extractOPMAndCache(ctx context.Context, srcRef image.TypedImageReference, ctlgSrcDir string, insecure bool) error <span class="cov0" title="0">{
        var img v1.Image
        var err error
        refExact := srcRef.Ref.Exact()
        if srcRef.OCIFBCPath == "" </span><span class="cov0" title="0">{
                remoteOpts := getCraneOpts(ctx, insecure)
                img, err = crane.Pull(refExact, remoteOpts...)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to pull image from %s: %v", refExact, err)
                }</span>
        } else<span class="cov0" title="0"> {
                img, err = getPlatformImageFromOCIIndex(v1alpha2.TrimProtocol(srcRef.OCIFBCPath), runtime.GOARCH, runtime.GOOS)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // if we get here and no image was found bail out
        <span class="cov0" title="0">if img == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to obtain image for %v", srcRef)
        }</span>
        <span class="cov0" title="0">cachePath, err := getCachePath(img)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, NoCacheArgsError) </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        <span class="cov0" title="0">cacheLocationFileName := filepath.Join(ctlgSrcDir, config.OPMCacheLocationPlaceholder)

        baseDir := filepath.Dir(cacheLocationFileName)
        err = os.MkdirAll(baseDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cfl, err := os.Create(cacheLocationFileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer cfl.Close()

        _, err = cfl.Write([]byte(cachePath))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // cachePath exists, opm binary will be needed to regenerate it
        <span class="cov0" title="0">opmBinaryFileName, err := copyOPMBinary(img, ctlgSrcDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // check for the extracted opm file (it should exist if we found something)
        <span class="cov0" title="0">_, err = os.Stat(opmBinaryFileName)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return fmt.Errorf("opm binary not found after extracting opm from catalog image %v", srcRef)
        }</span>
        <span class="cov0" title="0">err = os.Chmod(opmBinaryFileName, 0744)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error changing permissions to the extracted opm binary while preparing to run opm to regenerate cache: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getPlatformImageFromOCIIndex takes an oci local image located in `fbcPath` and finds the image that
// corresponds to the current platform and OS within the manifestList or imageIndex
func getPlatformImageFromOCIIndex(fbcPath string, architecture string, os string) (v1.Image, error) <span class="cov0" title="0">{
        var img v1.Image

        // obtain the path to where the OCI image reference resides
        layoutPath := layout.Path(fbcPath)

        // get its index.json and obtain its manifest
        rootIndex, err := layoutPath.ImageIndex()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rootIndexManifest, err := rootIndex.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // attempt to find the first image reference in the layout that corresponds to the platform...
        // for a manifest list only search one level deep.

<span class="cov0" title="0">loop:
        for _, descriptor := range rootIndexManifest.Manifests </span><span class="cov0" title="0">{

                if descriptor.MediaType.IsIndex() </span><span class="cov0" title="0">{
                        // follow the descriptor using its digest to get the referenced index and its manifest
                        childIndex, err := rootIndex.ImageIndex(descriptor.Digest)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">childIndexManifest, err := childIndex.IndexManifest()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // at this point, find and extract the child index that corresponds to this machine's
                        // architecture
                        <span class="cov0" title="0">for _, childDescriptor := range childIndexManifest.Manifests </span><span class="cov0" title="0">{
                                if childDescriptor.MediaType.IsImage() &amp;&amp; childDescriptor.Platform.Architecture == architecture &amp;&amp; childDescriptor.Platform.OS == os </span><span class="cov0" title="0">{
                                        img, err = childIndex.Image(childDescriptor.Digest)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        // no further processing necessary
                                        <span class="cov0" title="0">break loop</span>
                                }
                        }

                } else<span class="cov0" title="0"> if descriptor.MediaType.IsImage() </span><span class="cov0" title="0">{
                        // this is a direct reference to an image, so just store it for later
                        img, err = rootIndex.Image(descriptor.Digest)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // no further processing necessary
                        <span class="cov0" title="0">break loop</span>
                }
        }
        <span class="cov0" title="0">return img, nil</span>
}

// getCachePath reads an image's config, and determines if the container command  had a --cache-dir argument
// and if so, returns the path that corresponds to that argument
func getCachePath(img v1.Image) (string, error) <span class="cov0" title="0">{
        cachePath := ""
        cfgf, err := img.ConfigFile()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to get config file for image %v: %v", img, err)
        }</span>
        <span class="cov0" title="0">cmd := cfgf.Config.Cmd
        hasCacheArg := false
        for i, elmt := range cmd </span><span class="cov0" title="0">{
                if strings.Contains(elmt, "--cache-dir") </span><span class="cov0" title="0">{
                        hasCacheArg = true
                        subElmts := strings.Split(elmt, "=")
                        if len(subElmts) == 1 </span><span class="cov0" title="0">{ // the command might  be `serve --cache-dir /tmp/cache`
                                cachePath = cmd[i+1]
                        }</span> else<span class="cov0" title="0"> if len(subElmts) == 2 </span><span class="cov0" title="0">{ // the command might be `serve --cache-dir=/tmp/cache`
                                cachePath = subElmts[1]
                        }</span> else<span class="cov0" title="0"> {
                                return "", fmt.Errorf("unable to parse command line for image %v: %v", img, err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">if !hasCacheArg </span><span class="cov0" title="0">{
                return "", NoCacheArgsError
        }</span> else<span class="cov0" title="0"> {
                return cachePath, nil
        }</span>
}

func deleteLayer(old string) (v1.Layer, error) <span class="cov0" title="0">{
        deleteMap := map[string][]byte{}
        deleteMap[old] = []byte{}
        return crane.Layer(deleteMap)
}</span>

func copyOPMBinary(img v1.Image, ctlgSrcDir string) (string, error) <span class="cov0" title="0">{
        targetOpm := filepath.Join(ctlgSrcDir, config.OpmBinDir, "opm")
        cfgf, err := img.ConfigFile()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">opmBin := ""
        // Following https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact,
        // identifying the binary that will be run by the catalog:
        entrypoint := cfgf.Config.Entrypoint
        if len(entrypoint) &gt; 0 </span><span class="cov0" title="0">{
                opmBin = strings.TrimPrefix(entrypoint[0], (string)(os.PathSeparator)) // /bin/opm becomes bin/opm in order to prepare for extraction from the image
        }</span> else<span class="cov0" title="0"> {
                cmd := cfgf.Config.Cmd
                if len(cmd) &gt; 0 </span><span class="cov0" title="0">{
                        opmBin = strings.TrimPrefix(cmd[0], (string)(os.PathSeparator))
                }</span>
        }
        <span class="cov0" title="0">if opmBin == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to find the path to opm in the catalog image: both entrypoint and cmd were empty")
        }</span>
        // Extract all catalog contents to a temporary folder
        <span class="cov0" title="0">err = extractCatalog(img, filepath.Join(ctlgSrcDir, config.CtlgExtractionDir), opmBin)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // The extractionDir now contains all the contents of the image, including
        // any symbolic links.
        // check that `opmBin` (as set in the image Entrypoint) can be found in the extractionDir
        <span class="cov0" title="0">opmBinPath := filepath.Join(ctlgSrcDir, config.CtlgExtractionDir, opmBin)
        _, err = os.Stat(opmBinPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // prepare folder for copying the binary for later use
        <span class="cov0" title="0">err = os.MkdirAll(filepath.Join(ctlgSrcDir, config.OpmBinDir), 0755)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // if `opmBin` has any symbolic links they can be evaluated easily
        <span class="cov0" title="0">realOpmBinPath, err := filepath.EvalSymlinks(opmBinPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // copy opm binary from the extractionDir to a separate folder (bin) under catalogSourceDir
        <span class="cov0" title="0">err = os.Rename(realOpmBinPath, targetOpm)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // in order to avoid using too much space (case where several operator catalogs are included in the imagesetconfig)
        // we clean up the extracted catalog right after having copied the opmBinary to its target location
        <span class="cov0" title="0">err = os.RemoveAll(filepath.Join(ctlgSrcDir, config.CtlgExtractionDir))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return targetOpm, nil</span>
}

// `extractCatalog` function extracts the `img` contents into `destFolder`.
// All layers of the image are flattened.
// All contents (files, folders and symLinks are extracted)
// Errors related to creation of symbolic links are not considered as blockers
// unless they relate to the `opmBin` path.
func extractCatalog(img v1.Image, destFolder string, opmBin string) error <span class="cov0" title="0">{
        // `symLinks` is a map of symbolic link (key) to the file it points to (value)
        symLinks := make(map[string]string)
        tr := tar.NewReader(mutate.Extract(img))
        err := os.MkdirAll(destFolder, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                header, err := tr.Next()

                // break the infinite loop when EOF
                if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if header == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // descriptor points to the file being read
                <span class="cov0" title="0">descriptor := filepath.Join(destFolder, header.Name)

                // check the file type
                // if its a dir and it doesn't exist create it
                if header.Typeflag == tar.TypeDir </span><span class="cov0" title="0">{
                        if _, err := os.Stat(descriptor); err != nil </span><span class="cov0" title="0">{
                                if err := os.MkdirAll(descriptor, 0755); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> if header.Typeflag == tar.TypeReg </span><span class="cov0" title="0">{
                        // if it's a file create it, making sure it's at least writable and executable by the user - should only be needed for debug cases
                        f, err := os.OpenFile(descriptor, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode)|0755)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // copy over contents
                        <span class="cov0" title="0">if _, err := io.Copy(f, tr); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // manually close here after each file operation; defering would cause each file close
                        // to wait until all operations have completed.
                        <span class="cov0" title="0">f.Close()</span>
                } else<span class="cov0" title="0"> if header.Typeflag == tar.TypeSymlink </span><span class="cov0" title="0">{
                        // A symLink cannot be created inside the loop:
                        // the file/folder it points to (header.Linkname), or any folder on the path
                        // to that file/folder might not have been untarred yet.
                        // Storing the symbolic link to the map in order to create it later.
                        // Examples:
                        // descriptor=".../oc-mirror-workspace/src/catalogs/.../extracted/usr/bin/darwin-amd64-opm";                 ".../oc-mirror-workspace/src/catalogs/.../extracted/bin/registry/darwin-amd64-opm"
                        // descriptor=".../oc-mirror-workspace/src/catalogs/.../extracted/usr/bin/opm";                                         ".../oc-mirror-workspace/src/catalogs/.../extracted/bin/registry/opm"
                        // descriptor=".../oc-mirror-workspace/src/catalogs/.../extracted/etc/alternatives/easy_install-3"; ".../oc-mirror-workspace/src/catalogs/.../extracted/usr/bin/easy_install-3.6"
                        // descriptor=".../oc-mirror-workspace/src/catalogs/.../extracted/usr/bin/easy_install-3.6";                 ".../oc-mirror-workspace/src/catalogs/.../extracted/hostname"
                        symLinks[descriptor] = filepath.Join(destFolder, header.Linkname)
                }</span>

        }

        // symLinks map now contains all symbolic links from the image, all layers included.
        // The following loop will attempt to create each of these symbolic links.
        // Some attempts will fail.
        // Example : `hostname` is the target of several symbolic links in this map.
        // Creating symlinks pointing to `hostname` have been known to fail sometimes
        // because this file is not owned by the user and is read only.
        // Most of such problems have been solved by forcing the filemode to 0755 for all files untarred
        // (see previous loop).
        // For those attempts that failed, most will not be of any incidence to extracting the opm binary.
        // That is why we ignore these errors unless they correspond to a map entry relating to opmBin's path.
        // This technique is not flowless, but it reduces substancially breaking for symbolic links like `hostname`
        // that should not have any incidence on the extraction of the opm binary from the image.
        <span class="cov0" title="0">opmBinPathComponents := strings.Split(opmBin, string(filepath.Separator))
        for link, target := range symLinks </span><span class="cov0" title="0">{
                targetAbsPath, err := filepath.Abs(target)
                if err != nil </span><span class="cov0" title="0">{ // this is an overkill, and should not happen
                        for _, pathComp := range opmBinPathComponents </span><span class="cov0" title="0">{
                                if strings.Contains(target, pathComp) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">linkAbsPath, err := filepath.Abs(link)
                if err != nil </span><span class="cov0" title="0">{ // this is an overkill, and should not happen
                        for _, pathComp := range opmBinPathComponents </span><span class="cov0" title="0">{
                                if strings.Contains(link, pathComp) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">err = os.Symlink(targetAbsPath, linkAbsPath)
                if err != nil </span><span class="cov0" title="0">{ // For `opmBin` = `/bin/opm`,
                        // only return the error if the symlink contains `/bin` or `/opm`
                        for _, pathComp := range opmBinPathComponents </span><span class="cov0" title="0">{
                                if strings.Contains(link, pathComp) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "path"
        "path/filepath"
        "time"

        v1 "github.com/google/go-containerregistry/pkg/v1"
        archiver "github.com/mholt/archiver/v3"
        "github.com/openshift/library-go/pkg/image/reference"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        "github.com/operator-framework/operator-registry/pkg/image/containerdregistry"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/image/builder"
)

// This is a temporary solution until this data is distributed as container images
// https://github.com/openshift/enhancements/pull/310

const (
        // Base image to use when build graph image
        graphBaseImage = "registry.access.redhat.com/ubi8/ubi-micro:latest"
        // URL where graph archive is stored
        graphURL           = "https://api.openshift.com/api/upgrades_info/graph-data"
        outputFile         = "cincinnati-graph-data.tar.gz"
        graphDataDir       = "/var/lib/cincinnati-graph-data/"
        graphDataMountPath = "/var/lib/cincinnati/graph-data"
        getDataTimeout     = time.Minute * 60
)

// unpackRelease will unpack Cincinnati graph data if it exists in the archive
func (o *MirrorOptions) unpackRelease(dstDir string, filesInArchive map[string]string) (bool, error) <span class="cov0" title="0">{
        var found bool
        if err := unpack(config.GraphDataDir, dstDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                nferr := &amp;ErrArchiveFileNotFound{}
                if errors.As(err, &amp;nferr) || errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        klog.V(1).Info("No  graph data found in archive, skipping graph image build")
                        return found, nil
                }</span>
                <span class="cov0" title="0">return found, err</span>
        }
        <span class="cov0" title="0">found = true
        return found, nil</span>
}

// buildGraphImage builds and publishes an image containing the unpacked Cincinnati graph data
func (o *MirrorOptions) buildGraphImage(ctx context.Context, dstDir string) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        refs := image.TypedImageMapping{}

        var destInsecure bool
        if o.DestPlainHTTP || o.DestSkipTLS </span><span class="cov0" title="0">{
                destInsecure = true
        }</span>

        <span class="cov0" title="0">nameOpts := getNameOpts(destInsecure)
        remoteOpts := getRemoteOpts(ctx, destInsecure)
        var err error
        mirrorRef := imagesource.TypedImageReference{Type: imagesource.DestinationRegistry}
        mirrorRef.Ref, err = reference.Parse(o.ToMirror)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The UBI image has been pulled and is expected to be available
        // as a base for the graph image
        <span class="cov0" title="0">ubiImage, err := imagesource.ParseReference(graphBaseImage)
        if err != nil </span><span class="cov0" title="0">{
                return refs, fmt.Errorf("error parsing image %q: %v", graphBaseImage, err)
        }</span>

        <span class="cov0" title="0">ubiImage.Ref.Registry = mirrorRef.Ref.Registry
        ubiImage.Ref.Namespace = path.Join(o.UserNamespace, ubiImage.Ref.Namespace)

        graphImage := ubiImage
        graphImage.Ref.Namespace = path.Join(o.UserNamespace, "openshift")
        graphImage.Ref.Name = "graph-image"

        imgBuilder := builder.NewImageBuilder(nameOpts, remoteOpts)
        layoutDir := filepath.Join(dstDir, "layout")

        // unpack graph data archive and build image
        graphToFile := filepath.Join(dstDir, config.GraphDataDir, outputFile)
        graphDataFolder := filepath.Join(dstDir, config.GraphDataDir, "/graph-data")

        err = archiver.Unarchive(graphToFile, graphDataFolder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract tarball %v", err)
        }</span>

        <span class="cov0" title="0">add, err := builder.LayerFromPath(graphDataDir, graphDataFolder)
        if err != nil </span><span class="cov0" title="0">{
                return refs, fmt.Errorf("error creating add layer: %v", err)
        }</span>

        <span class="cov0" title="0">cpCmd := fmt.Sprintf("cp -rp %s/* %s", graphDataDir, graphDataMountPath)

        update := func(cfg *v1.ConfigFile) </span><span class="cov0" title="0">{
                cfg.Config.Cmd = []string{"/bin/bash", "-c", cpCmd}
                cfg.Author = "oc-mirror"
        }</span>
        <span class="cov0" title="0">layoutPath, err := imgBuilder.CreateLayout(ubiImage.Ref.Exact(), layoutDir)
        if err != nil </span><span class="cov0" title="0">{
                return refs, fmt.Errorf("error creating OCI layout: %v", err)
        }</span>
        <span class="cov0" title="0">if err := imgBuilder.Run(ctx, graphImage.Ref.Exact(), layoutPath, update, add); err != nil </span><span class="cov0" title="0">{
                return refs, nil
        }</span>

        <span class="cov0" title="0">graphImgCvt := image.TypedImageReference{
                Ref:  graphImage.Ref,
                Type: graphImage.Type,
        }
        // Add to mapping for UpdateService manifest generation
        refs.Add(graphImgCvt, graphImgCvt, v1alpha2.TypeCincinnatiGraph)

        resolver, err := containerdregistry.NewResolver("", o.DestSkipTLS, o.DestPlainHTTP, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating image resolver: %v", err)
        }</span>

        // Resolve the image's digest for UpdateService manifest creation
        <span class="cov0" title="0">for source, dest := range refs </span><span class="cov0" title="0">{
                _, desc, err := resolver.Resolve(ctx, dest.Ref.Exact())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error retrieving digest for graph image %q: %v", dest.Ref.Exact(), err)
                }</span>
                <span class="cov0" title="0">dest.Ref.ID = desc.Digest.String()
                refs[source] = dest</span>
        }

        <span class="cov0" title="0">return refs, nil</span>
}

// downloadsGraphData will download the current Cincinnati graph data
func downloadGraphData(ctx context.Context, dir string) error <span class="cov0" title="0">{
        // TODO(jpower432): It would be helpful to validate
        // the source of this downloaded file before processing
        // it further
        graphArchive := filepath.Join(dir, outputFile)
        out, err := os.Create(filepath.Clean(graphArchive))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        req, err := http.NewRequest("GET", graphURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := http.Client{}
        tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        client.Transport = transport
        timeoutCtx, cancel := context.WithTimeout(ctx, getDataTimeout)
        defer cancel()

        resp, err := client.Do(req.WithContext(timeoutCtx))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected HTTP status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(out, resp.Body)
        return err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "time"

        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/layout"
        "github.com/google/uuid"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
)

// Create will plan a mirroring operation based on provided configuration
func (o *MirrorOptions) Create(ctx context.Context, cfg v1alpha2.ImageSetConfiguration) (v1alpha2.Metadata, image.TypedImageMapping, error) <span class="cov8" title="1">{
        // Determine stateless or stateful mode.
        // Empty storage configuration will trigger a metadata cleanup
        // action and labels metadata as single use
        path := filepath.Join(o.Dir, config.SourceDir)
        meta := v1alpha2.NewMetadata()
        var backend storage.Backend
        var err error
        if !cfg.StorageConfig.IsSet() </span><span class="cov8" title="1">{
                meta.SingleUse = true
                klog.Warningf("backend is not configured in %s, using stateless mode", o.ConfigPath)
                cfg.StorageConfig.Local = &amp;v1alpha2.LocalConfig{Path: path}
                backend, err = storage.ByConfig(path, cfg.StorageConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return meta, image.TypedImageMapping{}, fmt.Errorf("error opening backend: %v", err)
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                        if err := backend.Cleanup(ctx, config.MetadataBasePath); err != nil </span><span class="cov0" title="0">{
                                klog.Error(err)
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                meta.SingleUse = false
                backend, err = storage.ByConfig(path, cfg.StorageConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return meta, image.TypedImageMapping{}, fmt.Errorf("error opening backend: %v", err)
                }</span>
        }
        <span class="cov8" title="1">thisRun := v1alpha2.PastMirror{
                Timestamp: int(time.Now().Unix()),
        }
        // Run full or diff mirror.
        merr := backend.ReadMetadata(ctx, &amp;meta, config.MetadataBasePath)
        if merr != nil &amp;&amp; !errors.Is(merr, storage.ErrMetadataNotExist) </span><span class="cov0" title="0">{
                return meta, image.TypedImageMapping{}, merr
        }</span>
        // New metadata files get a full mirror, with complete/heads-only catalogs, release images,
        // and a new UUID. Otherwise, use data from the last mirror to mirror just the layer diff.
        <span class="cov8" title="1">switch </span>{
        case merr != nil:<span class="cov8" title="1">
                klog.Info("No metadata detected, creating new workspace")
                meta.Uid = uuid.New()
                thisRun.Sequence = 1
                thisRun.Mirror = cfg.Mirror
                f := func(ctx context.Context, cfg v1alpha2.ImageSetConfiguration) (image.TypedImageMapping, error) </span><span class="cov8" title="1">{
                        if len(cfg.Mirror.Operators) != 0 </span><span class="cov0" title="0">{
                                operator := NewOperatorOptions(o)
                                operator.SkipImagePin = o.SkipImagePin
                                return operator.PlanFull(ctx, cfg)
                        }</span>
                        <span class="cov8" title="1">return image.TypedImageMapping{}, nil</span>
                }
                <span class="cov8" title="1">mmapping, err := o.run(ctx, &amp;cfg, meta, f)
                meta.PastMirror = thisRun
                return meta, mmapping, err</span>
        default:<span class="cov0" title="0">
                lastRun := meta.PastMirror
                thisRun.Sequence = lastRun.Sequence + 1
                thisRun.Mirror = cfg.Mirror
                f := func(ctx context.Context, cfg v1alpha2.ImageSetConfiguration) (image.TypedImageMapping, error) </span><span class="cov0" title="0">{
                        if len(cfg.Mirror.Operators) != 0 </span><span class="cov0" title="0">{
                                operator := NewOperatorOptions(o)
                                operator.SkipImagePin = o.SkipImagePin
                                return operator.PlanDiff(ctx, cfg, lastRun)
                        }</span>
                        <span class="cov0" title="0">return image.TypedImageMapping{}, nil</span>
                }
                <span class="cov0" title="0">mmapping, err := o.run(ctx, &amp;cfg, meta, f)
                meta.PastMirror = thisRun
                return meta, mmapping, err</span>
        }
}

/*
operatorFunc is a function signature for operator planning operations

# Arguments

• ctx: A cancellation context

• cfg: An ImageSetConfiguration that should be processed

# Returns

• image.TypedImageMapping: Any src-&gt;dest mappings found during planning. Will be nil if an error occurs, non-nil otherwise.

• error: non-nil if an error occurs, nil otherwise
*/
type operatorFunc func(
        ctx context.Context,
        cfg v1alpha2.ImageSetConfiguration,
) (image.TypedImageMapping, error)

func (o *MirrorOptions) run(
        ctx context.Context,
        cfg *v1alpha2.ImageSetConfiguration,
        meta v1alpha2.Metadata,
        operatorPlan operatorFunc,
) (image.TypedImageMapping, error) <span class="cov8" title="1">{

        mmappings := image.TypedImageMapping{}

        if len(cfg.Mirror.Platform.Channels) != 0 </span><span class="cov0" title="0">{
                release := NewReleaseOptions(o)
                mappings, err := release.Plan(ctx, meta.PastMirror, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return mmappings, err
                }</span>
                <span class="cov0" title="0">mmappings.Merge(mappings)

                if cfg.Mirror.Platform.Graph </span><span class="cov0" title="0">{
                        klog.Info("Adding graph data")
                        // Always add the graph base image to the metadata if needed,
                        // to ensure it does not get pruned before use.
                        cfg.Mirror.AdditionalImages = append(cfg.Mirror.AdditionalImages, v1alpha2.Image{Name: graphBaseImage})

                        releaseDir := filepath.Join(o.Dir, config.SourceDir, config.GraphDataDir)
                        if err := os.MkdirAll(releaseDir, 0750); err != nil </span><span class="cov0" title="0">{
                                return mmappings, err
                        }</span>
                        <span class="cov0" title="0">if err := downloadGraphData(ctx, releaseDir); err != nil </span><span class="cov0" title="0">{
                                return mmappings, err
                        }</span>
                }
        }

        <span class="cov8" title="1">err := o.createOlmArtifactsForOCI(ctx, *cfg)
        if err != nil </span><span class="cov0" title="0">{
                return mmappings, err
        }</span>

        <span class="cov8" title="1">mappings, err := operatorPlan(ctx, *cfg)
        if err != nil </span><span class="cov0" title="0">{
                return mmappings, err
        }</span>
        <span class="cov8" title="1">mmappings.Merge(mappings)

        if len(cfg.Mirror.AdditionalImages) != 0 </span><span class="cov8" title="1">{
                additional := NewAdditionalOptions(o)
                mappings, err := additional.Plan(ctx, cfg.Mirror.AdditionalImages)
                if err != nil </span><span class="cov0" title="0">{
                        return mmappings, err
                }</span>
                <span class="cov8" title="1">mmappings.Merge(mappings)</span>
        }

        <span class="cov8" title="1">if len(cfg.Mirror.Helm.Local) != 0 || len(cfg.Mirror.Helm.Repositories) != 0 </span><span class="cov0" title="0">{
                helm := NewHelmOptions(o)
                mappings, err := helm.PullCharts(ctx, *cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return mmappings, err
                }</span>
                <span class="cov0" title="0">mmappings.Merge(mappings)</span>
        }

        <span class="cov8" title="1">if len(cfg.Mirror.Samples) != 0 </span><span class="cov0" title="0">{
                klog.Info("sample images full not implemented")
        }</span>

        <span class="cov8" title="1">return mmappings, nil</span>
}

func (o *MirrorOptions) createOlmArtifactsForOCI(ctx context.Context, cfg v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        for _, operator := range cfg.Mirror.Operators </span><span class="cov8" title="1">{
                if !operator.IsFBCOCI() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">ctlg, err := image.ParseReference(operator.Catalog)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // setup where the FBC content will be written to
                <span class="cov8" title="1">catalogContentsDir := filepath.Join(artifactsFolderName, ctlg.Ref.Name)
                // obtain the path to where the OCI image reference resides
                layoutPath := layout.Path(v1alpha2.TrimProtocol(ctlg.OCIFBCPath))

                // get its index.json and obtain its manifest
                rootIndex, err := layoutPath.ImageIndex()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">rootIndexManifest, err := rootIndex.IndexManifest()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // attempt to find the first image reference in the layout...
                // for a manifest list only search one level deep.
                <span class="cov8" title="1">var img v1.Image
        loop:
                for _, descriptor := range rootIndexManifest.Manifests </span><span class="cov8" title="1">{

                        if descriptor.MediaType.IsIndex() </span><span class="cov0" title="0">{
                                // follow the descriptor using its digest to get the referenced index and its manifest
                                childIndex, err := rootIndex.ImageIndex(descriptor.Digest)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">childIndexManifest, err := childIndex.IndexManifest()
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                // at this point, find the first image and store it for later if possible
                                <span class="cov0" title="0">for _, childDescriptor := range childIndexManifest.Manifests </span><span class="cov0" title="0">{
                                        if childDescriptor.MediaType.IsImage() </span><span class="cov0" title="0">{
                                                img, err = childIndex.Image(childDescriptor.Digest)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                // no further processing necessary
                                                <span class="cov0" title="0">break loop</span>
                                        }
                                }

                        } else<span class="cov8" title="1"> if descriptor.MediaType.IsImage() </span><span class="cov8" title="1">{
                                // this is a direct reference to an image, so just store it for later
                                img, err = rootIndex.Image(descriptor.Digest)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                // no further processing necessary
                                <span class="cov8" title="1">break loop</span>
                        }
                }
                // if we get here and no image was found bail out
                <span class="cov8" title="1">if img == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to obtain image for %s", operator.Catalog)
                }</span>
                // fullArtifactPath is set to &lt;current working directory&gt;/olm_artifacts/&lt;repo&gt;/&lt;config folder&gt;
                <span class="cov8" title="1">fullArtifactPath, err := extractDeclarativeConfigFromImage(img, catalogContentsDir)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // store the full artifact path for later so we don't have to recalculate the path.
                <span class="cov8" title="1">o.operatorCatalogToFullArtifactPath[operator.Catalog] = fullArtifactPath</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package describe

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"

        "github.com/spf13/cobra"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"

        "github.com/openshift/oc-mirror/pkg/bundle"
        "github.com/openshift/oc-mirror/pkg/cli"
)

type DescribeOptions struct {
        *cli.RootOptions
        From string
}

func NewDescribeCommand(f kcmdutil.Factory, ro *cli.RootOptions) *cobra.Command <span class="cov0" title="0">{
        o := DescribeOptions{}
        o.RootOptions = ro

        cmd := &amp;cobra.Command{
                Use:   "describe &lt;archive path&gt;",
                Short: "Pretty print the contents of mirror metadata",
                Example: templates.Examples(`
                        # Output the contents of 'mirror_seq1_00000.tar'
                        oc-mirror describe mirror_seq1_00000.tar
                `),
                Args: cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        kcmdutil.CheckErr(o.Complete(args))
                        kcmdutil.CheckErr(o.Validate())
                        kcmdutil.CheckErr(o.Run(cmd.Context()))
                }</span>,
        }

        <span class="cov0" title="0">o.BindFlags(cmd.PersistentFlags())

        return cmd</span>
}

func (o *DescribeOptions) Complete(args []string) error <span class="cov8" title="1">{
        if len(args) == 1 </span><span class="cov8" title="1">{
                o.From = args[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *DescribeOptions) Validate() error <span class="cov8" title="1">{
        if len(o.From) == 0 </span><span class="cov8" title="1">{
                return errors.New("must specify path to imageset archive")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *DescribeOptions) Run(ctx context.Context) error <span class="cov8" title="1">{

        meta, err := bundle.ReadMetadataFromFile(ctx, o.From)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error retrieving metadata from %q: %v", o.From, err)
        }</span>

        // Process metadata for output
        <span class="cov8" title="1">data, err := json.MarshalIndent(&amp;meta, "", " ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Fprintln(o.IOStreams.Out, string(data))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mirror

import (
        "archive/tar"
        "bytes"
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"

        imagecopy "github.com/containers/image/v5/copy"
        "github.com/containers/image/v5/manifest"
        "github.com/containers/image/v5/pkg/cli/environment"
        "github.com/containers/image/v5/pkg/sysregistriesv2"
        "github.com/containers/image/v5/signature"
        "github.com/containers/image/v5/transports/alltransports"
        "github.com/containers/image/v5/types"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/mutate"
        "github.com/opencontainers/go-digest"
        "github.com/operator-framework/operator-registry/alpha/declcfg"
        "github.com/operator-framework/operator-registry/pkg/containertools"
        "k8s.io/klog/v2"
        "sigs.k8s.io/yaml"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
)

const (
        blobsPath           string = "/blobs/sha256/"
        dockerPrefix        string = "docker://"
        configPath          string = "configs/"
        catalogJSON         string = "/catalog.json"
        relatedImages       string = "relatedImages"
        artifactsFolderName string = "olm_artifacts"
        ocpRelease          string = "release"
        ocpReleaseImages    string = "release-images"
        filePrefix          string = "file://"
        sha256Tag           string = "sha256:"
        manifests           string = "manifests"
        openshift           string = "openshift"
        source              string = "src/v2"
)

// RemoteRegFuncs contains the functions to be used for working with remote registries
// In order to be able to mock these external packages,
// we pass them as parameters of bulkImageCopy and bulkImageMirror
type RemoteRegFuncs struct {
        copy               func(ctx context.Context, policyContext *signature.PolicyContext, destRef types.ImageReference, srcRef types.ImageReference, options *imagecopy.Options) (copiedManifest []byte, retErr error)
        mirrorMappings     func(cfg v1alpha2.ImageSetConfiguration, images image.TypedImageMapping, insecure bool) error
        newImageSource     func(ctx context.Context, sys *types.SystemContext, imgRef types.ImageReference) (types.ImageSource, error)
        getManifest        func(ctx context.Context, instanceDigest *digest.Digest, imgSrc types.ImageSource) ([]byte, string, error)
        handleMetadata     func(ctx context.Context, tmpdir string, filesInArchive map[string]string) (backend storage.Backend, incoming, curr v1alpha2.Metadata, err error)
        m2mWorkflowWrapper func(ctx context.Context, cfg v1alpha2.ImageSetConfiguration, cleanup cleanupFunc) error
}

// getISConfig simple function to read and unmarshal the imagesetconfig
// set via the command line
func (o *MirrorOptions) getISConfig() (*v1alpha2.ImageSetConfiguration, error) <span class="cov8" title="1">{
        var isc *v1alpha2.ImageSetConfiguration
        configData, err := os.ReadFile(o.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(configData, &amp;isc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return isc, nil</span>
}

func (o *MirrorOptions) generateSrcToFileMapping(ctx context.Context, relatedImages []declcfg.RelatedImage) (image.TypedImageMapping, error) <span class="cov8" title="1">{
        mapping := image.TypedImageMapping{}
        for _, i := range relatedImages </span><span class="cov8" title="1">{
                if i.Image == "" </span><span class="cov8" title="1">{
                        klog.Warningf("invalid related image %s: reference empty", i.Name)
                        continue</span>
                }
                <span class="cov8" title="1">sysCtx := newSystemContext(o.SourceSkipTLS, o.OCIRegistriesConfig)
                reg, err := sysregistriesv2.FindRegistry(sysCtx, i.Image)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Warningf("Cannot find registry for %s: %v", i.Image, err)
                }</span>
                <span class="cov8" title="1">if reg != nil &amp;&amp; len(reg.Mirrors) &gt; 0 </span><span class="cov8" title="1">{
                        // i.Image is coming from a declarativeConfig (ClusterServiceVersion) it's therefore always a docker ref
                        mirroredImage, err := findFirstAvailableMirror(ctx, sysCtx, reg.Mirrors, dockerPrefix+i.Image, reg.Prefix, o.remoteRegFuncs)
                        if err == nil </span><span class="cov8" title="1">{
                                i.Image = mirroredImage
                        }</span>
                }

                <span class="cov8" title="1">srcTIR, err := image.ParseReference(i.Image)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">srcTI := image.TypedImage{
                        TypedImageReference: srcTIR,
                        Category:            v1alpha2.TypeOperatorRelatedImage,
                }
                // The registry is needed in from, as this will be used to generate ICSP from mapping
                dstPath := filePrefix + srcTIR.Ref.Registry + "/" + srcTIR.Ref.Namespace + "/" + srcTIR.Ref.Name
                if srcTIR.Ref.ID != "" </span><span class="cov8" title="1">{
                        dstPath = dstPath + "/" + strings.TrimPrefix(srcTI.Ref.ID, sha256Tag)
                }</span> else<span class="cov8" title="1"> if srcTIR.Ref.ID == "" &amp;&amp; srcTIR.Ref.Tag != "" </span><span class="cov8" title="1">{
                        //recreating a fake digest to copy image into
                        //this is because dclcfg.LoadFS will create a symlink to this folder
                        //from the tag
                        dstPath = dstPath + "/" + fmt.Sprintf("%x", sha256.Sum256([]byte(srcTIR.Ref.Tag)))[0:6]
                }</span>
                <span class="cov8" title="1">dstTIR, err := image.ParseReference(strings.ToLower(dstPath))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if srcTI.Ref.Tag != "" </span><span class="cov8" title="1">{
                        //put the tag back because it's needed to follow symlinks by LoadFS
                        dstTIR.Ref.Tag = srcTI.Ref.Tag
                }</span>
                <span class="cov8" title="1">dstTI := image.TypedImage{
                        TypedImageReference: dstTIR,
                        Category:            v1alpha2.TypeOperatorRelatedImage,
                }
                mapping[srcTI] = dstTI</span>
        }
        <span class="cov8" title="1">return mapping, nil</span>
}

func (o *MirrorOptions) addRelatedImageToMapping(ctx context.Context, mapping *sync.Map, img declcfg.RelatedImage, targetLocation string) error <span class="cov8" title="1">{
        if img.Image == "" </span><span class="cov8" title="1">{
                klog.Warningf("invalid related image %s: reference empty", img.Name)
                return nil
        }</span>
        <span class="cov8" title="1">sysCtx := newSystemContext(o.SourceSkipTLS, o.OCIRegistriesConfig)
        reg, err := sysregistriesv2.FindRegistry(sysCtx, img.Image)
        if err != nil </span><span class="cov0" title="0">{
                klog.Warningf("Cannot find registry for %s", img.Image)
        }</span>

        <span class="cov8" title="1">from, to := "", ""
        _, subns, imgName, tag, sha := v1alpha2.ParseImageReference(img.Image)
        if imgName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid related image %s: repository name empty", img.Image)
        }</span>

        <span class="cov8" title="1">from = img.Image

        if reg != nil &amp;&amp; len(reg.Mirrors) &gt; 0 </span><span class="cov0" title="0">{
                // i.Image is coming from a declarativeConfig (ClusterServiceVersion) it's therefore always a docker ref
                mirroredImage, err := findFirstAvailableMirror(ctx, sysCtx, reg.Mirrors, dockerPrefix+img.Image, reg.Prefix, o.remoteRegFuncs)
                if err == nil </span><span class="cov0" title="0">{
                        from = mirroredImage
                }</span> else<span class="cov0" title="0"> {
                        // verbose log so we know when we had no mirror hits
                        klog.V(3).Infof("Cannot find mirror for %s: %s", img.Image, err)
                }</span>
        }

        <span class="cov8" title="1">to = targetLocation
        if subns != "" </span><span class="cov8" title="1">{
                to = strings.Join([]string{to, subns}, "/")
        }</span>
        <span class="cov8" title="1">to = strings.Join([]string{to, imgName}, "/")
        if tag != "" </span><span class="cov8" title="1">{
                to = to + ":" + tag
        }</span> else<span class="cov8" title="1"> {
                to = to + "@" + sha256Tag + sha
        }</span>

        // a deccfg.RelatedImage is a reference to a remote image
        // we can parse it directly, without adding a transport prefix
        // as it is assumed to be docker:// by default
        <span class="cov8" title="1">srcTIR, err := image.ParseReference(strings.ToLower(from))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if sha != "" &amp;&amp; srcTIR.Ref.ID == "" </span><span class="cov0" title="0">{
                srcTIR.Ref.ID = sha256Tag + sha
        }</span>
        <span class="cov8" title="1">if tag != "" &amp;&amp; srcTIR.Ref.Tag == "" </span><span class="cov0" title="0">{
                srcTIR.Ref.Tag = tag
        }</span>
        <span class="cov8" title="1">srcTI := image.TypedImage{
                TypedImageReference: srcTIR,
                Category:            v1alpha2.TypeOperatorRelatedImage,
        }

        dstTIR, err := image.ParseReference(to)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if sha != "" &amp;&amp; dstTIR.Ref.ID == "" </span><span class="cov0" title="0">{
                dstTIR.Ref.ID = sha256Tag + sha
        }</span>
        //If there is no tag mirrorMapping is unable to push the image
        //It would push manifests and layers, but image would not appear
        //in registry
        <span class="cov8" title="1">if sha != "" &amp;&amp; dstTIR.Ref.Tag == "" </span><span class="cov8" title="1">{
                dstTIR.Ref.Tag = sha[0:6]
        }</span>
        <span class="cov8" title="1">dstTI := image.TypedImage{
                TypedImageReference: dstTIR,
                Category:            v1alpha2.TypeOperatorRelatedImage,
        }
        mapping.Store(srcTI, dstTI)
        return nil</span>
}

func prepareDestCatalogRef(operator v1alpha2.Operator, destReg, namespace string) (string, error) <span class="cov8" title="1">{
        if destReg == "" </span><span class="cov8" title="1">{
                return "", errors.New("destination registry may not be empty")
        }</span>
        <span class="cov8" title="1">uniqueName, err := operator.GetUniqueName()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">notAReg, subNamespace, repo, tag, _ := v1alpha2.ParseImageReference(uniqueName)

        to := dockerPrefix + destReg

        if namespace != "" </span><span class="cov8" title="1">{
                to = strings.Join([]string{to, namespace}, "/")
        }</span>
        <span class="cov8" title="1">if notAReg != "" </span><span class="cov8" title="1">{
                to = strings.Join([]string{to, notAReg}, "/")
        }</span>
        <span class="cov8" title="1">if subNamespace != "" </span><span class="cov8" title="1">{
                to = strings.Join([]string{to, subNamespace}, "/")
        }</span>

        <span class="cov8" title="1">to = strings.Join([]string{to, repo}, "/")
        if tag != "" </span><span class="cov8" title="1">{
                to += ":" + tag
        }</span>
        //check if this is a valid reference
        <span class="cov8" title="1">_, err = image.ParseReference(v1alpha2.TrimProtocol(to))
        return to, err</span>
}

func addCatalogToMapping(catalogMapping image.TypedImageMapping, srcOperator v1alpha2.Operator, digest digest.Digest, destRef string) error <span class="cov8" title="1">{
        if digest == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no digest provided for OCI catalog %s after copying it to the disconnected registry. This usually indicates an error in the catalog copy", srcOperator.Catalog)
        }</span>
        // need to use GetUniqueName, because JUST for the catalogSource
        // generation, we need the srcOperator reference to be based on
        // targetName and targetTag if they exist
        <span class="cov8" title="1">srcCtlgRef, err := srcOperator.GetUniqueName()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if srcOperator.IsFBCOCI() &amp;&amp; !strings.Contains(srcCtlgRef, v1alpha2.OCITransportPrefix) </span><span class="cov8" title="1">{
                srcCtlgRef = v1alpha2.OCITransportPrefix + "//" + srcCtlgRef
        }</span>

        <span class="cov8" title="1">ctlgSrcTIR, err := image.ParseReference(srcCtlgRef)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ctlgDstTIR, err := image.ParseReference(v1alpha2.TrimProtocol(destRef))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // digest is returned from the result of copy to the disconnected registry, and unless there is
        // an error during copy, this digest will be provided.
        // ctlgSrcTIR.Ref.ID will not be empty for the case of a remote registry, but for oci FBC catalogs,
        // this will always be empty.
        // if both digest and ctlgSrcTIR.Ref.ID are empty, then there is no way of creating a accurate mapping source.
        <span class="cov8" title="1">if digest == "" &amp;&amp; ctlgSrcTIR.Ref.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to add catalog %s to mirror mapping: no digest found", srcOperator.Catalog)
        }</span>
        <span class="cov8" title="1">if digest != "" &amp;&amp; ctlgSrcTIR.Ref.ID == "" </span><span class="cov8" title="1">{
                ctlgSrcTIR.Ref.ID = string(digest)
        }</span>
        <span class="cov8" title="1">if ctlgSrcTIR.Ref.ID != "" &amp;&amp; ctlgDstTIR.Ref.ID == "" </span><span class="cov8" title="1">{
                ctlgDstTIR.Ref.ID = ctlgSrcTIR.Ref.ID
        }</span>
        <span class="cov8" title="1">if ctlgSrcTIR.Ref.Tag != "" &amp;&amp; ctlgDstTIR.Ref.Tag == "" </span><span class="cov0" title="0">{
                ctlgDstTIR.Ref.Tag = ctlgSrcTIR.Ref.Tag
        }</span>

        <span class="cov8" title="1">ctlgSrcTI := image.TypedImage{
                TypedImageReference: ctlgSrcTIR,
                Category:            v1alpha2.TypeOperatorCatalog,
        }

        ctlgDstTI := image.TypedImage{
                TypedImageReference: ctlgDstTIR,
                Category:            v1alpha2.TypeOperatorCatalog,
        }

        if srcOperator.IsFBCOCI() </span><span class="cov8" title="1">{
                ctlgSrcTI.ImageFormat = image.OCIFormat
                ctlgDstTI.ImageFormat = image.OCIFormat
        }</span>

        <span class="cov8" title="1">catalogMapping[ctlgSrcTI] = ctlgDstTI
        return nil</span>
}

/*
extractDeclarativeConfigFromImage obtains a DeclarativeConfig instance from an image

# Arguments

• img: the image to pull a DeclarativeConfig out of

• extractedImageDir: the location where the DeclarativeConfig should be placed upon extraction.
Typically &lt;current working directory&gt;/olm_artifacts/&lt;repo&gt;.

# Returns

• string: path to the folder containing the DeclarativeConfig if no error occurred, otherwise empty string.
The config directory from img is determined and appended to extractedImageDir.
Typically results in &lt;current working directory&gt;/olm_artifacts/&lt;repo&gt;/&lt;config folder&gt;

• error: non-nil if an error occurred, nil otherwise
*/
func extractDeclarativeConfigFromImage(img v1.Image, extractedImageDir string) (string, error) <span class="cov8" title="1">{
        if img == nil </span><span class="cov0" title="0">{
                return "", errors.New("unable to extract DeclarativeConfig because no image was provided")
        }</span>

        <span class="cov8" title="1">config, err := img.ConfigFile()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">configsPrefix := "configs/"
        if config.Config.Labels != nil </span><span class="cov8" title="1">{
                label := config.Config.Labels[containertools.ConfigsLocationLabel]
                if label != "" </span><span class="cov8" title="1">{
                        // strip beginning slash since this would prevent the configsPrefix from matching later on
                        label = strings.TrimPrefix(label, "/")
                        // since configsPrefix is supposed to be a directory, put in the ending slash if its not already present.
                        if !strings.HasSuffix(label, "/") </span><span class="cov8" title="1">{
                                label = label + "/"
                        }</span>
                        <span class="cov8" title="1">configsPrefix = label</span>
                }
        }
        <span class="cov8" title="1">returnPath := filepath.Join(extractedImageDir, configsPrefix)

        tr := tar.NewReader(mutate.Extract(img))
        for </span><span class="cov8" title="1">{
                header, err := tr.Next()

                // break the infinite loop when EOF
                if errors.Is(err, io.EOF) </span><span class="cov8" title="1">{
                        break</span>
                }

                // skip the file if it is a directory or not in the configs dir
                <span class="cov8" title="1">if !strings.HasPrefix(header.Name, configsPrefix) || header.FileInfo().IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var buf bytes.Buffer
                _, err = buf.ReadFrom(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">targetFileName := filepath.Join(extractedImageDir, header.Name)
                bytes := buf.Bytes()

                baseDir := filepath.Dir(targetFileName)
                err = os.MkdirAll(baseDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">f, err := os.Create(targetFileName)
                if err == nil </span><span class="cov8" title="1">{
                        defer f.Close()
                }</span> else<span class="cov0" title="0"> {
                        return "", err
                }</span>

                <span class="cov8" title="1">_, err = f.Write(bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        // check for the folder (it should exist if we found something)
        <span class="cov8" title="1">_, err = os.Stat(returnPath)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("directory not found after extracting %q within image", configsPrefix)
        }</span>
        // folder itself should contain data
        <span class="cov8" title="1">dirs, err := os.ReadDir(returnPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(dirs) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no content found at %q within image", configsPrefix)
        }</span>
        <span class="cov8" title="1">return returnPath, nil</span>
}

// getRelatedImages reads a directory containing an FBC catalog () unpacked contents
// and returns the list of relatedImages found in the CSVs of bundles
// filtering by the list of packages provided in imageSetConfig for the catalog
func getRelatedImages(cfg declcfg.DeclarativeConfig) ([]declcfg.RelatedImage, error) <span class="cov8" title="1">{
        allImages := []declcfg.RelatedImage{}

        for _, bundle := range cfg.Bundles </span><span class="cov8" title="1">{
                allImages = append(allImages, declcfg.RelatedImage{Name: bundle.Package, Image: bundle.Image})
                allImages = append(allImages, bundle.RelatedImages...)
        }</span>
        //make sure there are no duplicates in the list with same image:
        <span class="cov8" title="1">finalList := []declcfg.RelatedImage{}
        for _, i := range allImages </span><span class="cov8" title="1">{
                found := false
                for _, j := range finalList </span><span class="cov8" title="1">{
                        if i.Image == j.Image </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        finalList = append(finalList, i)
                }</span>
        }
        <span class="cov8" title="1">return finalList, nil</span>
}

func findFirstAvailableMirror(ctx context.Context, sysCtx *types.SystemContext, mirrors []sysregistriesv2.Endpoint, imageName string, prefix string, regFuncs RemoteRegFuncs) (string, error) <span class="cov8" title="1">{
        finalError := fmt.Errorf("could not find a valid mirror for %s", imageName)
        if !strings.HasSuffix(prefix, "/") </span><span class="cov8" title="1">{
                prefix += "/"
        }</span>
        <span class="cov8" title="1">for _, mirror := range mirrors </span><span class="cov8" title="1">{
                if !strings.HasSuffix(mirror.Location, "/") </span><span class="cov8" title="1">{
                        mirror.Location += "/"
                }</span>
                <span class="cov8" title="1">mirroredImage := strings.Replace(imageName, prefix, mirror.Location, 1)
                imgRef, err := alltransports.ParseImageName(mirroredImage)
                if err != nil </span><span class="cov8" title="1">{
                        finalError = fmt.Errorf("%w: unable to parse reference %s: %v", finalError, mirroredImage, err)
                        continue</span>
                }
                <span class="cov8" title="1">imgsrc, err := regFuncs.newImageSource(ctx, sysCtx, imgRef)
                defer func() </span><span class="cov8" title="1">{
                        if imgsrc != nil &amp;&amp; err == nil </span><span class="cov8" title="1">{
                                err = imgsrc.Close()
                                if err != nil </span><span class="cov0" title="0">{
                                        klog.V(3).Infof("%s is not closed", imgsrc)
                                }</span>
                        }
                }()
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        finalError = fmt.Errorf("%w: unable to create ImageSource for %s: %v", finalError, mirroredImage, err)
                        continue</span>
                }
                <span class="cov8" title="1">_, _, err = regFuncs.getManifest(ctx, nil, imgsrc)
                if err != nil </span><span class="cov8" title="1">{
                        finalError = fmt.Errorf("%w: unable to get Manifest for %s: %v", finalError, mirroredImage, err)
                        continue</span>
                } else<span class="cov8" title="1"> {
                        return v1alpha2.TrimProtocol(mirroredImage), nil
                }</span>
        }
        <span class="cov8" title="1">return "", finalError</span>
}

// copyImage is used both for pulling catalog images from the remote registry
// as well as pushing these catalog images to the remote registry.
// It calls the underlying containers/image copy library, which looks out for registries.conf
// file if any, when copying images around.
func (o *MirrorOptions) copyImage(ctx context.Context, from, to string, funcs RemoteRegFuncs) (digest.Digest, error) <span class="cov8" title="1">{
        if !strings.HasPrefix(from, "docker") </span><span class="cov8" title="1">{
                // find absolute path if from is a relative path
                fromPath := v1alpha2.TrimProtocol(from)
                if !strings.HasPrefix(fromPath, "/") </span><span class="cov8" title="1">{
                        absolutePath, err := filepath.Abs(fromPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return digest.Digest(""), fmt.Errorf("unable to get absolute path of oci image %s: %v", from, err)
                        }</span>
                        <span class="cov8" title="1">from = "oci://" + absolutePath</span>
                }
        }

        <span class="cov8" title="1">sourceCtx := newSystemContext(o.SourceSkipTLS, o.OCIRegistriesConfig)
        destinationCtx := newSystemContext(o.DestSkipTLS, "")

        // Pull the source image, and store it in the local storage, under the name main
        var sigPolicy *signature.Policy
        var err error
        if o.OCIInsecureSignaturePolicy </span><span class="cov8" title="1">{
                sigPolicy = &amp;signature.Policy{Default: []signature.PolicyRequirement{signature.NewPRInsecureAcceptAnything()}}
        }</span> else<span class="cov0" title="0"> {
                sigPolicy, err = signature.DefaultPolicy(nil)
                if err != nil </span><span class="cov0" title="0">{
                        return digest.Digest(""), err
                }</span>
        }
        <span class="cov8" title="1">policyContext, err := signature.NewPolicyContext(sigPolicy)
        if err != nil </span><span class="cov0" title="0">{
                return digest.Digest(""), err
        }</span>
        // define the source context
        <span class="cov8" title="1">srcRef, err := alltransports.ParseImageName(from)
        if err != nil </span><span class="cov0" title="0">{
                return digest.Digest(""), err
        }</span>
        // define the destination context
        <span class="cov8" title="1">destRef, err := alltransports.ParseImageName(to)
        if err != nil </span><span class="cov0" title="0">{
                return digest.Digest(""), err
        }</span>

        // call the copy.Image function with the set options
        <span class="cov8" title="1">manifestBytes, err := funcs.copy(ctx, policyContext, destRef, srcRef, &amp;imagecopy.Options{
                RemoveSignatures:      true,
                SignBy:                "",
                ReportWriter:          os.Stdout,
                SourceCtx:             sourceCtx,
                DestinationCtx:        destinationCtx,
                ForceManifestMIMEType: "",
                ImageListSelection:    imagecopy.CopySystemImage,
                OciDecryptConfig:      nil,
                OciEncryptLayers:      nil,
                OciEncryptConfig:      nil,
        })
        if err != nil </span><span class="cov0" title="0">{
                return digest.Digest(""), err
        }</span>
        <span class="cov8" title="1">return manifest.Digest(manifestBytes)</span>
}

// newSystemContext set the context for source &amp; destination resources
func newSystemContext(skipTLS bool, registriesConfigPath string) *types.SystemContext <span class="cov8" title="1">{
        skipTLSVerify := types.OptionalBoolFalse
        if skipTLS </span><span class="cov8" title="1">{
                skipTLSVerify = types.OptionalBoolTrue
        }</span>
        <span class="cov8" title="1">ctx := &amp;types.SystemContext{
                RegistriesDirPath:           "",
                ArchitectureChoice:          "",
                OSChoice:                    "",
                VariantChoice:               "",
                BigFilesTemporaryDir:        "", //*globalArgs.cache + "/tmp",
                DockerInsecureSkipTLSVerify: skipTLSVerify,
        }
        if registriesConfigPath != "" </span><span class="cov8" title="1">{
                ctx.SystemRegistriesConfPath = registriesConfigPath
        }</span> else<span class="cov8" title="1"> {
                err := environment.UpdateRegistriesConf(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // log and ignore
                        klog.Warningf("unable to load registries.conf from environment variables: %v", err)

                }</span>
        }
        <span class="cov8" title="1">return ctx</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package mirror

import (
        "bytes"
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        helmchart "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/chartutil"
        helmcli "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/downloader"
        "helm.sh/helm/v3/pkg/engine"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/releaseutil"
        helmrepo "helm.sh/helm/v3/pkg/repo"
        "k8s.io/client-go/util/homedir"
        "k8s.io/client-go/util/jsonpath"
        "k8s.io/klog/v2"
        "sigs.k8s.io/yaml"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
)

type HelmOptions struct {
        *MirrorOptions
        settings *helmcli.EnvSettings
        insecure bool
}

func NewHelmOptions(mo *MirrorOptions) *HelmOptions <span class="cov0" title="0">{
        settings := helmcli.New()
        opts := &amp;HelmOptions{
                MirrorOptions: mo,
                settings:      settings,
        }
        if mo.SourcePlainHTTP || mo.SourceSkipTLS </span><span class="cov0" title="0">{
                opts.insecure = true
        }</span>
        <span class="cov0" title="0">return opts</span>

}

func (h *HelmOptions) PullCharts(ctx context.Context, cfg v1alpha2.ImageSetConfiguration) (image.TypedImageMapping, error) <span class="cov0" title="0">{

        var images []v1alpha2.Image

        // Create a temp file for to hold repo information
        cleanup, file, err := mktempFile(h.Dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">h.settings.RepositoryConfig = file
        defer cleanup()

        // Using VerifyLater options to ensure
        // any verification information is downloaded
        // and can be used later.
        c := downloader.ChartDownloader{
                Out:     h.Out,
                Keyring: defaultKeyring(),
                Verify:  downloader.VerifyLater,
                Getters: getter.All(h.settings),
                Options: []getter.Option{
                        getter.WithInsecureSkipVerifyTLS(h.insecure),
                },
                RepositoryConfig: h.settings.RepositoryConfig,
                RepositoryCache:  h.settings.RepositoryCache,
        }

        for _, chart := range cfg.Mirror.Helm.Local </span><span class="cov0" title="0">{

                // find images associations with chart (default values)
                img, err := findImages(chart.Path, chart.ImagePaths...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">images = append(images, img...)</span>
        }

        <span class="cov0" title="0">for _, repo := range cfg.Mirror.Helm.Repositories </span><span class="cov0" title="0">{

                if err := h.repoAdd(repo); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, chart := range repo.Charts </span><span class="cov0" title="0">{
                        klog.Infof("Pulling chart %s", chart.Name)
                        ref := fmt.Sprintf("%s/%s", repo.Name, chart.Name)
                        dest := filepath.Join(h.Dir, config.SourceDir, config.HelmDir)
                        path, _, err := c.DownloadTo(ref, chart.Version, dest)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error pulling chart %q: %v", ref, err)
                        }</span>

                        // find images associations with chart (default values)
                        <span class="cov0" title="0">img, err := findImages(path, chart.ImagePaths...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">images = append(images, img...)</span>
                }
        }

        // Image download planning
        <span class="cov0" title="0">additional := NewAdditionalOptions(h.MirrorOptions)
        return additional.Plan(ctx, images)</span>
}

// FindImages will download images found in a Helm chart on disk
func findImages(path string, imagePaths ...string) (images []v1alpha2.Image, err error) <span class="cov8" title="1">{

        klog.V(2).Infof("Reading from path %s", path)

        // Get all json paths where images
        // are located
        p := getImagesPath(imagePaths...)

        chart, err := loader.Load(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">manifest, err := render(chart)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Process each YAML document seperately
        <span class="cov8" title="1">for _, single := range bytes.Split([]byte(manifest), []byte("\n---\n")) </span><span class="cov8" title="1">{

                imgs, err := search(single, p...)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">images = append(images, imgs...)</span>
        }

        <span class="cov8" title="1">return images, nil</span>
}

// getImagesPath returns known jsonpaths and user defined
// json paths where images are found
func getImagesPath(paths ...string) []string <span class="cov8" title="1">{
        pathlist := []string{
                "{.spec.template.spec.initContainers[*].image}",
                "{.spec.template.spec.containers[*].image}",
                "{.spec.initContainers[*].image}",
                "{.spec.containers[*].image}",
        }
        return append(pathlist, paths...)
}</span>

// render will return a templated chart based on default
// values from the chart data and helm chartutils.
func render(ch *helmchart.Chart) (string, error) <span class="cov8" title="1">{
        out := new(bytes.Buffer)
        valueOpts := make(map[string]interface{})
        caps := chartutil.DefaultCapabilities

        // Using placeholders for the name
        // and namespace since we are only rendering
        // to obtain image information
        relOps := chartutil.ReleaseOptions{
                Name:      "NAME",
                Namespace: "RELEASE-NAMESPACE",
        }
        valuesToRender, err := chartutil.ToRenderValues(ch, valueOpts, relOps, caps)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error rendering values: %v", err)
        }</span>

        <span class="cov8" title="1">files, err := engine.Render(ch, valuesToRender)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error rendering chart %s: %v", ch.Name(), err)
        }</span>

        // Skip the NOTES.txt files
        <span class="cov8" title="1">for k := range files </span><span class="cov8" title="1">{
                if strings.HasSuffix(k, ".txt") </span><span class="cov8" title="1">{
                        delete(files, k)
                }</span>
        }

        <span class="cov8" title="1">for _, crd := range ch.CRDObjects() </span><span class="cov0" title="0">{
                fmt.Fprintf(out, "---\n# Source: %s\n%s\n", crd.Name, string(crd.File.Data[:]))
        }</span>

        <span class="cov8" title="1">_, manifests, err := releaseutil.SortManifests(files, caps.APIVersions, releaseutil.InstallOrder)
        if err != nil </span><span class="cov0" title="0">{
                // We return the files as a big blob of data to help the user debug parser
                // errors.
                for name, content := range files </span><span class="cov0" title="0">{
                        if strings.TrimSpace(content) == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">fmt.Fprintf(out, "---\n# Source: %s\n%s\n", name, content)</span>
                }
                <span class="cov0" title="0">return out.String(), err</span>
        }
        <span class="cov8" title="1">for _, m := range manifests </span><span class="cov8" title="1">{
                fmt.Fprintf(out, "---\n# Source: %s\n%s\n", m.Name, m.Content)
        }</span>
        <span class="cov8" title="1">return out.String(), nil</span>
}

// repoAdd adds a Helm repo with given name and url
func (h *HelmOptions) repoAdd(chartRepo v1alpha2.Repository) error <span class="cov0" title="0">{

        entry := helmrepo.Entry{
                Name: chartRepo.Name,
                URL:  chartRepo.URL,
        }

        b, err := os.ReadFile(h.settings.RepositoryConfig)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var helmFile helmrepo.File
        if err := yaml.Unmarshal(b, &amp;helmFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check for existing repo name
        <span class="cov0" title="0">if helmFile.Has(chartRepo.Name) </span><span class="cov0" title="0">{
                klog.Infof("repository name (%s) already exists", chartRepo.Name)
                return nil
        }</span>

        // Check that the provided repo info is valid
        <span class="cov0" title="0">r, err := helmrepo.NewChartRepository(&amp;entry, getter.All(h.settings))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := r.DownloadIndexFile(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid chart repository %q: %v", chartRepo.URL, err)
        }</span>

        // Update temp file with chart entry
        <span class="cov0" title="0">helmFile.Update(&amp;entry)

        if err := helmFile.WriteFile(h.settings.RepositoryConfig, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing helm repo file: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// parseJSONPath will parse data and filter for a provided jsonpath template
func parseJSONPath(input interface{}, parser *jsonpath.JSONPath, template string) ([]string, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        if err := parser.Parse(template); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parser.Execute(buf, input); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">f := func(s rune) bool </span><span class="cov8" title="1">{ return s == ' ' }</span>
        <span class="cov8" title="1">r := strings.FieldsFunc(buf.String(), f)
        return r, nil</span>
}

// search will return images from parsed object
func search(yamlData []byte, paths ...string) (images []v1alpha2.Image, err error) <span class="cov8" title="1">{

        var data interface{}
        // yaml.Unmarshal will convert YAMl to JSON first
        if err := yaml.Unmarshal(yamlData, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">j := jsonpath.New("")
        j.AllowMissingKeys(true)

        for _, path := range paths </span><span class="cov8" title="1">{
                results, err := parseJSONPath(data, j, path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">for _, result := range results </span><span class="cov8" title="1">{
                        klog.V(2).Infof("Found image %s", result)
                        img := v1alpha2.Image{
                                Name: result,
                        }

                        images = append(images, img)
                }</span>
        }

        <span class="cov8" title="1">return images, nil</span>
}

// mkTempFile will make a temporary file and return the name
// and cleanup method
func mktempFile(dir string) (func(), string, error) <span class="cov0" title="0">{
        file, err := os.CreateTemp(dir, "repo.*")
        return func() </span><span class="cov0" title="0">{
                if err := os.Remove(file.Name()); err != nil </span><span class="cov0" title="0">{
                        klog.Fatal(err)
                }</span>
        }, file.Name(), err
}

// defaultKeyring returns the expanded path to the default keyring.
func defaultKeyring() string <span class="cov0" title="0">{
        if v, ok := os.LookupEnv("GNUPGHOME"); ok </span><span class="cov0" title="0">{
                return filepath.Join(v, "pubring.gpg")
        }</span>
        <span class="cov0" title="0">return filepath.Join(homedir.HomeDir(), ".gnupg", "pubring.gpg")</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package initcmd

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "sort"

        "github.com/blang/semver/v4"
        "github.com/spf13/cobra"
        yamlv2 "gopkg.in/yaml.v2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/cli"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/version"
)

type InitOptions struct {
        *cli.RootOptions
        Output      string
        Registry    string
        catalogBase string
}

func NewInitCommand(f kcmdutil.Factory, ro *cli.RootOptions) *cobra.Command <span class="cov0" title="0">{
        o := InitOptions{
                RootOptions: ro,
                catalogBase: "registry.redhat.io/redhat/redhat-operator-index",
        }

        cmd := &amp;cobra.Command{
                Use:   "init",
                Short: "Output initial config template",
                Example: templates.Examples(`
                        # Get oc-mirror initial config template
                        oc-mirror init

                        # Get oc-mirror initial config template 
                        # with a registry storage backend
                        oc-mirror init --registry localhost:5000/test:latest
                        
                        # Save oc-mirror initial config to a file
                        oc-mirror init &gt;imageset-config.yaml
                `),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        kcmdutil.CheckErr(o.Validate())
                        kcmdutil.CheckErr(o.Run(cmd.Context()))
                }</span>,
        }

        <span class="cov0" title="0">fs := cmd.Flags()
        fs.StringVar(&amp;o.Output, "output", o.Output, "One of 'yaml' or 'json'.")
        fs.StringVar(&amp;o.Registry, "registry", o.Registry, "Registry location for storage backend, if using.")
        o.BindFlags(cmd.PersistentFlags())

        return cmd</span>
}

func (o *InitOptions) Validate() error <span class="cov8" title="1">{
        if o.Output != "" &amp;&amp; o.Output != "yaml" &amp;&amp; o.Output != "json" </span><span class="cov8" title="1">{
                return errors.New(`--output must be 'yaml' or 'json'`)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *InitOptions) Run(ctx context.Context) error <span class="cov8" title="1">{
        var err error

        releaseChannel, err := getReleaseChannelFromGit()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">catalog, err := getCatalog(o.catalogBase)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">imageSetConfig := v1alpha2.ImageSetConfiguration{
                TypeMeta: metav1.TypeMeta{
                        Kind:       v1alpha2.ImageSetConfigurationKind,
                        APIVersion: v1alpha2.GroupVersion.String(),
                },
                ImageSetConfigurationSpec: v1alpha2.ImageSetConfigurationSpec{
                        StorageConfig: v1alpha2.StorageConfig{
                                Registry: nil,
                                Local:    &amp;v1alpha2.LocalConfig{Path: "./"},
                        },
                        Mirror: v1alpha2.Mirror{
                                Platform: v1alpha2.Platform{
                                        Graph: false,
                                        Channels: []v1alpha2.ReleaseChannel{
                                                {
                                                        Name: releaseChannel,
                                                        // Default empty other fields
                                                },
                                        },
                                },
                                Operators: []v1alpha2.Operator{
                                        {
                                                IncludeConfig: v1alpha2.IncludeConfig{
                                                        Packages: []v1alpha2.IncludePackage{
                                                                {
                                                                        Name: "serverless-operator",
                                                                        Channels: []v1alpha2.IncludeChannel{
                                                                                {
                                                                                        Name: "stable",
                                                                                        //IncludeBundle: v1alpha2.IncludeBundle{},
                                                                                },
                                                                        },
                                                                        IncludeBundle: v1alpha2.IncludeBundle{},
                                                                },
                                                        },
                                                },
                                                //Catalog:          "registry.redhat.io/redhat/redhat-operator-index:v4.12",
                                                Catalog:          catalog,
                                                Full:             false,
                                                SkipDependencies: false,
                                        },
                                },
                                AdditionalImages: []v1alpha2.Image{
                                        {Name: "registry.redhat.io/ubi8/ubi:latest"}, // Just use UBI as the default
                                },
                                Helm:          v1alpha2.Helm{},
                                BlockedImages: nil,
                        },
                },
        }

        if o.Registry != "" </span><span class="cov8" title="1">{
                registry := &amp;v1alpha2.RegistryConfig{
                        ImageURL: o.Registry,
                        SkipTLS:  false,
                }
                imageSetConfig.ImageSetConfigurationSpec.StorageConfig.Registry = registry
                // Unset the local default backend
                imageSetConfig.ImageSetConfigurationSpec.StorageConfig.Local = nil
        }</span>

        <span class="cov8" title="1">switch o.Output </span>{
        case "":<span class="cov0" title="0">
                fallthrough</span>
        case "yaml":<span class="cov8" title="1">
                marshalled, err := orderedYamlMarshal(&amp;imageSetConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fmt.Fprint(o.Out, string(marshalled))</span>
        case "json":<span class="cov8" title="1">
                marshalled, err := json.MarshalIndent(&amp;imageSetConfig, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(o.Out, string(marshalled))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("InitOptions were not validated: --output=%q should have been rejected", o.Output)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getReleaseChannelFromGit() (string, error) <span class="cov8" title="1">{
        gitVersion := version.Get().GitVersion
        // Example: v4.1.1-g01d6cf7
        // Example: v4.2.0
        vers, err := semver.ParseTolerant(gitVersion)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to parse oc-mirror version: %s ; %w", gitVersion, err)
        }</span>
        <span class="cov8" title="1">releaseChannel := fmt.Sprintf("stable-%d.%d", vers.Major, vers.Minor)
        return releaseChannel, nil</span>
}

func getCatalog(catalogBase string) (string, error) <span class="cov8" title="1">{
        versionMap, err := image.GetVersionsFromImage(catalogBase)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to get version map for init: %w", err)
        }</span>
        <span class="cov8" title="1">catalogLatestVersionString := "v0.0"
        catalogLatestVersion, err := semver.ParseTolerant(catalogLatestVersionString)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("impossible error: unable to parse %s as version", catalogLatestVersionString)
        }</span>
        <span class="cov8" title="1">for versionString, count := range versionMap </span><span class="cov8" title="1">{
                if count == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">catalogVersion, err := semver.ParseTolerant(versionString)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if catalogVersion.GT(catalogLatestVersion) </span><span class="cov8" title="1">{
                        catalogLatestVersionString = versionString
                        catalogLatestVersion = catalogVersion
                }</span>
        }
        <span class="cov8" title="1">catalog := fmt.Sprintf("%s:%s", catalogBase, catalogLatestVersionString)
        return catalog, nil</span>
}

// Key order doesn't matter to machines, but is nice for humans.
// oc-mirror init output is for humans.
// Issue with k8s yaml library: no support for MapSlice
// Our structs have json tags but not yaml tags, and I didn't want to add yaml tags everywhere,
// so the JSON marshaller is used to adapt those tags and key sorting happens here.
// This is less code than adding MarshalYAML with MapSlices to our types
func orderedYamlMarshal(obj interface{}) ([]byte, error) <span class="cov8" title="1">{
        bytes, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var yamlObj map[string]interface{}
        err = yamlv2.Unmarshal(bytes, &amp;yamlObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">slices := interfaceToMapSlice(yamlObj)
        yamlOrder := map[string]map[string]int{
                "": {
                        "kind":          1,
                        "apiVersion":    2,
                        "storageConfig": 3,
                        "mirror":        4,
                },
                "storageConfig": {
                        "registry": 1,
                        "local":    2,
                },
                "registry": {
                        "imageURL": 1,
                        "skipTLS":  2,
                },
                "mirror": {
                        "platform":         1,
                        "operators":        2,
                        "additionalImages": 3,
                        "helm":             4,
                },
                "packages": {
                        "name":            1,
                        "startingVersion": 2,
                        "channels":        3,
                },
                "operators": {
                        "catalog":  1,
                        "packages": 2,
                },
                "channels": {
                        "name": -1,
                },
        }
        sortedSlices := deepMapKeySort(slices, yamlOrder, "")
        bytes, err = yamlv2.Marshal(&amp;sortedSlices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bytes, nil</span>
}

func interfaceToMapSlice(slice interface{}) yamlv2.MapSlice <span class="cov8" title="1">{
        mapSlice := yamlv2.MapSlice{}
        iter := reflect.ValueOf(slice).MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                mapSlice = append(mapSlice, yamlv2.MapItem{
                        Key:   fmt.Sprintf("%v", iter.Key()),
                        Value: iter.Value().Interface(),
                })
        }</span>
        <span class="cov8" title="1">return mapSlice</span>
}

// map[parent][child]index
func deepMapKeySort(slice interface{}, orders map[string]map[string]int, parentKey string) interface{} <span class="cov8" title="1">{
        switch slices := slice.(type) </span>{
        case yamlv2.MapSlice:<span class="cov8" title="1">
                for sliceIndex, mapItem := range slices </span><span class="cov8" title="1">{
                        key := fmt.Sprintf("%v", mapItem.Key)
                        switch reflect.ValueOf(mapItem.Value).Kind() </span>{
                        case reflect.Slice:<span class="cov8" title="1">
                                slices[sliceIndex].Value = deepMapKeySort(mapItem.Value, orders, key)</span>
                        case reflect.Map:<span class="cov8" title="1">
                                childMapSlice := interfaceToMapSlice(mapItem.Value)
                                slices[sliceIndex].Value = deepMapKeySort(childMapSlice, orders, key)</span>
                        }
                }
                <span class="cov8" title="1">sort.Slice(slices, func(i, j int) bool </span><span class="cov8" title="1">{
                        keyI := slices[i].Key.(string)
                        keyJ := slices[j].Key.(string)
                        return orders[parentKey][keyI] &lt; orders[parentKey][keyJ]
                }</span>)
                <span class="cov8" title="1">return slices</span>
        }
        <span class="cov8" title="1">switch reflect.ValueOf(slice).Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1">
                slice_ := slice.([]interface{})
                for i := range slice_ </span><span class="cov8" title="1">{
                        slice_[i] = deepMapKeySort(slice_[i], orders, parentKey)
                }</span>
                <span class="cov8" title="1">return slice</span>
        case reflect.Map:<span class="cov8" title="1">
                mapSlice := interfaceToMapSlice(slice)
                return deepMapKeySort(mapSlice, orders, parentKey)</span>
        }
        <span class="cov0" title="0">return slice</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package list

import (
        "github.com/spf13/cobra"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"

        "github.com/openshift/oc-mirror/pkg/cli"
)

func NewListCommand(f kcmdutil.Factory, ro *cli.RootOptions) *cobra.Command <span class="cov0" title="0">{

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List available platform and operator content and their versions.",
                Run:   kcmdutil.DefaultSubCommandRun(ro.IOStreams.ErrOut),
        }

        cmd.AddCommand(NewOperatorsCommand(f, ro))
        cmd.AddCommand(NewReleasesCommand(f, ro))
        cmd.AddCommand(NewUpdatesCommand(f, ro))

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package list

import (
        "errors"
        "fmt"
        "io"

        "github.com/operator-framework/operator-registry/alpha/action"
        "github.com/operator-framework/operator-registry/alpha/model"
        "github.com/spf13/cobra"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"

        "github.com/openshift/oc-mirror/pkg/cli"
        "github.com/openshift/oc-mirror/pkg/image"
)

type OperatorsOptions struct {
        *cli.RootOptions
        Catalog  string
        Package  string
        Channel  string
        Version  string
        Catalogs bool
}

func NewOperatorsCommand(f kcmdutil.Factory, ro *cli.RootOptions) *cobra.Command <span class="cov0" title="0">{
        o := OperatorsOptions{}
        o.RootOptions = ro

        cmd := &amp;cobra.Command{
                Use:   "operators",
                Short: "List available operator catalog content and versions",
                Example: templates.Examples(`
                    # List available operator catalog release versions
                        oc-mirror list operators

                        # Output default operator catalogs for OpenShift release 4.8
                        oc-mirror list operators --catalogs --version=4.8

                        # List all operator packages in a catalog
                        oc-mirror list operators --catalog=catalog-name

                        # List all channels in an operator package
                        oc-mirror list operators --catalog=catalog-name --package=package-name

                        # List all available versions for a specified operator in a channel
                        oc-mirror list operators --catalog=catalog-name --package=operator-name --channel=channel-name
                `),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        kcmdutil.CheckErr(o.Complete())
                        kcmdutil.CheckErr(o.Validate())
                        kcmdutil.CheckErr(o.Run(cmd))
                }</span>,
        }

        <span class="cov0" title="0">fs := cmd.Flags()
        fs.BoolVar(&amp;o.Catalogs, "catalogs", o.Catalogs, "List available catalogs for an OpenShift release version, requires --version")
        fs.StringVar(&amp;o.Catalog, "catalog", o.Catalog, "List information for a specified catalog")
        fs.StringVar(&amp;o.Package, "package", o.Package, "List information for a specified package")
        fs.StringVar(&amp;o.Channel, "channel", o.Channel, "List information for a specified channel")
        fs.StringVar(&amp;o.Version, "version", o.Version, "Specify an OpenShift release version")

        o.BindFlags(cmd.PersistentFlags())

        return cmd</span>
}

func (o *OperatorsOptions) Complete() error <span class="cov8" title="1">{
        if len(o.Version) &gt; 0 </span><span class="cov8" title="1">{
                o.Catalogs = true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *OperatorsOptions) Validate() error <span class="cov8" title="1">{
        if len(o.Version) == 0 &amp;&amp; o.Catalogs </span><span class="cov8" title="1">{
                return errors.New("must specify --version with --catalogs")
        }</span>
        <span class="cov8" title="1">if len(o.Channel) &gt; 0 &amp;&amp; (len(o.Package) == 0 || len(o.Catalog) == 0) </span><span class="cov8" title="1">{
                return errors.New("must specify --catalog and --package with --channel")
        }</span>
        <span class="cov8" title="1">if len(o.Package) &gt; 0 &amp;&amp; len(o.Catalog) == 0 </span><span class="cov8" title="1">{
                return errors.New("must specify --catalog with --package")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *OperatorsOptions) Run(cmd *cobra.Command) error <span class="cov0" title="0">{

        w := o.IOStreams.Out
        ctx := cmd.Context()

        // Process cases from most specific to most broad
        switch </span>{
        case len(o.Channel) &gt; 0:<span class="cov0" title="0">
                // Print Version for all bundles in a channel
                var ch model.Channel
                lc := action.ListChannels{
                        IndexReference: o.Catalog,
                        PackageName:    o.Package,
                }
                res, err := lc.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Find target channel for searching
                <span class="cov0" title="0">for _, c := range res.Channels </span><span class="cov0" title="0">{
                        if c.Name == o.Channel </span><span class="cov0" title="0">{
                                ch = c
                                break</span>
                        }
                }

                <span class="cov0" title="0">if _, err := fmt.Fprintln(w, "VERSIONS"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // List all bundle versions in channel
                <span class="cov0" title="0">for _, bndl := range ch.Bundles </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintln(w, bndl.Version); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case len(o.Package) &gt; 0:<span class="cov0" title="0">
                lc := action.ListChannels{
                        IndexReference: o.Catalog,
                        PackageName:    o.Package,
                }
                chRes, err := lc.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(chRes.Channels) &gt; 0 </span><span class="cov0" title="0">{
                        pkg := chRes.Channels[0].Package
                        pkgRes := action.ListPackagesResult{
                                Packages: []model.Package{*pkg},
                        }
                        if err := pkgRes.WriteColumns(w); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(w, "")</span>
                }
                <span class="cov0" title="0">if err := chRes.WriteColumns(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case len(o.Catalog) &gt; 0:<span class="cov0" title="0">
                lp := action.ListPackages{
                        IndexReference: o.Catalog,
                }
                res, err := lp.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list operators, please check catalog name - %s : %w", o.Catalog, err)
                }</span>
                <span class="cov0" title="0">if err := res.WriteColumns(o.IOStreams.Out); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case o.Catalogs:<span class="cov0" title="0">
                if _, err := fmt.Fprintln(w, "Available OpenShift OperatorHub catalogs:"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := o.listCatalogs(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">

                vm, err := image.GetVersionsFromImage(catalogs[0])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fmt.Fprintln(w, "Available OpenShift OperatorHub catalog versions:")

                for v := range vm </span><span class="cov0" title="0">{

                        if _, err := fmt.Fprintf(w, "  %s\n", v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                }
        }

        <span class="cov0" title="0">return nil</span>
}

var catalogs = []string{
        "registry.redhat.io/redhat/redhat-operator-index",
        "registry.redhat.io/redhat/certified-operator-index",
        "registry.redhat.io/redhat/community-operator-index",
        "registry.redhat.io/redhat/redhat-marketplace-index",
}

func (o *OperatorsOptions) listCatalogs(w io.Writer) error <span class="cov0" title="0">{

        if _, err := fmt.Fprintf(w, "OpenShift %s:\n", o.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, catalog := range catalogs </span><span class="cov0" title="0">{
                versions, err := image.GetVersionsFromImage(catalog)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "Failed to get catalog version details: %s", err)
                        continue</span>
                }

                <span class="cov0" title="0">if versions["v"+o.Version] &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "%s:v%s\n", catalog, o.Version)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(w, "Invalid catalog reference, please check version: %s:v%s\n", catalog, o.Version)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package list

import (
        "context"
        "errors"
        "fmt"
        "io"
        "sort"
        "strconv"
        "strings"

        "github.com/google/uuid"
        "github.com/spf13/cobra"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/cincinnati"
        "github.com/openshift/oc-mirror/pkg/cli"
        "github.com/openshift/oc-mirror/pkg/image"
)

type ReleasesOptions struct {
        *cli.RootOptions
        Channel       string
        Channels      bool
        Version       string
        FilterByArchs []string
}

// used to capture major.minor version from release tags
type releaseVersion struct {
        major int
        minor int
}

const OCPReleaseRepo = "quay.io/openshift-release-dev/ocp-release"

func NewReleasesCommand(f kcmdutil.Factory, ro *cli.RootOptions) *cobra.Command <span class="cov0" title="0">{
        o := ReleasesOptions{}
        o.RootOptions = ro

        cmd := &amp;cobra.Command{
                Use:   "releases",
                Short: "List available platform content and versions",
                Example: templates.Examples(`
                    # Output OpenShift release versions
                        oc-mirror list releases

                        # Output all OpenShift release channels list for a release
                        oc-mirror list releases --version=4.8

                        # List all OpenShift versions in a specified channel
                        oc-mirror list releases --channel=stable-4.8

                        # List all OpenShift channels for a specific version
                        oc-mirror list releases --channels --version=4.8

                        # List OpenShift channels for a specific version and one or more release architecture. Valid architectures: amd64 (default), arm64, ppc64le, s390x, multi.
                        oc-mirror list releases --channels --version=4.13 --filter-by-archs amd64,arm64,ppc64le,s390x,multi
                `),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        kcmdutil.CheckErr(o.Complete())
                        kcmdutil.CheckErr(o.Validate())
                        kcmdutil.CheckErr(o.Run(cmd.Context()))
                }</span>,
        }

        <span class="cov0" title="0">fs := cmd.Flags()
        fs.StringVar(&amp;o.Channel, "channel", o.Channel, "List information for a specified channel")
        fs.BoolVar(&amp;o.Channels, "channels", o.Channels, "List all channel information")
        fs.StringVar(&amp;o.Version, "version", o.Version, "Specify an OpenShift release version")
        fs.StringSliceVar(&amp;o.FilterByArchs, "filter-by-archs", o.FilterByArchs, "An architecture list to control the release image "+
                "picked when multiple variants are available")

        o.BindFlags(cmd.PersistentFlags())

        return cmd</span>
}

func (o *ReleasesOptions) Complete() error <span class="cov8" title="1">{
        if len(o.Version) &gt; 0 &amp;&amp; len(o.Channel) == 0 </span><span class="cov8" title="1">{

                r := releaseVersion{}
                if err := r.parseTag(o.Version); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">o.Channel = fmt.Sprintf("stable-%s", r.String())</span>
        }
        <span class="cov8" title="1">if len(o.FilterByArchs) == 0 </span><span class="cov8" title="1">{
                o.FilterByArchs = []string{v1alpha2.DefaultPlatformArchitecture}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *ReleasesOptions) Validate() error <span class="cov8" title="1">{
        if o.Channels &amp;&amp; len(o.Version) == 0 </span><span class="cov8" title="1">{
                return errors.New("must specify --version")
        }</span>
        <span class="cov8" title="1">if o.Channel == "stable-" </span><span class="cov8" title="1">{
                return errors.New("must specify --version or --channel")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *ReleasesOptions) Run(ctx context.Context) error <span class="cov0" title="0">{

        w := o.IOStreams.Out

        client, err := cincinnati.NewOCPClient(uuid.New())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if o.Channels </span><span class="cov0" title="0">{
                return listChannelsForVersion(ctx, client, o, w)
        }</span>

        <span class="cov0" title="0">if len(o.Channel) == 0 </span><span class="cov0" title="0">{
                return listOCPReleaseVersions(w)
        }</span>

        <span class="cov0" title="0">return listChannels(o, w, ctx, client)</span>

}

func listChannels(o *ReleasesOptions, w io.Writer, ctx context.Context, client cincinnati.Client) error <span class="cov0" title="0">{
        // By default, the stable channel versions will be listed
        if strings.HasPrefix(o.Channel, "stable") </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintln(w, "Listing stable channels. Use --channel=&lt;channel-name&gt; to filter."); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := fmt.Fprintln(w, "Use oc-mirror list release --channels to discover other channels."); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := fmt.Fprintln(w, ""); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">for _, arch := range o.FilterByArchs </span><span class="cov0" title="0">{
                vers, err := cincinnati.GetVersions(ctx, client, arch, o.Channel)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := fmt.Fprintf(w, "Channel: %v\nArchitecture: %v\n", o.Channel, arch); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, ver := range vers </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintf(w, "%s\n", ver); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }
        <span class="cov0" title="0">return nil</span>
}

func listChannelsForVersion(ctx context.Context, client cincinnati.Client, o *ReleasesOptions, w io.Writer) error <span class="cov0" title="0">{
        channels, err := cincinnati.GetChannels(ctx, client, o.Channel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := fmt.Fprintf(w, "Listing channels for version %v.\n\n", o.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for channel := range channels </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(w, "%s\n", channel); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func listOCPReleaseVersions(w io.Writer) error <span class="cov0" title="0">{
        tags, err := image.GetVersionsFromImage(OCPReleaseRepo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tagSlice := make([]string, 10)
        for tag := range tags </span><span class="cov0" title="0">{
                tagSlice = append(tagSlice, tag)
        }</span>
        <span class="cov0" title="0">versions := parseVersionTags(tagSlice)

        fmt.Fprint(w, "Available OpenShift Container Platform release versions: \n")

        for _, ver := range versions </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "  %s\n", ver.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Parse all the release image tags, and create a list of just the major.minor versions.
func parseVersionTags(versionTags []string) []releaseVersion <span class="cov8" title="1">{
        // Use a map to capture the unique major.minor versions
        ocpVersions := make(map[string]releaseVersion)
        for _, tag := range versionTags </span><span class="cov8" title="1">{
                r := releaseVersion{}
                if err := r.parseTag(tag); err != nil </span><span class="cov8" title="1">{
                        // tag is not $major.$minor.$patch(.*) continue to next tag
                        continue</span>
                }
                <span class="cov8" title="1">ocpVersions[r.String()] = r</span>
        }

        <span class="cov8" title="1">versions := make([]releaseVersion, 0, len(ocpVersions))
        for k := range ocpVersions </span><span class="cov8" title="1">{
                versions = append(versions, ocpVersions[k])
        }</span>

        <span class="cov8" title="1">sort.Slice(versions, func(i, j int) bool </span><span class="cov8" title="1">{
                if versions[i].major == versions[j].major </span><span class="cov8" title="1">{
                        return versions[i].minor &lt; versions[j].minor
                }</span>
                <span class="cov8" title="1">return versions[i].major &lt; versions[j].major</span>
        })
        <span class="cov8" title="1">return versions</span>
}

func (r *releaseVersion) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d.%d", r.major, r.minor)
}</span>

func (r *releaseVersion) parseTag(tag string) error <span class="cov8" title="1">{
        s := strings.Split(tag, ".")
        if len(s) &lt;= 1 </span><span class="cov8" title="1">{
                return errors.New("Unable parse major.minor version from: " + tag)
        }</span>
        <span class="cov8" title="1">var err error
        r.major, err = strconv.Atoi(s[0])
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("Unable to parse major version number. " + err.Error())
        }</span>
        <span class="cov8" title="1">r.minor, _ = strconv.Atoi(s[1]) // if minor version unparsed, defaults to 0
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package list

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "text/tabwriter"

        "github.com/blang/semver/v4"
        "github.com/google/uuid"
        "github.com/operator-framework/operator-registry/alpha/declcfg"
        "github.com/operator-framework/operator-registry/alpha/model"
        "github.com/operator-framework/operator-registry/pkg/image/containerdregistry"
        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/cincinnati"
        "github.com/openshift/oc-mirror/pkg/cli"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
        "github.com/openshift/oc-mirror/pkg/operator/diff"
)

type UpdatesOptions struct {
        *cli.RootOptions
        ConfigPath string
}

func NewUpdatesCommand(f kcmdutil.Factory, ro *cli.RootOptions) *cobra.Command <span class="cov0" title="0">{
        o := UpdatesOptions{}
        o.RootOptions = ro

        cmd := &amp;cobra.Command{
                Use:   "updates &lt;configuration path&gt;",
                Short: "List available updates in upgrade graph from upstream sources.",
                Long: templates.LongDesc(`
                List available updates in the upgrade graph for releases and operators from upstream sources
                based on current state. A storage configuration must be specified to use this command.
        `),
                Example: templates.Examples(`
                        # List updates between remote and current workspace
                        oc-mirror list updates mirror-config.yaml
                `),
                Args: cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        kcmdutil.CheckErr(o.Complete(args))
                        kcmdutil.CheckErr(o.Validate())
                        kcmdutil.CheckErr(o.Run(cmd.Context()))
                }</span>,
        }

        <span class="cov0" title="0">o.BindFlags(cmd.PersistentFlags())

        return cmd</span>
}

func (o *UpdatesOptions) Complete(args []string) error <span class="cov8" title="1">{
        if len(args) == 1 </span><span class="cov8" title="1">{
                o.ConfigPath = args[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *UpdatesOptions) Validate() error <span class="cov8" title="1">{
        if len(o.ConfigPath) == 0 </span><span class="cov8" title="1">{
                return errors.New("must specify imageset configuration")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *UpdatesOptions) Run(ctx context.Context) error <span class="cov0" title="0">{
        cfg, err := config.ReadConfig(o.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path := filepath.Join(o.Dir, config.SourceDir)
        backend, err := storage.ByConfig(path, cfg.StorageConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error opening backend: %v", err)
        }</span>

        <span class="cov0" title="0">var meta v1alpha2.Metadata
        switch err := backend.ReadMetadata(ctx, &amp;meta, config.MetadataBasePath); </span>{
        case err != nil &amp;&amp; !errors.Is(err, storage.ErrMetadataNotExist):<span class="cov0" title="0">
                return err</span>
        case err != nil &amp;&amp; errors.Is(err, storage.ErrMetadataNotExist):<span class="cov0" title="0">
                return fmt.Errorf("no metadata detected")</span>
        default:<span class="cov0" title="0">
                for _, arch := range cfg.Mirror.Platform.Architectures </span><span class="cov0" title="0">{
                        if len(cfg.Mirror.Platform.Channels) != 0 </span><span class="cov0" title="0">{
                                if err := o.releaseUpdates(ctx, arch, cfg, meta.PastMirror); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(cfg.Mirror.Operators) != 0 </span><span class="cov0" title="0">{
                        if err := o.operatorUpdates(ctx, cfg, meta); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (o UpdatesOptions) releaseUpdates(ctx context.Context, arch string, cfg v1alpha2.ImageSetConfiguration, last v1alpha2.PastMirror) error <span class="cov0" title="0">{
        lastMaxVersion := map[string]semver.Version{}
        for _, ch := range last.Mirror.Platform.Channels </span><span class="cov0" title="0">{
                version, err := semver.Parse(ch.MaxVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">lastMaxVersion[ch.Name] = version</span>
        }

        // Find the latest version is each channel being requested and plot upgrade graph between the old
        // versions if available
        <span class="cov0" title="0">id := uuid.New()

        for _, ch := range cfg.Mirror.Platform.Channels </span><span class="cov0" title="0">{

                var c cincinnati.Client
                var err error
                if ch.Type == v1alpha2.TypeOKD </span><span class="cov0" title="0">{
                        c, err = cincinnati.NewOKDClient(id)
                }</span> else<span class="cov0" title="0"> {
                        c, err = cincinnati.NewOCPClient(id)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">latest, err := cincinnati.GetChannelMinOrMax(ctx, c, arch, ch.Name, false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">ver, found := lastMaxVersion[ch.Name]
                if !found </span><span class="cov0" title="0">{
                        ver = latest
                }</span>
                <span class="cov0" title="0">_, _, upgrades, err := cincinnati.GetUpdates(ctx, c, arch, ch.Name, ver, latest)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var vers []semver.Version
                for _, upgrade := range upgrades </span><span class="cov0" title="0">{
                        vers = append(vers, upgrade.Version)
                }</span>

                <span class="cov0" title="0">if err := o.writeReleaseColumns(vers, arch, ch.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (o UpdatesOptions) operatorUpdates(ctx context.Context, cfg v1alpha2.ImageSetConfiguration, meta v1alpha2.Metadata) error <span class="cov0" title="0">{
        dstDir, err := os.MkdirTemp(o.Dir, "updatetmp-")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(dstDir)

        // Find last operator catalog digest
        var pin string

        for _, op := range meta.PastMirror.Operators </span><span class="cov0" title="0">{
                if len(op.ImagePin) != 0 </span><span class="cov0" title="0">{
                        pin = op.ImagePin
                        break</span>
                }
        }

        <span class="cov0" title="0">reg, err := containerdregistry.NewRegistry(
                containerdregistry.SkipTLSVerify(false),
                containerdregistry.WithCacheDir(filepath.Join(dstDir, "cache")),
        )
        defer reg.Destroy()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, ctlg := range cfg.Mirror.Operators </span><span class="cov0" title="0">{
                catLogger := logrus.WithField("catalog", ctlg.Catalog)
                dic, err := ctlg.IncludeConfig.ConvertToDiffIncludeConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">diff := diff.Diff{
                        Registry:      reg,
                        NewRefs:       []string{ctlg.Catalog},
                        Logger:        catLogger,
                        IncludeConfig: dic,
                }
                if len(pin) != 0 </span><span class="cov0" title="0">{
                        diff.OldRefs = []string{pin}
                }</span>
                <span class="cov0" title="0">dc, err := diff.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := o.writeCatalogColumns(*dc, ctlg.Catalog); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (o UpdatesOptions) writeReleaseColumns(upgrades []semver.Version, arch, channel string) error <span class="cov0" title="0">{
        if len(upgrades) == 0 </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(os.Stdout, "No updates found for release channel %s\n", channel); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">tw := tabwriter.NewWriter(o.IOStreams.Out, 0, 4, 2, ' ', 0)
        if _, err := fmt.Fprintf(tw, "Listing update for release channel:\t%s\n", channel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(tw, "Architecture:\t%s\n", arch); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, upgrade := range upgrades </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(tw, "%s\n", upgrade); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return tw.Flush()</span>
}

func (o UpdatesOptions) writeCatalogColumns(dc declcfg.DeclarativeConfig, catalog string) error <span class="cov0" title="0">{
        if len(dc.Packages) == 0 </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(os.Stdout, "No updates found for catalog %s\n", catalog); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">tw := tabwriter.NewWriter(o.IOStreams.Out, 0, 4, 2, ' ', 0)
        if _, err := fmt.Fprintf(tw, "Listing update for catalog:\t%s\n", catalog); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintln(tw, "Package\tChannel\tBundle\tReplaces"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">mod, err := declcfg.ConvertToModel(dc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pkgs := []model.Package{}
        for _, pkg := range mod </span><span class="cov0" title="0">{
                pkgs = append(pkgs, *pkg)
        }</span>

        <span class="cov0" title="0">bundles := []model.Bundle{}
        for _, pkg := range pkgs </span><span class="cov0" title="0">{
                for _, ch := range pkg.Channels </span><span class="cov0" title="0">{
                        for _, b := range ch.Bundles </span><span class="cov0" title="0">{
                                bundles = append(bundles, *b)
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, b := range bundles </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(tw, "%s\t%s\t%s\t%s\n", b.Package.Name, b.Channel.Name, b.Name, b.Replaces); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tw.Flush()</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package mirror

import (
        "bytes"
        "fmt"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "unicode"
        "unicode/utf8"

        operatorv1alpha1 "github.com/openshift/api/operator/v1alpha1"
        cincinnativ1 "github.com/openshift/cincinnati-operator/api/v1"
        "github.com/openshift/library-go/pkg/image/reference"
        "github.com/openshift/oc-mirror/pkg/image"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation"
        "k8s.io/klog/v2"
        "sigs.k8s.io/yaml"
)

const (
        icspSizeLimit       = 250000
        idmsSizeLimit       = 250000
        registryICSPScope   = "registry"
        repositoryICSPScope = "repository"
        namespaceICSPScope  = "namespace"
        icspKind            = "ImageContentSourcePolicy"
        updateServiceKind   = "UpdateService"
)

var icspTypeMeta = metav1.TypeMeta{
        APIVersion: operatorv1alpha1.GroupVersion.String(),
        Kind:       icspKind,
}

// ICSPBuilder defines methods for generating ICSPs
type ICSPBuilder interface {
        New(string, int) operatorv1alpha1.ImageContentSourcePolicy
        GetMapping(string, image.TypedImageMapping) (map[string]string, error)
}

var _ ICSPBuilder = &amp;ReleaseBuilder{}

type ReleaseBuilder struct{}

func (b *ReleaseBuilder) New(icspName string, icspCount int) operatorv1alpha1.ImageContentSourcePolicy <span class="cov8" title="1">{
        name := strings.Join(strings.Split(icspName, "/"), "-") + "-" + strconv.Itoa(icspCount)
        return operatorv1alpha1.ImageContentSourcePolicy{
                TypeMeta: icspTypeMeta,
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: operatorv1alpha1.ImageContentSourcePolicySpec{
                        RepositoryDigestMirrors: []operatorv1alpha1.RepositoryDigestMirrors{},
                },
        }
}</span>

func (b *ReleaseBuilder) GetMapping(_ string, mapping image.TypedImageMapping) (map[string]string, error) <span class="cov8" title="1">{
        // Scope is set to repository for release because
        // they are mirrored as different repo names by
        // release planner
        return getRegistryMapping(repositoryICSPScope, mapping)
}</span>

var _ ICSPBuilder = &amp;OperatorBuilder{}

type OperatorBuilder struct{}

func (b *OperatorBuilder) New(icspName string, icspCount int) operatorv1alpha1.ImageContentSourcePolicy <span class="cov8" title="1">{
        name := strings.Join(strings.Split(icspName, "/"), "-") + "-" + strconv.Itoa(icspCount)
        return operatorv1alpha1.ImageContentSourcePolicy{
                TypeMeta: icspTypeMeta,
                ObjectMeta: metav1.ObjectMeta{
                        Name:   name,
                        Labels: map[string]string{"operators.openshift.org/catalog": "true"},
                },
                Spec: operatorv1alpha1.ImageContentSourcePolicySpec{
                        RepositoryDigestMirrors: []operatorv1alpha1.RepositoryDigestMirrors{},
                },
        }
}</span>

func (b *OperatorBuilder) GetMapping(icspScope string, mapping image.TypedImageMapping) (map[string]string, error) <span class="cov8" title="1">{
        return getRegistryMapping(icspScope, mapping)
}</span>

var _ ICSPBuilder = &amp;GenericBuilder{}

type GenericBuilder struct{}

func (b *GenericBuilder) New(icspName string, icspCount int) operatorv1alpha1.ImageContentSourcePolicy <span class="cov8" title="1">{
        name := strings.Join(strings.Split(icspName, "/"), "-") + "-" + strconv.Itoa(icspCount)
        return operatorv1alpha1.ImageContentSourcePolicy{
                TypeMeta: icspTypeMeta,
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: operatorv1alpha1.ImageContentSourcePolicySpec{
                        RepositoryDigestMirrors: []operatorv1alpha1.RepositoryDigestMirrors{},
                },
        }
}</span>

func (b *GenericBuilder) GetMapping(icspScope string, mapping image.TypedImageMapping) (map[string]string, error) <span class="cov8" title="1">{
        return getRegistryMapping(icspScope, mapping)
}</span>

// GenerateICSP will generate ImageContentSourcePolicy objects based on image mapping and an ICSPBuilder
func (o *MirrorOptions) GenerateICSP(icspName, icspScope string, byteLimit int, mapping image.TypedImageMapping, builder ICSPBuilder) (icsps []operatorv1alpha1.ImageContentSourcePolicy, err error) <span class="cov8" title="1">{
        registryMapping, err := builder.GetMapping(icspScope, mapping)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for len(registryMapping) != 0 </span><span class="cov8" title="1">{

                var icspCount int
                icsp := builder.New(icspName, icspCount)

                for key := range registryMapping </span><span class="cov8" title="1">{
                        icsp.Spec.RepositoryDigestMirrors = append(icsp.Spec.RepositoryDigestMirrors, operatorv1alpha1.RepositoryDigestMirrors{
                                Source:  key,
                                Mirrors: []string{registryMapping[key]},
                        })

                        y, err := yaml.Marshal(icsp)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unable to marshal ImageContentSourcePolicy yaml: %v", err)
                        }</span>
                        <span class="cov8" title="1">if len(y) &gt; byteLimit </span><span class="cov0" title="0">{
                                if lenMirrors := len(icsp.Spec.RepositoryDigestMirrors); lenMirrors &gt; 0 </span><span class="cov0" title="0">{
                                        if lenMirrors == 1 </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("repository digest mirror for %q cannot fit into any ICSP with byte limit %d", key, byteLimit)
                                        }</span>
                                        <span class="cov0" title="0">icsp.Spec.RepositoryDigestMirrors = icsp.Spec.RepositoryDigestMirrors[:lenMirrors-1]</span>
                                }
                                <span class="cov0" title="0">icspCount++
                                break</span>
                        }
                        <span class="cov8" title="1">delete(registryMapping, key)</span>
                }

                <span class="cov8" title="1">if len(icsp.Spec.RepositoryDigestMirrors) != 0 </span><span class="cov8" title="1">{
                        icsps = append(icsps, icsp)
                }</span>
        }

        <span class="cov8" title="1">return icsps, nil</span>
}

func aggregateICSPs(icsps [][]byte) []byte <span class="cov0" title="0">{
        aggregation := []byte{}
        for _, icsp := range icsps </span><span class="cov0" title="0">{
                aggregation = append(aggregation, []byte("---\n")...)
                aggregation = append(aggregation, icsp...)
        }</span>
        <span class="cov0" title="0">return aggregation</span>
}

func getRegistryMapping(icspScope string, mapping image.TypedImageMapping) (map[string]string, error) <span class="cov8" title="1">{
        registryMapping := map[string]string{}
        for k, v := range mapping </span><span class="cov8" title="1">{
                if len(v.Ref.ID) == 0 </span><span class="cov8" title="1">{
                        klog.Warningf("no digest mapping available for %s, skip writing to ImageContentSourcePolicy", k)
                        continue</span>
                }

                <span class="cov8" title="1">imgRegistry := k.Ref.Registry
                imgNamespace := k.Ref.Namespace

                switch </span>{
                case icspScope == registryICSPScope:<span class="cov8" title="1">
                        registryMapping[imgRegistry] = v.Ref.Registry</span>
                case icspScope == namespaceICSPScope &amp;&amp; k.Ref.Namespace == "":<span class="cov8" title="1">
                        fallthrough</span>
                case icspScope == repositoryICSPScope:<span class="cov8" title="1">
                        registryMapping[k.Ref.AsRepository().String()] = v.Ref.AsRepository().String()</span>
                case icspScope == namespaceICSPScope:<span class="cov8" title="1">
                        source := path.Join(imgRegistry, imgNamespace)
                        dest := path.Join(v.Ref.Registry, v.Ref.Namespace)
                        registryMapping[source] = dest</span>
                default:<span class="cov8" title="1">
                        return registryMapping, fmt.Errorf("invalid ICSP scope %s", icspScope)</span>
                }
        }

        <span class="cov8" title="1">return registryMapping, nil</span>
}

func generateCatalogSource(name string, dest reference.DockerImageReference) ([]byte, error) <span class="cov8" title="1">{
        // Prefer tag over digest for automatic updates.
        if dest.Tag != "" </span><span class="cov8" title="1">{
                dest.ID = ""
        }</span>

        <span class="cov8" title="1">obj := map[string]interface{}{
                "apiVersion": "operators.coreos.com/v1alpha1",
                "kind":       "CatalogSource",
                "metadata": map[string]interface{}{
                        "name":      name,
                        "namespace": "openshift-marketplace",
                },
                "spec": map[string]interface{}{
                        "sourceType": "grpc",
                        "image":      dest.String(),
                },
        }
        cs, err := yaml.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to marshal CatalogSource yaml: %v", err)
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}

// Use this type to keep the
// status off the generated manifest
type updateService struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`
        Spec              cincinnativ1.UpdateServiceSpec `json:"spec"`
}

func generateUpdateService(name string, releaseRepo, graphDataImage reference.DockerImageReference) ([]byte, error) <span class="cov8" title="1">{
        var updateServiceMeta = metav1.TypeMeta{
                APIVersion: cincinnativ1.GroupVersion.String(),
                Kind:       updateServiceKind,
        }

        obj := updateService{
                TypeMeta: updateServiceMeta,
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: cincinnativ1.UpdateServiceSpec{
                        Replicas:       2,
                        Releases:       releaseRepo.AsRepository().Exact(),
                        GraphDataImage: graphDataImage.Exact(),
                },
        }
        cs, err := yaml.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to marshal UpdateService yaml: %v", err)
        }</span>
        // creationTimestamp is a struct, omitempty does not apply
        <span class="cov8" title="1">cs = bytes.ReplaceAll(cs, []byte("  creationTimestamp: null\n"), []byte(""))

        return cs, nil</span>
}

// WriteICSPs will write provided ImageContentSourcePolicy objects to disk
func WriteICSPs(dir string, icsps []operatorv1alpha1.ImageContentSourcePolicy) error <span class="cov0" title="0">{

        if len(icsps) == 0 </span><span class="cov0" title="0">{
                klog.V(2).Info("No ICSPs generated to write")
                return nil
        }</span>

        <span class="cov0" title="0">klog.Infof("Writing ICSP manifests to %s", dir)

        // Stable ICSP generation.
        sort.Slice(icsps, func(i, j int) bool </span><span class="cov0" title="0">{
                return string(icsps[i].Name) &lt; string(icsps[j].Name)
        }</span>)

        <span class="cov0" title="0">icspBytes := make([][]byte, len(icsps))
        for i := range icsps </span><span class="cov0" title="0">{
                // Create an unstructured object for removing creationTimestamp
                obj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&amp;icsps[i])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error converting to unstructured: %v", err)
                }</span>
                <span class="cov0" title="0">delete(obj["metadata"].(map[string]interface{}), "creationTimestamp")

                if icspBytes[i], err = yaml.Marshal(obj); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to marshal ImageContentSourcePolicy yaml: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if err := os.WriteFile(filepath.Join(dir, "imageContentSourcePolicy.yaml"), aggregateICSPs(icspBytes), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing ImageContentSourcePolicy: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WriteCatalogSource will generate a CatalogSource object and write it to disk
func WriteCatalogSource(mapping image.TypedImageMapping, dir string) error <span class="cov8" title="1">{
        if len(mapping) == 0 </span><span class="cov8" title="1">{
                klog.V(2).Info("No catalogs found in mapping")
                return nil
        }</span>

        <span class="cov8" title="1">klog.Infof("Writing CatalogSource manifests to %s", dir)

        // Keep track of the names and to make sure no
        // manifest are overwritten.
        // If found, increment the name suffix by one.
        names := make(map[string]int, len(mapping))
        for source, dest := range mapping </span><span class="cov8" title="1">{
                name := source.Ref.Name
                name, err := createRFC1035NameForCatalogSource(name)
                // in theory this should never error
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">value, found := names[name]
                if found </span><span class="cov8" title="1">{
                        value++
                        names[name] = value
                        name = fmt.Sprintf("%s-%d", name, value)
                }</span> else<span class="cov8" title="1"> {
                        names[name] = 0
                }</span>

                <span class="cov8" title="1">catalogSource, err := generateCatalogSource(name, dest.Ref)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := os.WriteFile(filepath.Join(dir, fmt.Sprintf("catalogSource-%s.yaml", name)), catalogSource, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error writing CatalogSource: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
CreateRFC1035Name converts the provided name to an RFC 1035 compliant name suitable
for use in a catalog source. Unacceptable characters are converted to a dash.
Duplicate consecutive dashes are converted to a single dash.

RFC 1035 compliant strings:

- must consist of lower case alphanumeric characters or '-'

- must start with an alphabetic character

- must end with an alphanumeric character

# Arguments

• nameIn: the string to use as a basis for conversion. It is assumed that this is the
name portion of a DockerImageReference

# Returns

• string: a string compliant with RFC 1035 or empty string if error occurs

• error: non nil if error occurs, nil otherwise
*/
func createRFC1035NameForCatalogSource(nameIn string) (string, error) <span class="cov8" title="1">{
        // In case the nameIn argument has multiple path components (organization, namespace + subnamespace):
        // Ex: foo.com/cp/test/common-services@sha256:ef64abd2c4c9acdc433ed4454b008d90891fe18fe33d3a53e7d6104a4a8bf5c5
        // In this case, the `source.Ref.Name` will contain some path-components, in addition to the image name, separated by `/`
        // For the above example: name = `test/common-services`
        // Since name is used to generate the file name, `os.WriteFile` will fail in this case, as sub directory test
        // doesn't exist. Therefore we replace all `/` with `-`. This also goes for any other "unacceptable" character
        // that is not compliant with RFC 1035.

        // start by making sure name starts with lower case alpha character, so prefix with `cs-`
        name := strings.Join([]string{"cs", nameIn}, "-")
        // modify name to be RFC 1035 compliant
        name = strings.Map(toRFC1035, name)

        // paranoid check to make sure the last character is alpha numeric
        lastChar, _ := utf8.DecodeLastRuneInString(name)
        if !(unicode.IsNumber(lastChar) || unicode.IsLetter(lastChar)) </span><span class="cov8" title="1">{
                // convert name to have `-0` suffix
                name = strings.Join([]string{name, "0"}, "-")
        }</span>

        // remove duplicate dashes
        <span class="cov8" title="1">stringBuilder := strings.Builder{}
        var lastEncounteredRune rune
        for position, currentRune := range name </span><span class="cov8" title="1">{
                if currentRune != lastEncounteredRune || position == 0 || currentRune != '-' </span><span class="cov8" title="1">{
                        stringBuilder.WriteRune(currentRune)
                        lastEncounteredRune = currentRune
                }</span>
        }
        <span class="cov8" title="1">name = stringBuilder.String()

        // truncate if necessary
        if len(name) &gt; validation.DNS1035LabelMaxLength </span><span class="cov8" title="1">{
                // truncate the name to max length
                truncatedName := name[:validation.DNS1035LabelMaxLength]
                // is the last char a dash or a char that would be converted to a dash?
                lastChar, _ := utf8.DecodeLastRuneInString(truncatedName)
                if toRFC1035(lastChar) == '-' </span><span class="cov8" title="1">{
                        // truncate even more to allow -0 suffix
                        truncatedName = truncatedName[:validation.DNS1035LabelMaxLength-2]
                        // put suffix in place
                        name = strings.Join([]string{truncatedName, "0"}, "-")
                }</span> else<span class="cov8" title="1"> {
                        // use truncated value as-is
                        name = truncatedName
                }</span>
        }

        // double check that the final name conforms to RFC 1035 (this should never fail)
        <span class="cov8" title="1">errs := validation.IsDNS1035Label(name)
        if len(errs) != 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating catalog source name: %s", strings.Join(errs, ", "))
        }</span>
        <span class="cov8" title="1">return name, nil</span>
}

/*
toRFC1035 converts the supplied rune to a dash if its not
a through z, 0 through 9 or a dash
*/
func toRFC1035(r rune) rune <span class="cov8" title="1">{
        r = unicode.ToLower(r)
        switch </span>{
        case r &gt;= 'a' &amp;&amp; r &lt;= 'z':<span class="cov8" title="1">
                return r</span>
        case r &gt;= '0' &amp;&amp; r &lt;= '9':<span class="cov8" title="1">
                return r</span>
        case r == '-':<span class="cov8" title="1">
                return r</span>
        default:<span class="cov8" title="1">
                // convert unacceptable character
                return '-'</span>
        }
}

// WriteUpdateService will generate an UpdateService object and write it to disk
func WriteUpdateService(release, graph image.TypedImage, dir string) error <span class="cov0" title="0">{
        klog.Infof("Writing UpdateService manifests to %s", dir)
        updateService, err := generateUpdateService("update-service-oc-mirror", release.Ref, graph.Ref)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := os.WriteFile(filepath.Join(dir, "updateService.yaml"), updateService, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing UpdateService: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path"
        "path/filepath"
        "strings"

        "github.com/containers/image/v5/types"
        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/opencontainers/go-digest"
        operatorv1alpha1 "github.com/openshift/api/operator/v1alpha1"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        imagemanifest "github.com/openshift/oc/pkg/cli/image/manifest"
        "github.com/openshift/oc/pkg/cli/image/mirror"
        "github.com/spf13/cobra"
        "k8s.io/cli-runtime/pkg/genericclioptions"
        "k8s.io/klog/v2"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/bundle"
        "github.com/openshift/oc-mirror/pkg/cli"
        "github.com/openshift/oc-mirror/pkg/cli/mirror/describe"
        "github.com/openshift/oc-mirror/pkg/cli/mirror/initcmd"
        "github.com/openshift/oc-mirror/pkg/cli/mirror/list"
        "github.com/openshift/oc-mirror/pkg/cli/mirror/version"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/metadata"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"

        cliV2 "github.com/openshift/oc-mirror/v2/pkg/cli"
        clog "github.com/openshift/oc-mirror/v2/pkg/log"
        "golang.org/x/exp/slices"
)

var (
        mirrorlongDesc = templates.LongDesc(
                ` 
                Create and publish user-configured mirrors with a declarative configuration input.
                Accepts an argument defining the destination for the mirrored images using the prefix file:// for a local mirror packed into a 
                tar archive or docker:// for images to be streamed registry to registry without being stored locally. The default docker credentials are 
                used for authenticating to the registries. The podman location for credentials is also supported as a secondary location.
                When using file mirroring, the --from and --config flags control the location of the images to mirror. The --config flag accepts
                an imageset configuration file and the --from flag accepts the location of the imageset on disk. The --from input can be passed as a 
                file or directory, but must contain only one image sequence. The naming convention for an imageset is mirror\_seq&lt;sequence number&gt;\_&lt;tar count&gt;.tar.
                The location of the directory used by oc-mirror as a workspace defaults to the name oc-mirror-workspace. The location of this directory
                is outlined in the following: 
                1. Destination prefix is docker:// - The current working directory will be used.
                2. Destination prefix is file:// - The destination directory specified will be used.
                `,
        )
        mirrorExamples = templates.Examples(
                `
                # Mirror to a directory
                oc-mirror --config mirror-config.yaml file://mirror
                # Mirror to a directory without layer and image differential operations
                oc-mirror --config mirror-config.yaml file://mirror --ignore-history
                # Mirror to mirror publish
                oc-mirror --config mirror-config.yaml docker://localhost:5000
                # Publish a previously created mirror archive
                oc-mirror --from mirror_seq1_000000.tar docker://localhost:5000
                # Publish to a registry and add a top-level namespace
                oc-mirror --from mirror_seq1_000000.tar docker://localhost:5000/namespace
                # Generate manifests for previously created mirror archive
                oc-mirror --from mirror_seq1_000000.tar docker://localhost:5000/namespace --manifests-only
                # Skip metadata check during imageset publishing. This example shows a two-step process.
                # A differential imageset would have to be created with --ignore-history to be
                # successfully published with --skip-metadata-check.
                oc-mirror --config mirror-config.yaml file://mirror --ignore-history
                oc-mirror --from mirror_seq2_000000.tar docker://localhost:5000/namespace --skip-metadata-check
                `,
        )
)

const (
        tagLatest string = "latest"
)

func NewMirrorCmd() *cobra.Command <span class="cov0" title="0">{
        if isV2() </span><span class="cov0" title="0">{
                return buildV2Cmd()
        }</span> else<span class="cov0" title="0"> {
                return buildV1Cmd()
        }</span>
}

func isV2() bool <span class="cov0" title="0">{
        return len(os.Args) &gt; 0 &amp;&amp; slices.Contains(os.Args[:], "--v2")
}</span>

func buildV1Cmd() *cobra.Command <span class="cov0" title="0">{
        o := MirrorOptions{
                operatorCatalogToFullArtifactPath: map[string]string{},
        }
        o.RootOptions = &amp;cli.RootOptions{
                IOStreams: genericclioptions.IOStreams{
                        In:     os.Stdin,
                        Out:    os.Stdout,
                        ErrOut: os.Stderr,
                },
        }

        // Configures a REST client getter factory from configs for mirroring releases.
        kubeConfigFlags := genericclioptions.NewConfigFlags(true).WithDiscoveryBurst(250)
        matchVersionKubeConfigFlags := kcmdutil.NewMatchVersionFlags(kubeConfigFlags)
        f := kcmdutil.NewFactory(matchVersionKubeConfigFlags)

        cmd := &amp;cobra.Command{
                Use: fmt.Sprintf(
                        "%s &lt;destination type&gt;:&lt;destination location&gt;",
                        filepath.Base(os.Args[0]),
                ),
                Short:             "Manage mirrors per user configuration",
                Long:              mirrorlongDesc,
                Example:           mirrorExamples,
                PersistentPreRun:  o.LogfilePreRun,
                PersistentPostRun: o.LogfilePostRun,
                Args:              cobra.MinimumNArgs(1),
                SilenceErrors:     false,
                SilenceUsage:      false,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        kcmdutil.CheckErr(o.Complete(cmd, args))
                        kcmdutil.CheckErr(o.Validate())
                        kcmdutil.CheckErr(o.Run(cmd, f))
                }</span>,
        }

        <span class="cov0" title="0">o.BindFlags(cmd.Flags())
        o.RootOptions.BindFlags(cmd.PersistentFlags())

        cmd.AddCommand(version.NewVersionCommand(f, o.RootOptions))
        cmd.AddCommand(list.NewListCommand(f, o.RootOptions))
        cmd.AddCommand(describe.NewDescribeCommand(f, o.RootOptions))
        cmd.AddCommand(initcmd.NewInitCommand(f, o.RootOptions))

        return cmd</span>
}

func buildV2Cmd() *cobra.Command <span class="cov0" title="0">{
        fmt.Println("--v2 flag identified, flow redirected to the oc-mirror v2 version. PLEASE DO NOT USE that. V2 is still under development and it is not ready to be used. ")

        log := clog.New("info")
        cmd := cliV2.NewMirrorCmd(log)
        return cmd
}</span>

func (o *MirrorOptions) Complete(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{

        destination := args[0]
        splitIdx := strings.Index(destination, "://")
        if splitIdx == -1 </span><span class="cov8" title="1">{
                return fmt.Errorf("no scheme delimiter in destination argument")
        }</span>
        <span class="cov8" title="1">typStr, ref := destination[:splitIdx], destination[splitIdx+3:]

        switch typStr </span>{
        case "file":<span class="cov8" title="1">
                if cmd.Flags().Changed("dir") </span><span class="cov0" title="0">{
                        return fmt.Errorf("--dir cannot be specified with file destination scheme")
                }</span>
                <span class="cov8" title="1">ref = filepath.Clean(ref)
                if ref == "" </span><span class="cov0" title="0">{
                        ref = "."
                }</span>
                <span class="cov8" title="1">o.OutputDir = ref
                // If the destination is on disk, made the output dir the
                // parent dir for the workspace
                o.Dir = filepath.Join(o.OutputDir, o.Dir)</span>
        case "oci":<span class="cov0" title="0">
                if cmd.Flags().Changed("dir") </span><span class="cov0" title="0">{
                        return fmt.Errorf("--dir cannot be specified with oci destination scheme")
                }</span>
                <span class="cov0" title="0">ref = filepath.Clean(ref)
                if ref == "" </span><span class="cov0" title="0">{
                        ref = "."
                }</span>
                <span class="cov0" title="0">o.OutputDir = ref
                // If the destination is on disk, made the output dir the
                // parent dir for the workspace
                o.Dir = filepath.Join(o.OutputDir, o.Dir)</span>
        case "docker":<span class="cov8" title="1">
                mirror, err := imagesource.ParseReference(ref)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">o.ToMirror = mirror.Ref.Registry
                // get the &lt;namespace&gt;/&lt;image&gt; portion of the docker reference only
                o.UserNamespace = mirror.Ref.RepositoryName()
                err = checkDockerReference(mirror, o.MaxNestedPaths)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown destination scheme %q", typStr)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// checkDockerReference prints warnings or returns an error if applicable.
func checkDockerReference(mirror imagesource.TypedImageReference, nested int) error <span class="cov8" title="1">{
        switch </span>{
        case mirror.Ref.Registry == "" &amp;&amp; mirror.Ref.Namespace != "" &amp;&amp; strings.Count(mirror.Ref.Name, "/") &gt;= 1:<span class="cov8" title="1">
                klog.V(0).Info("The docker reference was parsed as a namespace and a repository name, not including a registry.")
                klog.V(0).Info("To specify a registry, use a qualified hostname.")
                klog.V(0).Info("For example, instead of docker://registry/namespace/repository, use docker://registry.localdomain/namespace/repository")</span>
        case mirror.Ref.Registry == "" &amp;&amp; mirror.Ref.Namespace != "" &amp;&amp; mirror.Ref.Name != "":<span class="cov8" title="1">
                klog.V(0).Info("The docker reference was parsed as a namespace and name, not including a registry.")
                klog.V(0).Info("To specify a registry, use a qualified hostname.")
                klog.V(0).Info("For example, instead of docker://registry/repository, use docker://registry.localdomain/repository")</span>
        case mirror.Ref.Registry == "" &amp;&amp; mirror.Ref.Namespace == "" &amp;&amp; mirror.Ref.Tag == "" &amp;&amp; mirror.Ref.ID == "":<span class="cov8" title="1">
                klog.V(0).Info("The docker reference was parsed as a repository (or image) name, not a registry.")
                klog.V(0).Info("To specify a repository, use a qualified hostname.")
                klog.V(0).Info("For example, instead of docker://registry, use docker://registry.localdomain")</span>
        case mirror.Ref.Registry == "" &amp;&amp; (mirror.Ref.Tag != "" || mirror.Ref.ID != ""):<span class="cov8" title="1">
                klog.V(0).Info("The docker reference was parsed as image:tag, not as hostname:port.")
                klog.V(0).Info("To specify a registry, use a qualified hostname.")
                klog.V(0).Info("For example, instead of docker://registry:5000, use docker://registry.localdomain:5000")</span>
        }
        <span class="cov8" title="1">if mirror.Ref.Registry == "" || mirror.Ref.Tag != "" || mirror.Ref.ID != "" </span><span class="cov8" title="1">{
                return fmt.Errorf("destination registry must consist of registry host and namespace(s) only, and must not include an image tag or ID")
        }</span>

        <span class="cov8" title="1">depth := strings.Split(mirror.Ref.RepositoryName(), "/")
        if nested &gt; 0 &amp;&amp; (len(depth) &gt;= nested) </span><span class="cov8" title="1">{
                return fmt.Errorf("the max-nested-paths value (%d) must be strictly higher than the number of path-components in the destination %s - try increasing the value", nested, mirror.Ref.RepositoryName())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *MirrorOptions) Validate() error <span class="cov8" title="1">{
        switch </span>{
        case len(o.From) &gt; 0 &amp;&amp; len(o.ToMirror) == 0:<span class="cov8" title="1">
                return fmt.Errorf("must specify a registry destination")</span>
        case len(o.OutputDir) &gt; 0 &amp;&amp; len(o.ConfigPath) == 0:<span class="cov8" title="1">
                return fmt.Errorf("must specify a configuration file with --config")</span>
        case len(o.ToMirror) &gt; 0 &amp;&amp; len(o.ConfigPath) == 0 &amp;&amp; len(o.From) == 0:<span class="cov8" title="1">
                return fmt.Errorf("must specify --config or --from with registry destination")</span>
        case o.ManifestsOnly &amp;&amp; len(o.From) == 0:<span class="cov8" title="1">
                return fmt.Errorf("must specify a path to an archive with --from with --manifest-only")</span>
        }

        <span class="cov8" title="1">var destInsecure bool
        if o.DestPlainHTTP || o.DestSkipTLS </span><span class="cov0" title="0">{
                destInsecure = true
        }</span>

        // Attempt to login to registry
        // FIXME(jpower432): CheckPushPermissions is slated for deprecation
        // must replace with its replacement
        <span class="cov8" title="1">if len(o.ToMirror) &gt; 0 &amp;&amp; !o.ManifestsOnly </span><span class="cov8" title="1">{
                klog.Infof("Checking push permissions for %s", o.ToMirror)
                ref := path.Join(o.ToMirror, o.UserNamespace, "oc-mirror")
                klog.V(2).Infof("Using image %s to check permissions", ref)
                imgRef, err := name.ParseReference(ref, getNameOpts(destInsecure)...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := remote.CheckPushPermission(imgRef, authn.DefaultKeychain, createRT(destInsecure)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error checking push permissions for %s: %v", o.ToMirror, err)
                }</span>
        }

        <span class="cov8" title="1">if len(o.From) &gt; 0 </span><span class="cov8" title="1">{
                if _, err := os.Stat(o.From); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // mode options
        <span class="cov8" title="1">mirrorToDisk := len(o.OutputDir) &gt; 0 &amp;&amp; o.From == ""
        mirrorToMirror := len(o.ToMirror) &gt; 0 &amp;&amp; len(o.ConfigPath) &gt; 0

        // mirrorToMirror workflow using the oci feature must have at least on operator set with oci:// prefix
        if mirrorToMirror || mirrorToDisk </span><span class="cov8" title="1">{
                cfg, err := config.ReadConfig(o.ConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to read the configuration file provided with --config: %v", err)
                }</span>
                <span class="cov8" title="1">for _, op := range cfg.Mirror.Operators </span><span class="cov8" title="1">{
                        if op.IsFBCOCI() </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if o.SkipPruning </span><span class="cov0" title="0">{
                klog.Infof("using --skip-pruning flag - pruning will be skipped")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type cleanupFunc func() error

func (o *MirrorOptions) Run(cmd *cobra.Command, f kcmdutil.Factory) (err error) <span class="cov0" title="0">{
        if o.OutputDir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(o.OutputDir, 0750); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">cleanup := func() error </span><span class="cov0" title="0">{
                if !o.SkipCleanup </span><span class="cov0" title="0">{
                        os.RemoveAll(artifactsFolderName)
                        removeTmpDirs()
                        return os.RemoveAll(filepath.Join(o.Dir, config.SourceDir))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return o.mirrorImages(cmd.Context(), cleanup)</span>
}

func (o *MirrorOptions) mirrorImages(ctx context.Context, cleanup cleanupFunc) error <span class="cov0" title="0">{

        o.remoteRegFuncs = RemoteRegFuncs{
                newImageSource: func(ctx context.Context, sys *types.SystemContext, imgRef types.ImageReference) (types.ImageSource, error) </span><span class="cov0" title="0">{
                        return imgRef.NewImageSource(ctx, sys)
                }</span>,
                getManifest: func(ctx context.Context, instanceDigest *digest.Digest, imgSrc types.ImageSource) ([]byte, string, error) <span class="cov0" title="0">{
                        return imgSrc.GetManifest(ctx, instanceDigest)
                }</span>,
                handleMetadata: o.handleMetadata,
        }

        // Three mode options
        <span class="cov0" title="0">mirrorToDisk := len(o.OutputDir) &gt; 0 &amp;&amp; o.From == ""
        diskToMirror := len(o.ToMirror) &gt; 0 &amp;&amp; len(o.From) &gt; 0
        mirrorToMirror := len(o.ToMirror) &gt; 0 &amp;&amp; len(o.ConfigPath) &gt; 0

        switch </span>{
        case o.ManifestsOnly:<span class="cov0" title="0">
                meta, err := bundle.ReadMetadataFromFile(ctx, o.From)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error retrieving metadata from %q: %v", o.From, err)
                }</span>

                <span class="cov0" title="0">mapping, err := image.ConvertToTypedMapping(meta.PastAssociations)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">mapping.ToRegistry(o.ToMirror, o.UserNamespace)
                results, err := o.createResultsDir()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return o.generateResults(mapping, results)</span>
        case mirrorToDisk:<span class="cov0" title="0">
                cfg, err := config.ReadConfig(o.ConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return o.mirrorToDiskWrapper(ctx, cfg, cleanup)</span>

        case diskToMirror:<span class="cov0" title="0">
                dir, err := o.createResultsDir()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">o.OutputDir = dir
                return o.diskToMirrorWrapper(ctx, cleanup)</span>

        case mirrorToMirror:<span class="cov0" title="0">

                cfg, err := config.ReadConfig(o.ConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return o.mirrorToMirrorWrapper(ctx, cfg, cleanup)</span>

        }
        <span class="cov0" title="0">if o.continuedOnError </span><span class="cov0" title="0">{
                return fmt.Errorf("one or more errors occurred")
        }</span>

        <span class="cov0" title="0">return cleanup()</span>
}

// removePreviouslyMirrored will check if an image has been previously mirrored
// and remove it from the mapping if found. These images are added to the current AssociationSet
// to maintain a history of images. Any images in the AssociationSet that was not requested in the mapping
// will be pruned from the history.
func (o *MirrorOptions) removePreviouslyMirrored(images image.TypedImageMapping, meta v1alpha2.Metadata) (image.AssociationSet, error) <span class="cov8" title="1">{
        prevDownloads, err := image.ConvertToAssociationSet(meta.PastAssociations)
        if err != nil </span><span class="cov0" title="0">{
                return image.AssociationSet{}, err
        }</span>

        <span class="cov8" title="1">if o.IgnoreHistory </span><span class="cov0" title="0">{
                return prevDownloads, nil
        }</span>

        <span class="cov8" title="1">var keep []string
        for srcRef := range images </span><span class="cov8" title="1">{
                // All keys need to specify image with digest.
                // Tagged images will need to be re-downloaded to
                // ensure their digests have not been updated.
                if srcRef.Ref.ID == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if found := prevDownloads.SetContainsKey(srcRef.Ref.String()); found </span><span class="cov8" title="1">{
                        klog.V(2).Infof("Skipping previously mirrored image %s", srcRef.Ref.String())
                        images.Remove(srcRef)
                        keep = append(keep, srcRef.Ref.String())
                }</span>
        }

        <span class="cov8" title="1">prunedDownloads, err := image.Prune(prevDownloads, keep)
        if err != nil </span><span class="cov0" title="0">{
                return prunedDownloads, err
        }</span>

        <span class="cov8" title="1">if len(images) == 0 </span><span class="cov8" title="1">{
                return image.AssociationSet{}, ErrNoUpdatesExist
        }</span>

        <span class="cov8" title="1">return prunedDownloads, prunedDownloads.Validate()</span>
}

// mirrorMappings downloads individual images from an image mapping.
func (o *MirrorOptions) mirrorMappings(cfg v1alpha2.ImageSetConfiguration, images image.TypedImageMapping, insecure bool) error <span class="cov0" title="0">{

        opts, err := o.newMirrorImageOptions(insecure)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var mappings []mirror.Mapping
        for srcRef, dstRef := range images </span><span class="cov0" title="0">{
                blocked, err := isBlocked(cfg.Mirror.BlockedImages, srcRef.Ref.Exact())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if blocked </span><span class="cov0" title="0">{
                        klog.Warningf("skipping blocked image %s", srcRef.String())
                        // Remove to make sure this does not end up in the metadata
                        images.Remove(srcRef)
                        continue</span>
                }

                <span class="cov0" title="0">srcTIR := imagesource.TypedImageReference{
                        Ref:  srcRef.Ref,
                        Type: srcRef.Type,
                }

                // OCPBUGS-11922
                dstTIR := o.processNestedPaths(&amp;dstRef)
                // Updating the original map - which will later be used to generate ICSP
                images[srcRef] = image.TypedImage{
                        Category:    dstRef.Category,
                        ImageFormat: dstRef.ImageFormat,
                        TypedImageReference: image.TypedImageReference{
                                Type:       dstRef.Type,
                                Ref:        dstTIR.Ref,
                                OCIFBCPath: dstRef.OCIFBCPath,
                        },
                }
                // Updating mappings which will be used for mirroring the images
                mappings = append(mappings, mirror.Mapping{
                        Source:      srcTIR,
                        Destination: dstTIR,
                        Name:        srcRef.Ref.Name,
                })</span>
        }
        <span class="cov0" title="0">opts.Mappings = mappings
        if err := opts.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return o.checkErr(opts.Run(), nil, nil)</span>
}

func (o *MirrorOptions) newMirrorImageOptions(insecure bool) (*mirror.MirrorImageOptions, error) <span class="cov0" title="0">{
        opts := mirror.NewMirrorImageOptions(o.IOStreams)
        opts.SkipMissing = o.SkipMissing
        opts.ContinueOnError = o.ContinueOnError
        opts.DryRun = o.DryRun
        opts.FileDir = filepath.Join(o.Dir, config.SourceDir)
        opts.FromFileDir = o.From
        opts.SecurityOptions.Insecure = insecure
        opts.SecurityOptions.SkipVerification = o.SkipVerification
        opts.FilterOptions = imagemanifest.FilterOptions{FilterByOS: ".*"}
        opts.KeepManifestList = true
        opts.SkipMultipleScopes = true
        opts.ParallelOptions = imagemanifest.ParallelOptions{MaxPerRegistry: o.MaxPerRegistry}
        regctx, err := image.NewContext(o.SkipVerification)
        if err != nil </span><span class="cov0" title="0">{
                return opts, fmt.Errorf("error creating registry context: %v", err)
        }</span>
        <span class="cov0" title="0">opts.SecurityOptions.CachedContext = regctx

        return opts, nil</span>
}

// generateResults will generate a mapping.txt and allow applicable manifests and write
// the data to files in the specified directory.
func (o *MirrorOptions) generateResults(mapping image.TypedImageMapping, dir string) error <span class="cov0" title="0">{

        mappingResultsPath := filepath.Join(dir, mappingFile)
        if err := o.writeMappingFile(mappingResultsPath, mapping); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allICSPs := []operatorv1alpha1.ImageContentSourcePolicy{}
        releases := image.ByCategory(mapping, v1alpha2.TypeOCPRelease, v1alpha2.TypeOCPReleaseContent)
        graphs := image.ByCategory(mapping, v1alpha2.TypeCincinnatiGraph)
        generic := image.ByCategory(mapping, v1alpha2.TypeGeneric)
        operator := image.ByCategory(mapping, v1alpha2.TypeOperatorBundle, v1alpha2.TypeOperatorRelatedImage)

        getICSP := func(mapping image.TypedImageMapping, name string, scope string, builder ICSPBuilder) error </span><span class="cov0" title="0">{
                icsps, err := o.GenerateICSP(name, scope, icspSizeLimit, mapping, builder)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error generating ICSP manifests")
                }</span>
                <span class="cov0" title="0">allICSPs = append(allICSPs, icsps...)
                return nil</span>
        }

        <span class="cov0" title="0">if len(graphs) == 1 </span><span class="cov0" title="0">{
                releaseImages := image.ByCategory(releases, v1alpha2.TypeOCPRelease)
                if len(releaseImages) != 0 </span><span class="cov0" title="0">{
                        for _, graph := range graphs </span><span class="cov0" title="0">{
                                var release image.TypedImage
                                // Just grab the first release image.
                                // The value is used as a repo and all release images
                                // are stored in the same repo.
                                for _, v := range releaseImages </span><span class="cov0" title="0">{
                                        release = v
                                        break</span>
                                }
                                <span class="cov0" title="0">if err := WriteUpdateService(release, graph, dir); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

        }

        <span class="cov0" title="0">ctlgRefs := image.ByCategory(mapping, v1alpha2.TypeOperatorCatalog)
        if len(ctlgRefs) != 0 </span><span class="cov0" title="0">{
                if err := WriteCatalogSource(ctlgRefs, dir); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := getICSP(releases, "release", namespaceICSPScope, &amp;ReleaseBuilder{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := getICSP(generic, "generic", namespaceICSPScope, &amp;GenericBuilder{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if o.MaxNestedPaths &gt; 0 </span><span class="cov0" title="0">{
                if err := getICSP(operator, "operator", repositoryICSPScope, &amp;OperatorBuilder{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := getICSP(operator, "operator", namespaceICSPScope, &amp;OperatorBuilder{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return WriteICSPs(dir, allICSPs)</span>
}

// moveToResults will move release signatures and helm charts to
// the specified results directory from the defined source directory
// in the config package.
func (o *MirrorOptions) moveToResults(resultsDir string) error <span class="cov0" title="0">{

        resultsDir = filepath.Clean(resultsDir)

        srcSignaturePath := filepath.Join(o.Dir, config.SourceDir, config.ReleaseSignatureDir)
        dstSignaturePath := filepath.Join(resultsDir, config.ReleaseSignatureDir)
        if err := os.Rename(srcSignaturePath, dstSignaturePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">klog.V(1).Infof("Moved any release signatures to %s", resultsDir)

        // Move charts into results dir
        srcHelmPath := filepath.Join(o.Dir, config.SourceDir, config.HelmDir)
        dstHelmPath := filepath.Join(resultsDir, config.HelmDir)
        if err := os.Rename(srcHelmPath, dstHelmPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">klog.V(1).Infof("Moved any downloaded Helm charts to %s", resultsDir)
        return nil</span>
}

func (o *MirrorOptions) processAssociationErrors(errs []error) error <span class="cov0" title="0">{
        if errs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">skipErr := func(err error) bool </span><span class="cov0" title="0">{
                ierr := &amp;image.ErrInvalidImage{}
                cerr := &amp;image.ErrInvalidComponent{}
                return errors.As(err, &amp;ierr) || errors.As(err, &amp;cerr)
        }</span>
        <span class="cov0" title="0">ierr := &amp;image.ErrInvalidImage{}
        for _, e := range errs </span><span class="cov0" title="0">{
                if o.SkipMissing &amp;&amp; errors.As(e, &amp;ierr) </span><span class="cov0" title="0">{
                        klog.V(1).Infof("warning: skipping image: %v", e)
                        continue</span>
                }
                <span class="cov0" title="0">if err := o.checkErr(e, skipErr, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (o *MirrorOptions) writeMappingFile(mappingPath string, mapping image.TypedImageMapping) error <span class="cov0" title="0">{
        path := filepath.Clean(mappingPath)
        mappingFile, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer mappingFile.Close()
        klog.Infof("Writing image mapping to %s", mappingPath)
        if err := image.WriteImageMapping(o.MaxNestedPaths, mapping, mappingFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return mappingFile.Sync()</span>
}

func (o *MirrorOptions) mirrorToMirrorWrapper(ctx context.Context, cfg v1alpha2.ImageSetConfiguration, cleanup cleanupFunc) error <span class="cov0" title="0">{
        destInsecure := o.DestPlainHTTP || o.DestSkipTLS
        srcInsecure := o.SourcePlainHTTP || o.SourceSkipTLS

        mappingPath := filepath.Join(o.Dir, mappingFile)

        if err := bundle.MakeWorkspaceDirs(o.Dir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">meta, mapping, err := o.Create(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Imageset sequence check
        <span class="cov0" title="0">metaImage := o.newMetadataImage(meta.Uid.String())
        targetCfg := &amp;v1alpha2.RegistryConfig{
                ImageURL: metaImage,
                SkipTLS:  destInsecure,
        }

        targetBackend, err := storage.NewRegistryBackend(targetCfg, o.Dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var curr v1alpha2.Metadata
        berr := targetBackend.ReadMetadata(ctx, &amp;curr, config.MetadataBasePath)
        if err := o.checkSequence(meta, curr, berr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Change the destination to registry
        // TODO(jpower432): Investigate whether oc can produce
        // registry to registry mapping
        <span class="cov0" title="0">mapping.ToRegistry(o.ToMirror, o.UserNamespace)

        prunedAssociations, err := o.removePreviouslyMirrored(mapping, meta)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ErrNoUpdatesExist) </span><span class="cov0" title="0">{
                        klog.Infof("No new images detected, process stopping")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // QUESTION(jpower432): Can you specify different TLS configuration for source
        // and destination with `oc image mirror`?
        <span class="cov0" title="0">if err := o.mirrorMappings(cfg, mapping, destInsecure || srcInsecure); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">prevAssociations, err := image.ConvertToAssociationSet(meta.PastAssociations)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if o.DryRun </span><span class="cov0" title="0">{
                if err := o.writeMappingFile(mappingPath, mapping); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := o.outputPruneImagePlan(ctx, prevAssociations, prunedAssociations); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return cleanup()</span>
        }

        <span class="cov0" title="0">assocs, errs := image.AssociateRemoteImageLayers(ctx, mapping, o.SourceSkipTLS, o.SourcePlainHTTP, o.SkipVerification)
        if errs != nil </span><span class="cov0" title="0">{
                if err := o.processAssociationErrors(errs.Errors()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Prune the images that differ between the previous Associations and the
        // pruned Associations.
        <span class="cov0" title="0">meta.PastMirror.Associations, err = image.ConvertFromAssociationSet(assocs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">prunedAssociations.Merge(assocs)

        if err := o.pruneRegistry(ctx, prevAssociations, prunedAssociations); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error pruning from registry %q: %v", o.ToMirror, err)
        }</span>

        <span class="cov0" title="0">meta.PastAssociations, err = image.ConvertFromAssociationSet(prunedAssociations)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dir, err := o.createResultsDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // process catalog FBC images
        <span class="cov0" title="0">if len(cfg.Mirror.Operators) &gt; 0 </span><span class="cov0" title="0">{
                ctlgRefs, err := o.rebuildCatalogs(ctx, filepath.Join(o.Dir, config.SourceDir))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error rebuilding catalog images from file-based catalogs: %v", err)
                }</span>
                <span class="cov0" title="0">mapping.Merge(ctlgRefs)</span>
        }
        // process Cincinnati graph data image
        <span class="cov0" title="0">if len(cfg.Mirror.Platform.Channels) &gt; 0 </span><span class="cov0" title="0">{
                if cfg.Mirror.Platform.Graph </span><span class="cov0" title="0">{
                        graphRef, err := o.buildGraphImage(ctx, filepath.Join(o.Dir, config.SourceDir))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error building cincinnati graph image: %v", err)
                        }</span>
                        <span class="cov0" title="0">mapping.Merge(graphRef)</span>
                }
        }

        <span class="cov0" title="0">if err := o.generateResults(mapping, dir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := o.moveToResults(dir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Sync metadata from disk to source and target backends
        <span class="cov0" title="0">if cfg.StorageConfig.IsSet() </span><span class="cov0" title="0">{
                sourceBackend, err := storage.ByConfig(o.Dir, cfg.StorageConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">workspace := filepath.Join(o.Dir, config.SourceDir)
                if err = metadata.UpdateMetadata(ctx, sourceBackend, &amp;meta, workspace, o.SourceSkipTLS, o.SourcePlainHTTP); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := metadata.SyncMetadata(ctx, sourceBackend, targetBackend); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return cleanup()</span>
}

// mirrorToDiskWrapper
func (o *MirrorOptions) mirrorToDiskWrapper(ctx context.Context, cfg v1alpha2.ImageSetConfiguration, cleanup cleanupFunc) error <span class="cov0" title="0">{
        sourceInsecure := o.SourcePlainHTTP || o.SourceSkipTLS

        if err := bundle.MakeWorkspaceDirs(o.Dir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">meta, mapping, err := o.Create(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Fix OCPBUGS-2633:
        // For DiskToMirror only
        // if more than one image in imageList belong to the same repository with different digests, no tag
        // and type destinationFile, then, replace the `latest` tag (set by `DockerClientDefaults`) by a subset
        // of the digest
        // Ex:
        // - name: quay.io/okd/scos-content@sha256:fc37fb091804ce32411d04559a4b0ba63139bd12b51f7d87dc2e8fa9ff9d3ef7
        // - name: quay.io/okd/scos-content@sha256:df80aa07467d1c6f59a39f3c00e00e130a6b25308b1419264565ca7cd8a76407

        <span class="cov0" title="0">firstTagLatestImageByRepo := make(map[string]image.TypedImage)

        for srcRef, dstRef := range mapping </span><span class="cov0" title="0">{

                if dstRef.Ref.Tag == tagLatest </span><span class="cov0" title="0">{
                        if firstSrcRef, ok := firstTagLatestImageByRepo[srcRef.Ref.AsRepository().String()]; !ok </span><span class="cov0" title="0">{
                                firstTagLatestImageByRepo[srcRef.Ref.AsRepository().String()] = srcRef
                        }</span> else<span class="cov0" title="0"> {
                                // There's more than one image for this repository with tag latest
                                // Replace tag latest for firstDstRef by a subset of the digest
                                if firstDstRef, exists := mapping[firstSrcRef]; exists &amp;&amp; firstSrcRef.Ref.ID != "" &amp;&amp; firstDstRef.Type == imagesource.DestinationFile </span><span class="cov0" title="0">{
                                        firstDstRefTag := strings.TrimPrefix(firstSrcRef.Ref.ID, "sha256:")
                                        if len(firstDstRefTag) &gt;= 8 </span><span class="cov0" title="0">{
                                                firstDstRefTag = firstDstRefTag[:8]
                                        }</span>
                                        <span class="cov0" title="0">firstDstRef.Ref.Tag = firstDstRefTag
                                        mapping[firstSrcRef] = firstDstRef</span>
                                }
                                // all following images with latest tag will get a subset of the digest as the tag as well
                                <span class="cov0" title="0">if dstRef.Type == imagesource.DestinationFile &amp;&amp; srcRef.Ref.ID != "" </span><span class="cov0" title="0">{
                                        newTag := strings.TrimPrefix(srcRef.Ref.ID, "sha256:")
                                        if len(newTag) &gt;= 8 </span><span class="cov0" title="0">{
                                                newTag = newTag[:8]
                                        }</span>
                                        <span class="cov0" title="0">dstRef.Ref.Tag = newTag
                                        mapping[srcRef] = dstRef</span>
                                }

                        }
                }
        }
        // End Fix OCPBUGS-2633
        <span class="cov0" title="0">prunedAssociations, err := o.removePreviouslyMirrored(mapping, meta)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ErrNoUpdatesExist) </span><span class="cov0" title="0">{
                        klog.Infof("No new images detected, process stopping")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if err := o.mirrorMappings(cfg, mapping, sourceInsecure); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mappingPath := filepath.Join(o.Dir, mappingFile)
        if o.DryRun </span><span class="cov0" title="0">{
                if err := o.writeMappingFile(mappingPath, mapping); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return cleanup()</span>
        }

        // Create and store associations
        <span class="cov0" title="0">assocDir := filepath.Join(o.Dir, config.SourceDir)
        assocs, errs := image.AssociateLocalImageLayers(assocDir, mapping)
        if errs != nil </span><span class="cov0" title="0">{
                if err := o.processAssociationErrors(errs.Errors()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Pack the images set
        <span class="cov0" title="0">tmpBackend, err := o.Pack(ctx, prunedAssociations, assocs, &amp;meta, cfg.ArchiveSize)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ErrNoUpdatesExist) </span><span class="cov0" title="0">{
                        klog.Infof("No updates detected, process stopping")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Sync metadata from temporary backend to target backend
        <span class="cov0" title="0">if cfg.StorageConfig.IsSet() </span><span class="cov0" title="0">{
                targetBackend, err := storage.ByConfig(o.Dir, cfg.StorageConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := metadata.SyncMetadata(ctx, tmpBackend, targetBackend); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (o *MirrorOptions) diskToMirrorWrapper(ctx context.Context, cleanup cleanupFunc) error <span class="cov0" title="0">{
        // Publish from disk to registry
        // this takes care of syncing the metadata to the
        // registry backends.

        mapping, err := o.Publish(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // OCPBUGS-4959 for automation processes to end gracefully
                // when we have the same sequence - i.e nothing to do
                msqErr := &amp;ErrMirrorSequence{}
                if errors.As(err, &amp;msqErr) </span><span class="cov0" title="0">{
                        klog.Info("No diff from previous mirror (sequence is the same), nothing to do")
                        return cleanup()
                }</span>
                <span class="cov0" title="0">serr := &amp;ErrInvalidSequence{}
                if errors.As(err, &amp;serr) </span><span class="cov0" title="0">{
                        return fmt.Errorf("error during publishing, expecting imageset with prefix mirror_seq%d: %v", serr.wantSeq, err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">mappingPath := filepath.Join(o.Dir, mappingFile)
        if o.DryRun </span><span class="cov0" title="0">{
                if err := o.writeMappingFile(mappingPath, mapping); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return cleanup()</span>
        }

        <span class="cov0" title="0">if err := o.generateResults(mapping, o.OutputDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *MirrorOptions) processNestedPaths(ref *image.TypedImage) imagesource.TypedImageReference <span class="cov8" title="1">{

        if o.MaxNestedPaths &gt; 0 </span><span class="cov8" title="1">{
                dir := ref.Ref
                full := dir.RepositoryName()

                pathComponents := strings.Split(full, "/")
                if o.MaxNestedPaths &gt; 0 &amp;&amp; len(pathComponents) &gt; o.MaxNestedPaths </span><span class="cov8" title="1">{
                        lastPathComponent := strings.Join(pathComponents[o.MaxNestedPaths-1:], "-")
                        newPathComponents := pathComponents[:o.MaxNestedPaths-1]
                        newRef := dir // reinitializing newRef from dir (so that we don't loose id and tag)
                        newRef.Namespace = strings.Join(newPathComponents, "/")
                        newRef.Name = lastPathComponent
                        return imagesource.TypedImageReference{Ref: newRef, Type: ref.Type}
                }</span> else<span class="cov8" title="1"> {
                        // return original - no changes
                        return imagesource.TypedImageReference{Ref: ref.Ref, Type: ref.Type}
                }</span>
        }
        // return original - no changes
        <span class="cov0" title="0">return imagesource.TypedImageReference{Ref: ref.Ref, Type: ref.Type}</span>
}

// removeTmpDirs - utility function to delete left over temporary files
func removeTmpDirs() <span class="cov0" title="0">{
        const directory string = "/tmp/"
        var toDelete = []string{"render-unpack-*", "imageset-catalog-*"}

        for _, x := range toDelete </span><span class="cov0" title="0">{
                // instead of traversing through all the directories in /tmp
                // look for a spepcific name + wildcard
                name, err := filepath.Glob(filepath.Join(directory, x))
                if err != nil </span><span class="cov0" title="0">{
                        klog.Warningf("finding directory %s %v", x, err)
                }</span>
                // could be more than one directory
                <span class="cov0" title="0">for _, y := range name </span><span class="cov0" title="0">{
                        klog.Infof("deleting directory %s", y)
                        os.RemoveAll(y)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/containerd/containerd/errdefs"
        "github.com/containerd/containerd/remotes"
        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/empty"
        "github.com/google/go-containerregistry/pkg/v1/layout"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/joelanford/ignore"
        imgreference "github.com/openshift/library-go/pkg/image/reference"
        "github.com/openshift/oc/pkg/cli/admin/catalog"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        "github.com/operator-framework/operator-registry/alpha/action"
        "github.com/operator-framework/operator-registry/alpha/declcfg"
        "github.com/operator-framework/operator-registry/pkg/image/containerdregistry"
        "github.com/otiai10/copy"
        "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/apimachinery/pkg/util/yaml"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/operator"
        "github.com/openshift/oc-mirror/pkg/operator/diff"
)

// OperatorOptions configures either a Full or Diff mirror operation
// on a particular operator catalog image.
type OperatorOptions struct {
        *MirrorOptions

        SkipImagePin bool
        Logger       *logrus.Entry

        tmp      string
        insecure bool
}

func NewOperatorOptions(mo *MirrorOptions) *OperatorOptions <span class="cov8" title="1">{
        opts := &amp;OperatorOptions{MirrorOptions: mo}
        if mo.SourcePlainHTTP || mo.SourceSkipTLS </span><span class="cov0" title="0">{
                opts.insecure = true
        }</span>
        <span class="cov8" title="1">return opts</span>
}

/*
PlanFull plans a mirror for each catalog image in its entirety

# Arguments

• ctx: A cancellation context

• cfg: An ImageSetConfiguration that should be processed

# Returns

• image.TypedImageMapping: Any src-&gt;dest mappings found during planning. Will be nil if an error occurs, non-nil otherwise.

• error: non-nil if an error occurs, nil otherwise
*/
func (o *OperatorOptions) PlanFull(
        ctx context.Context,
        cfg v1alpha2.ImageSetConfiguration,
) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        return o.run(ctx, cfg, o.renderDCFull)
}</span>

/*
PlanDiff plans only the diff between each old and new catalog image pair

# Arguments

• ctx: A cancellation context

• cfg: An ImageSetConfiguration that should be processed

• lastRun: The mirror results of the last run

# Returns

• image.TypedImageMapping: Any src-&gt;dest mappings found during planning. Will be nil if an error occurs, non-nil otherwise.

• error: non-nil if an error occurs, nil otherwise
*/
func (o *OperatorOptions) PlanDiff(ctx context.Context, cfg v1alpha2.ImageSetConfiguration, lastRun v1alpha2.PastMirror) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        // Wrapper renderDCDiff so it satisfies the renderDCFunc function signature.
        f := func(ctx context.Context, reg *containerdregistry.Registry, ctlg v1alpha2.Operator) (*declcfg.DeclarativeConfig, v1alpha2.IncludeConfig, error) </span><span class="cov0" title="0">{
                return o.renderDCDiff(ctx, reg, ctlg, lastRun)
        }</span>
        <span class="cov0" title="0">return o.run(ctx, cfg, f)</span>
}

// complete defaults OperatorOptions.
func (o *OperatorOptions) complete() <span class="cov8" title="1">{
        if o.Dir == "" </span><span class="cov8" title="1">{
                o.Dir = "create"
        }</span>

        <span class="cov8" title="1">if o.Logger == nil </span><span class="cov8" title="1">{
                o.Logger = logrus.NewEntry(logrus.New())
        }</span>
}

/*
renderDCFunc is a function signature for rendering declarative configurations for a catalog.
Currently renderDCFull and renderDCDiff implement this function signature.

# Arguments

• context.Context: the cancellation context

• *containerdregistry.Registry: a containerd registry

• v1alpha2.Operator: operator metadata that should be processed

# Returns

• error: non-nil if an error occurs, nil otherwise
*/
type renderDCFunc func(
        context.Context,
        *containerdregistry.Registry,
        v1alpha2.Operator,
) (*declcfg.DeclarativeConfig, v1alpha2.IncludeConfig, error)

func (o *OperatorOptions) run(
        ctx context.Context,
        cfg v1alpha2.ImageSetConfiguration,
        renderDC renderDCFunc,
) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        o.complete()

        cleanup, err := o.mktempDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !o.SkipCleanup </span><span class="cov0" title="0">{
                defer cleanup()
        }</span>

        <span class="cov0" title="0">mmapping := image.TypedImageMapping{}
        for _, ctlg := range cfg.Mirror.Operators </span><span class="cov0" title="0">{
                reg, err := o.createRegistry()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating container registry: %v", err)
                }</span>

                <span class="cov0" title="0">ctlgRef, err := image.ParseReference(ctlg.Catalog)
                if err != nil </span><span class="cov0" title="0">{
                        reg.Destroy()
                        return nil, err
                }</span>
                <span class="cov0" title="0">targetName, err := ctlg.GetUniqueName()
                if err != nil </span><span class="cov0" title="0">{
                        reg.Destroy()
                        return nil, err
                }</span>
                <span class="cov0" title="0">if ctlg.IsFBCOCI() </span><span class="cov0" title="0">{
                        targetName = v1alpha2.OCITransportPrefix + "//" + targetName
                }</span>
                <span class="cov0" title="0">targetCtlg, err := image.ParseReference(targetName)
                if err != nil </span><span class="cov0" title="0">{
                        reg.Destroy()
                        return nil, fmt.Errorf("error parsing catalog: %v", err)
                }</span>

                // Render the catalog to mirror into a declarative config.
                <span class="cov0" title="0">dc, ic, err := renderDC(ctx, reg, ctlg)
                if err != nil </span><span class="cov0" title="0">{
                        reg.Destroy()
                        return nil, o.checkValidationErr(err)
                }</span>

                <span class="cov0" title="0">ctlgSrcDir := filepath.Join(o.Dir, config.SourceDir, config.CatalogsDir, targetCtlg.Ref.Registry, targetCtlg.Ref.Namespace, targetCtlg.Ref.Name)
                if targetCtlg.Ref.ID != "" </span><span class="cov0" title="0">{
                        ctlgSrcDir = filepath.Join(ctlgSrcDir, targetCtlg.Ref.ID)
                }</span> else<span class="cov0" title="0"> if targetCtlg.Ref.Tag != "" </span><span class="cov0" title="0">{
                        ctlgSrcDir = filepath.Join(ctlgSrcDir, targetCtlg.Ref.Tag)
                }</span>
                <span class="cov0" title="0">err = extractOPMAndCache(ctx, ctlgRef, ctlgSrcDir, o.SourceSkipTLS)
                if err != nil </span><span class="cov0" title="0">{
                        reg.Destroy()
                        return nil, fmt.Errorf("unable to extract OPM binary from catalog %s: %v", targetName, err)
                }</span>

                <span class="cov0" title="0">mappings, err := o.plan(ctx, dc, ic, ctlgRef, targetCtlg)
                if err != nil </span><span class="cov0" title="0">{
                        reg.Destroy()
                        return nil, err
                }</span>
                <span class="cov0" title="0">mmapping.Merge(mappings)
                reg.Destroy()</span>
        }

        <span class="cov0" title="0">return mmapping, nil</span>
}

func (o *OperatorOptions) mktempDir() (func(), error) <span class="cov0" title="0">{
        o.tmp = filepath.Join(o.Dir, fmt.Sprintf("operators.%d", time.Now().Unix()))
        return func() </span><span class="cov0" title="0">{
                if err := os.RemoveAll(o.tmp); err != nil </span><span class="cov0" title="0">{
                        o.Logger.Error(err)
                }</span>
        }, os.MkdirAll(o.tmp, os.ModePerm)
}

func (o *OperatorOptions) createRegistry() (*containerdregistry.Registry, error) <span class="cov0" title="0">{
        cacheDir, err := os.MkdirTemp("", "imageset-catalog-registry-")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logger := logrus.New()
        logger.SetOutput(io.Discard)
        nullLogger := logrus.NewEntry(logger)

        return containerdregistry.NewRegistry(
                containerdregistry.WithCacheDir(cacheDir),
                containerdregistry.SkipTLSVerify(o.SourceSkipTLS),
                containerdregistry.WithPlainHTTP(o.SourcePlainHTTP),
                // The containerd registry impl is somewhat verbose, even on the happy path,
                // so discard all logger logs. Any important failures will be returned from
                // registry methods and eventually logged as fatal errors.
                containerdregistry.WithLog(nullLogger),
        )</span>
}

// renderDCFull renders data in ctlg into a declarative config for o.Full().
// Satisfies the renderDCFunc function signature.
func (o *OperatorOptions) renderDCFull(
        ctx context.Context,
        reg *containerdregistry.Registry,
        ctlg v1alpha2.Operator,
) (dc *declcfg.DeclarativeConfig, ic v1alpha2.IncludeConfig, err error) <span class="cov0" title="0">{

        hasInclude := len(ctlg.IncludeConfig.Packages) != 0
        // Render the full catalog if neither HeadsOnly or IncludeConfig are specified.
        full := !ctlg.IsHeadsOnly() &amp;&amp; !hasInclude

        catLogger := o.Logger.WithField("catalog", ctlg.Catalog)
        ctlgRef := ctlg.Catalog //applies for all docker-v2 remote catalogs
        if ctlg.IsFBCOCI() </span><span class="cov0" title="0">{
                // initialize path where we assume the catalog config dir is &lt;current working directory&gt;/olm_artifacts/&lt;repo&gt;/&lt;config folder&gt;
                var ok bool
                if ctlgRef, ok = o.operatorCatalogToFullArtifactPath[ctlg.Catalog]; !ok </span><span class="cov0" title="0">{
                        err = fmt.Errorf("unable to obtain artifact path for %s while performing full render", ctlg.Catalog)
                        return dc, ic, err
                }</span>
        }
        <span class="cov0" title="0">if full </span><span class="cov0" title="0">{
                // Mirror the entire catalog.
                dc, err = action.Render{
                        Registry: reg,
                        Refs:     []string{ctlgRef}, // /home/skhoury/oc-catalog2 =&gt; configs dir olm_artifacts/oci-catalog2/configs
                }.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return dc, ic, err
                }</span>
        } else<span class="cov0" title="0"> {
                // Generate and mirror a heads-only diff using only the catalog as a new ref.
                dic, derr := ctlg.IncludeConfig.ConvertToDiffIncludeConfig()
                if derr != nil </span><span class="cov0" title="0">{
                        return dc, ic, derr
                }</span>
                <span class="cov0" title="0">dc, err = diff.Diff{
                        Registry:         reg,
                        NewRefs:          []string{ctlgRef},
                        Logger:           catLogger,
                        IncludeConfig:    dic,
                        SkipDependencies: ctlg.SkipDependencies,
                        HeadsOnly:        ctlg.IsHeadsOnly(),
                }.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return dc, ic, err
                }</span>

                <span class="cov0" title="0">var icManager operator.IncludeConfigManager
                if hasInclude </span><span class="cov0" title="0">{
                        icManager = operator.NewPackageStrategy(ctlg.IncludeConfig)
                }</span> else<span class="cov0" title="0"> {
                        icManager = operator.NewCatalogStrategy()
                }</span>

                // Render ic for incorporation into the metadata
                <span class="cov0" title="0">ic, err = icManager.ConvertDCToIncludeConfig(*dc)
                if err != nil </span><span class="cov0" title="0">{
                        return dc, ic, fmt.Errorf("error converting declarative config to include config: %v", err)
                }</span>

                <span class="cov0" title="0">if err := o.verifyDC(dic, dc); err != nil </span><span class="cov0" title="0">{
                        return dc, ic, err
                }</span>
        }

        <span class="cov0" title="0">return dc, ic, nil</span>
}

// renderDCDiff renders data in ctlg into a declarative config for o.PlanDiff().
// This produces the declarative config that will be used to determine
// differential images.
func (o *OperatorOptions) renderDCDiff(
        ctx context.Context,
        reg *containerdregistry.Registry,
        ctlg v1alpha2.Operator,
        lastRun v1alpha2.PastMirror,
) (dc *declcfg.DeclarativeConfig, ic v1alpha2.IncludeConfig, err error) <span class="cov0" title="0">{
        prevCatalog := make(map[string]v1alpha2.OperatorMetadata, len(lastRun.Operators))
        for _, pastCtlg := range lastRun.Operators </span><span class="cov0" title="0">{
                prevCatalog[pastCtlg.Catalog] = pastCtlg
        }</span>

        <span class="cov0" title="0">uniqueName, err := ctlg.GetUniqueName()
        if err != nil </span><span class="cov0" title="0">{
                return dc, ic, err
        }</span>
        <span class="cov0" title="0">prev, found := prevCatalog[uniqueName]

        // The catalog is new or just need to mirror the full
        // catalog or channels.
        if !found || !ctlg.IsHeadsOnly() </span><span class="cov0" title="0">{
                return o.renderDCFull(ctx, reg, ctlg)
        }</span>

        <span class="cov0" title="0">hasInclude := len(ctlg.IncludeConfig.Packages) != 0
        // Process the catalog at heads-only or specified
        // packages at heads-only
        catalogHeadsOnly := ctlg.IsHeadsOnly() &amp;&amp; !hasInclude
        includeWithHeadsOnly := ctlg.IsHeadsOnly() &amp;&amp; hasInclude

        // Generate a heads-only diff using the catalog as a new ref and previous bundle information.
        catLogger := o.Logger.WithField("catalog", ctlg.Catalog)

        ctlgRef := ctlg.Catalog //applies for all docker-v2 remote catalogs
        if ctlg.IsFBCOCI() </span><span class="cov0" title="0">{
                var ok bool
                if ctlgRef, ok = o.operatorCatalogToFullArtifactPath[ctlg.Catalog]; !ok </span><span class="cov0" title="0">{
                        err = fmt.Errorf("unable to obtain artifact path for %s while performing diff render", ctlg.Catalog)
                        return dc, ic, err
                }</span>
        }
        <span class="cov0" title="0">a := diff.Diff{
                Registry:         reg,
                NewRefs:          []string{ctlgRef},
                Logger:           catLogger,
                SkipDependencies: ctlg.SkipDependencies,
        }

        // If a previous catalog is found, reconcile the
        // previously stored IncludeConfig with the current catalog information
        // to make sure the bundles still exist. This causes the declarative config
        // to be rendered once to get the full information and then a second time to
        // get the final copy. This will help determine what bundles have been pruned.
        var icManager operator.IncludeConfigManager
        switch </span>{
        case catalogHeadsOnly:<span class="cov0" title="0">
                icManager = operator.NewCatalogStrategy()
                dc, err = action.Render{
                        Registry: reg,
                        Refs:     []string{ctlgRef},
                }.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return dc, ic, err
                }</span>

        case includeWithHeadsOnly:<span class="cov0" title="0">
                icManager = operator.NewPackageStrategy(ctlg.IncludeConfig)
                // Must set the current
                // diff include configuration to get the full
                // channels before recalculating.
                dic, err := ctlg.IncludeConfig.ConvertToDiffIncludeConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return dc, ic, err
                }</span>
                <span class="cov0" title="0">a.IncludeConfig = dic
                a.HeadsOnly = false
                dc, err = a.Run(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return dc, ic, err
                }</span>
        }

        // Update the IncludeConfig and diff include configuration based on previous mirrored bundles
        // and the current catalog.
        <span class="cov0" title="0">ic, err = icManager.UpdateIncludeConfig(*dc, prev.IncludeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return dc, ic, fmt.Errorf("error updating include config: %v", err)
        }</span>
        <span class="cov0" title="0">dic, err := ic.ConvertToDiffIncludeConfig()
        if err != nil </span><span class="cov0" title="0">{
                return dc, ic, fmt.Errorf("error during include config conversion to declarative config: %v", err)
        }</span>

        // Set up action diff for final declarative config rendering
        <span class="cov0" title="0">a.HeadsOnly = true
        a.IncludeConfig = dic
        dc, err = a.Run(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return dc, ic, err
        }</span>

        <span class="cov0" title="0">if err := o.verifyDC(dic, dc); err != nil </span><span class="cov0" title="0">{
                return dc, ic, err
        }</span>

        <span class="cov0" title="0">return dc, ic, nil</span>
}

// verifyDC verifies the declarative config and that each of the requested operator packages were
// found and added to the DeclarativeConfig.
func (o *OperatorOptions) verifyDC(dic diff.DiffIncludeConfig, dc *declcfg.DeclarativeConfig) error <span class="cov8" title="1">{
        o.Logger.Debug("DiffIncludeConfig: ", dic)
        o.Logger.Debug("DeclarativeConfig: ", dc)

        // Converting the dc to the model results in running
        // model validations. This checks default channels and
        // replace chain.
        if _, err := declcfg.ConvertToModel(*dc); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dcMap := make(map[string]bool)
        // Load the declarative config packages into a map
        for _, dcpkg := range dc.Packages </span><span class="cov8" title="1">{
                dcMap[dcpkg.Name] = true
        }</span>

        <span class="cov8" title="1">for _, pkg := range dic.Packages </span><span class="cov8" title="1">{
                klog.V(2).Infof("Checking for package: %s", pkg)

                if !dcMap[pkg.Name] </span><span class="cov8" title="1">{
                        // The operator package wasn't found. Log the error and continue on.
                        o.Logger.Errorf("Operator %s was not found, please check name, minVersion, maxVersion, and channels in the config file.", pkg.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

/*
plan determines the source -&gt; destination mapping for images associated with the provided catalog

# Arguments

• ctx: A cancellation context

• dc: the declarative config to use during processing

• ic: the include config associated with the dc argument

• ctlgRef: this is the source catalog reference

• targetCtlg: this is the target catalog reference

# Return

• image.TypedImageMapping: the source -&gt; destination image mapping for images found during planning

• error: non-nil if an error occurs, nil otherwise
*/
func (o *OperatorOptions) plan(ctx context.Context, dc *declcfg.DeclarativeConfig, ic v1alpha2.IncludeConfig, ctlgRef, targetCtlg image.TypedImageReference) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        o.Logger.Debugf("Mirroring catalog %q bundle and related images", ctlgRef.Ref.Exact())

        opts, err := o.newMirrorCatalogOptions(ctlgRef.Ref, filepath.Join(o.Dir, config.SourceDir))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !o.SkipImagePin </span><span class="cov0" title="0">{
                resolver, err := containerdregistry.NewResolver("", o.SourceSkipTLS, o.SourcePlainHTTP, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating image resolver: %v", err)
                }</span>
                <span class="cov0" title="0">if err := o.pinImages(ctx, dc, resolver); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error pinning images in catalog %s: %v", ctlgRef, err)
                }</span>
        }
        <span class="cov0" title="0">indexDir, err := o.writeConfigs(dc, ic, targetCtlg.Ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mappingFile := filepath.Join(opts.ManifestDir, mappingFile) // re-read mappung from disk

        if ctlgRef.Type != image.DestinationOCI </span><span class="cov0" title="0">{
                // Create the mapping file, but don't mirror quite yet.
                // Since the file-based catalog (declarative config) needs to be rebuilt
                // after rendering with the existing image in the publishing step,
                // we can just build the new image once then.
                opts.ManifestOnly = true
                opts.ImageMirrorer = catalog.ImageMirrorerFunc(func(mapping map[imagesource.TypedImageReference]imagesource.TypedImageReference) error </span><span class="cov0" title="0">{
                        return nil
                }</span>)
                <span class="cov0" title="0">opts.IndexPath = indexDir

                opts.IndexExtractor = catalog.IndexExtractorFunc(func(imagesource.TypedImageReference) (string, error) </span><span class="cov0" title="0">{
                        o.Logger.Debugf("returning index dir in extractor: %s", opts.IndexPath)
                        return opts.IndexPath, nil
                }</span>)

                <span class="cov0" title="0">opts.RelatedImagesParser = catalog.RelatedImagesParserFunc(parseRelatedImages)

                opts.MaxICSPSize = icspSizeLimit
                opts.MaxIDMSSize = idmsSizeLimit
                opts.SourceRef = imagesource.TypedImageReference{
                        Ref:  ctlgRef.Ref,
                        Type: ctlgRef.Type,
                }
                opts.DestRef = imagesource.TypedImageReference{
                        Type: imagesource.DestinationFile,
                }

                if err := opts.Validate(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid catalog mirror options: %v", err)
                }</span>

                <span class="cov0" title="0">if err := opts.Run(); err != nil </span><span class="cov0" title="0">{ // mappings.txt
                        return nil, fmt.Errorf("error running catalog mirror: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                relatedImages, err := getRelatedImages(*dc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // place related images into the workspace - aka mirrorToDisk
                // TODO this should probably be done only if artifacts have not been copied
                <span class="cov0" title="0">var syncMapResult sync.Map
                start := time.Now()
                g, ctx := errgroup.WithContext(ctx)

                // set the destination for the related images mirroring
                // Case of MirrorToMirror workflow, mirror to o.ToMirror
                targetLocation := o.ToMirror

                mirrorToDisk := len(o.OutputDir) &gt; 0 &amp;&amp; o.From == ""
                mirrorToMirror := len(o.ToMirror) &gt; 0 &amp;&amp; len(o.ConfigPath) &gt; 0
                // Case of MirrorToDisk workflow, the location is on disk, and should be under
                // a folder structure with catalogNamespace/catalogName
                // as in vendor/github.com/openshift/oc/pkg/cli/admin/catalog/mirrorer.go, function mount.
                // for the case of mirrorToDisk, it's as if we wanted to call mount with dest=file:// and
                // maxComponents=0
                if mirrorToDisk &amp;&amp; !mirrorToMirror </span><span class="cov0" title="0">{
                        targetLocation = filePrefix
                        if ctlgRef.Ref.Namespace != "" </span><span class="cov0" title="0">{
                                targetLocation += ctlgRef.Ref.Namespace
                        }</span>
                        <span class="cov0" title="0">if ctlgRef.Ref.Name != "" </span><span class="cov0" title="0">{
                                targetLocation += "/" + ctlgRef.Ref.Name
                        }</span>
                }

                // create mappings for the related images that will moved from the workspace to the final destination
                <span class="cov0" title="0">for _, i := range relatedImages </span><span class="cov0" title="0">{
                        // avoid closure problems by making a copy of i
                        copyofI := i
                        g.Go(func() error </span><span class="cov0" title="0">{
                                // intentionally removed the usernamespace from the call, because mirror.go is going to add it back!!
                                err := o.addRelatedImageToMapping(ctx, &amp;syncMapResult, copyofI, targetLocation)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        })
                }
                // if error occurs in one of the go routines, get the first error and bail out
                <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">duration := time.Since(start)
                klog.Infof("%d related images processed in %s", len(relatedImages), duration)

                result := image.TypedImageMapping{}
                syncMapResult.Range(func(key, value any) bool </span><span class="cov0" title="0">{
                        source := key.(image.TypedImage)
                        destination := value.(image.TypedImage)
                        result[source] = destination
                        // always continue iteration
                        return true
                }</span>)

                <span class="cov0" title="0">if err := o.writeMappingFile(mappingFile, result); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">mappings, err := image.ReadImageMapping(mappingFile, "=", v1alpha2.TypeOperatorBundle)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Remove the catalog image from mappings we are going to transfer this
        // using an OCI layout.
        <span class="cov0" title="0">var ctlgImg image.TypedImage
        if ctlgRef.Type == "oci" </span><span class="cov0" title="0">{
                ctlgImg, err = image.ParseTypedImage(ctlgRef.OCIFBCPath, v1alpha2.TypeOperatorBundle)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                ctlgImg, err = image.ParseTypedImage(ctlgRef.Ref.Exact(), v1alpha2.TypeOperatorBundle)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">mappings.Remove(ctlgImg)
        // Write catalog OCI layout file to src so it is included in the archive
        // at a path unique to the image.
        if ctlgRef.Type != image.DestinationOCI </span><span class="cov0" title="0">{
                if err := o.writeLayout(ctx, ctlgRef.Ref, targetCtlg.Ref); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                // ctlgDir is the result of converting targetCtlg.Ref to &lt;repoPath&gt; example: foo/bar/baz/image/sha256:XXXX
                ctlgDir, err := operator.GenerateCatalogDir(targetCtlg.Ref)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // layoutDir looks like &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/layout
                // this will be the destination of the copy action that follows
                <span class="cov0" title="0">layoutDir := filepath.Join(o.Dir, config.SourceDir, config.CatalogsDir, ctlgDir, config.LayoutsDir)
                if err := os.MkdirAll(layoutDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error catalog layout dir: %v", err)
                }</span>
                // obtain the source directory for the OCI content
                <span class="cov0" title="0">ociSourcePath := v1alpha2.TrimProtocol(ctlgRef.OCIFBCPath)

                // Now copy the individual components of the source OCI source to its layout dir destination.
                // This is done to ensure that files/folders that are not part of the OCI layout specification
                // are not copied.
                if err := copyOCILayoutFileOrFolder(ociSourcePath, layoutDir, "oci-layout"); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := copyOCILayoutFileOrFolder(ociSourcePath, layoutDir, "index.json"); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := copyOCILayoutFileOrFolder(ociSourcePath, layoutDir, "blobs"); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Remove catalog namespace prefix from each mapping's destination, which is added by opts.Run().
        <span class="cov0" title="0">for srcRef, dstRef := range mappings </span><span class="cov0" title="0">{
                newRepoName := strings.TrimPrefix(dstRef.Ref.RepositoryName(), ctlgRef.Ref.RepositoryName())
                newRepoName = strings.TrimPrefix(newRepoName, "/")
                tmpRef, err := imgreference.Parse(newRepoName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">dstRef.Ref.Namespace = tmpRef.Namespace
                dstRef.Ref.Name = tmpRef.Name
                mappings[srcRef] = dstRef</span>
        }

        <span class="cov0" title="0">return mappings, validateMapping(*dc, mappings)</span>
}

/*
copyOCILayoutFileOrFolder will copy a file or folder that belongs to a oci layout

# Arguments

• sourcePath: the source directory

• destinationPath: the destination directory

• fileOrDir: the file or directory within the source that will be copied to the destination

# Returns

• error: non nil if file/folder copy failed, nil otherwise
*/
func copyOCILayoutFileOrFolder(sourcePath, destinationPath, fileOrDir string) error <span class="cov0" title="0">{
        if err := copy.Copy(filepath.Join(sourcePath, fileOrDir), filepath.Join(destinationPath, fileOrDir)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error copying oci fbc catalog to layout directory: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

/*
validateMapping will search for bundle and related images in mapping
and log a warning if an image does not exist and will not be mirrored.

# Arguments

• dc: the catalog content that contains bundle and related images

• mapping: the source/destination mapping to search through looking for a match based on the catalog content

# Returns

• error: this should only produce an error if the bundle or related images in the catalog could
not be parsed
*/
func validateMapping(dc declcfg.DeclarativeConfig, mapping image.TypedImageMapping) error <span class="cov8" title="1">{

        /*
                The source image in the mapping could have been modified from the value found in the catalog
                in some circumstances. For example, when using registries.conf we might find an image in a mirror
                and use that for the mapping rather than the original location defined in the catalog.

                The docker image format could be one of these variants:

                        &lt;registry&gt;/&lt;namespace&gt;/name
                        &lt;registry&gt;/&lt;namespace&gt;/name:tag
                        &lt;registry&gt;/&lt;namespace&gt;/name@digest
                        &lt;registry&gt;/&lt;namespace&gt;/name:tag@digest

                Because the registry and namespace portion of the docker reference *could* be different, not
                only do we need to check for "exact matches", we also need to attempt to find a match
                based on the name and one of the tag / digest variants above to get a match. If none of those
                variants match than we need to add a error message.
        */

        // getImageList will produce a list of images formatted as described above.
        // It returns a list for consistent ordering from most likely to least likely
        // to be encountered, to allow for early search termination.
        getImageList := func(sourceImage image.TypedImage) (result []string) </span><span class="cov8" title="1">{
                // handle full reference first since this is the (most likely condition)
                fullRef := sourceImage.Ref.Exact()
                result = append(result, fullRef)

                // depending on the number of components we could have one or more slashes
                // and in that case get the last component
                sourceImageName := sourceImage.Ref.Name
                if i := strings.LastIndex(sourceImageName, "/"); i != -1 </span><span class="cov8" title="1">{
                        sourceImageName = sourceImageName[i+1:]
                }</span>

                // handle name with id
                <span class="cov8" title="1">if sourceImage.Ref.ID != "" </span><span class="cov8" title="1">{
                        nameId := fmt.Sprintf("%s@%s", sourceImageName, sourceImage.Ref.ID)
                        result = append(result, nameId)
                }</span>

                // handle name with tag
                <span class="cov8" title="1">if sourceImage.Ref.Tag != "" </span><span class="cov8" title="1">{
                        nameTag := fmt.Sprintf("%s:%s", sourceImageName, sourceImage.Ref.Tag)
                        result = append(result, nameTag)
                }</span>

                // handle just the name
                <span class="cov8" title="1">result = append(result, sourceImageName)

                // handle name with tag and id (least likely condition)
                if sourceImage.Ref.Tag != "" &amp;&amp; sourceImage.Ref.ID != "" </span><span class="cov8" title="1">{
                        nameTagID := fmt.Sprintf("%s:%s@%s", sourceImageName, sourceImage.Ref.Tag, sourceImage.Ref.ID)
                        result = append(result, nameTagID)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // first convert the source portion of the mapping into a form suitable for comparison,
        // but only do so for bundle types... ignore all others
        <span class="cov8" title="1">sourceSet := map[string]struct{}{}
        for sourceImage := range mapping </span><span class="cov8" title="1">{
                for _, image := range getImageList(sourceImage) </span><span class="cov8" title="1">{
                        sourceSet[image] = struct{}{}
                }</span>
        }

        // validateFunc performs the search in the sourceSet looking for the provided img
        <span class="cov8" title="1">validateFunc := func(img string) error </span><span class="cov8" title="1">{
                ref, err := image.ParseTypedImage(img, v1alpha2.TypeOperatorBundle)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // attempt to find a match
                <span class="cov8" title="1">matchFound := false
                images := getImageList(ref)
                for _, image := range images </span><span class="cov8" title="1">{
                        if _, ok := sourceSet[image]; ok </span><span class="cov8" title="1">{
                                // bail out on search since we found what we're looking for
                                matchFound = true
                                break</span>
                        }
                }

                // if no match warn user
                <span class="cov8" title="1">if !matchFound </span><span class="cov8" title="1">{
                        klog.Warningf("image %s is not included in mapping", img)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // for all bundle/related images preform the validation against the source image in the mapping
        <span class="cov8" title="1">var errs []error
        for _, b := range dc.Bundles </span><span class="cov8" title="1">{
                if err := validateFunc(b.Image); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("bundle %q image %q: %v", b.Name, b.Image, err))
                        continue</span>
                }
                <span class="cov8" title="1">for _, relatedImg := range b.RelatedImages </span><span class="cov8" title="1">{
                        if err := validateFunc(relatedImg.Image); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("bundle %q related image %q: %v", b.Name, relatedImg.Name, err))
                                continue</span>
                        }
                }
        }
        <span class="cov8" title="1">return utilerrors.NewAggregate(errs)</span>
}

// pinImages resolves every image in dc to it's canonical name (includes digest).
func (o *OperatorOptions) pinImages(ctx context.Context, dc *declcfg.DeclarativeConfig, resolver remotes.Resolver) (err error) <span class="cov8" title="1">{

        // Check that declarative config is not nil
        // to avoid panics
        if err := validate(dc); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Instead of returning an error, just log it.
        <span class="cov8" title="1">isSkipErr := func(err error) bool </span><span class="cov8" title="1">{
                return o.ContinueOnError || (o.SkipMissing &amp;&amp; errors.Is(err, errdefs.ErrNotFound))
        }</span>

        <span class="cov8" title="1">var errs []error
        for i, b := range dc.Bundles </span><span class="cov8" title="1">{

                if !image.IsImagePinned(b.Image) </span><span class="cov8" title="1">{
                        klog.Warningf("bundle %s: pinning bundle image %s to digest", b.Name, b.Image)

                        if !image.IsImageTagged(b.Image) </span><span class="cov8" title="1">{
                                klog.Warningf("bundle %s: bundle image tag not set", b.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">if dc.Bundles[i].Image, err = image.ResolveToPin(ctx, resolver, b.Image); err != nil </span><span class="cov8" title="1">{
                                if isSkipErr(err) </span><span class="cov8" title="1">{
                                        klog.Warningf("skipping bundle %s image %s resolve error: %v", b.Name, b.Image, err)
                                }</span> else<span class="cov8" title="1"> {
                                        errs = append(errs, err)
                                }</span>
                        }
                }
                <span class="cov8" title="1">for j, ri := range b.RelatedImages </span><span class="cov8" title="1">{
                        if !image.IsImagePinned(ri.Image) </span><span class="cov8" title="1">{
                                klog.Warningf("bundle %s: pinning related image %s to digest", ri.Name, ri.Image)

                                if !image.IsImageTagged(ri.Image) </span><span class="cov0" title="0">{
                                        klog.Warningf("bundle %s: related image tag not set", b.Name)
                                        continue</span>
                                }

                                <span class="cov8" title="1">if b.RelatedImages[j].Image, err = image.ResolveToPin(ctx, resolver, ri.Image); err != nil </span><span class="cov8" title="1">{
                                        if isSkipErr(err) </span><span class="cov8" title="1">{
                                                klog.Warningf("skipping bundle %s related image %s=%s resolve error: %v", b.Name, ri.Name, ri.Image, err)
                                        }</span> else<span class="cov8" title="1"> {
                                                errs = append(errs, err)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return utilerrors.NewAggregate(errs)</span>
}

/*
writeLayout creates OCI layout on the file system by pulling the image from the ctlgRef argument

# Arguments

• ctx: A cancellation context

• ctlgRef: this is the source catalog reference

• targetCtlg: this is the target catalog reference

# Return

• error: non-nil if an error occurs, nil otherwise
*/
func (o *OperatorOptions) writeLayout(ctx context.Context, ctlgRef, targetCtlg imgreference.DockerImageReference) error <span class="cov0" title="0">{

        // Write catalog OCI layout file to src so it is included in the archive
        // at a path unique to the image.

        // ctlgDir is the result of converting targetCtlg to &lt;repoPath&gt; example: foo.io/bar/baz/image/sha256:XXXX
        ctlgDir, err := operator.GenerateCatalogDir(targetCtlg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // layoutDir looks like &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/layout
        <span class="cov0" title="0">layoutDir := filepath.Join(o.Dir, config.SourceDir, config.CatalogsDir, ctlgDir, config.LayoutsDir)
        if err := os.MkdirAll(layoutDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error catalog layout dir: %v", err)
        }</span>

        <span class="cov0" title="0">o.Logger.Debugf("writing catalog %q layout to %s", ctlgRef.Exact(), layoutDir)

        ref, err := name.ParseReference(ctlgRef.Exact(), getNameOpts(o.insecure)...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">desc, err := remote.Get(ref, getRemoteOpts(ctx, o.insecure)...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if desc.MediaType.IsImage() </span><span class="cov0" title="0">{
                layoutPath, err := layout.Write(layoutDir, empty.Index)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating OCI layout: %v", err)
                }</span>
                <span class="cov0" title="0">img, err := desc.Image()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // try to get the config file... does it have os/arch values?
                <span class="cov0" title="0">configFile, err := img.ConfigFile()
                if err != nil || configFile == nil || (configFile.Architecture == "" &amp;&amp; configFile.OS == "") </span><span class="cov0" title="0">{
                        o.Logger.Debugf("could not determine platform for catalog image %s, using linux/amd64 instead", ref.Name())
                        // Default to amd64 architecture with no multi-arch image since we can't know for sure what this image is
                        if err := layoutPath.AppendImage(img, layout.WithPlatform(v1.Platform{OS: "linux", Architecture: "amd64"})); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                // set the correct platform while appending the image
                <span class="cov0" title="0">if err := layoutPath.AppendImage(img, layout.WithPlatform(v1.Platform{OS: configFile.OS, Architecture: configFile.Architecture, Variant: configFile.Variant})); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        } else<span class="cov0" title="0"> {
                idx, err := desc.ImageIndex()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err = layout.Write(layoutDir, idx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating OCI layout: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

/*
writeConfigs will write the declarative and include configuration to disk in a directory generated by the catalog name.

# Arguments

• dc: the declarative config to use during processing

• ic: the include config associated with the dc argument

• targetCtlg: this is the target catalog reference

# Return

• string: the index directory

• error: non-nil if an error occurs, nil otherwise
*/
func (o *OperatorOptions) writeConfigs(dc *declcfg.DeclarativeConfig, ic v1alpha2.IncludeConfig, targetCtlg imgreference.DockerImageReference) (string, error) <span class="cov0" title="0">{

        // Write catalog declarative config file to src so it is included in the archive
        // at a path unique to the image.

        // ctlgDir is the result of converting targetCtlg to &lt;repoPath&gt; example: foo.io/bar/baz/image/sha256:XXXX
        ctlgDir, err := operator.GenerateCatalogDir(targetCtlg)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // catalogBasePath looks like &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;
        <span class="cov0" title="0">catalogBasePath := filepath.Join(o.Dir, config.SourceDir, config.CatalogsDir, ctlgDir)
        // indexDir looks like &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/index
        indexDir := filepath.Join(catalogBasePath, config.IndexDir)
        if err := os.MkdirAll(indexDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating diff index dir: %v", err)
        }</span>
        // catalogIndexPath looks like &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/index/index.json
        <span class="cov0" title="0">catalogIndexPath := filepath.Join(indexDir, "index.json")

        o.Logger.Debugf("writing target catalog %q diff to %s", targetCtlg.Exact(), catalogIndexPath)

        indexFile, err := os.Create(catalogIndexPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating diff index file: %v", err)
        }</span>

        // includeConfigPath looks like &lt;some path&gt;/src/catalogs/&lt;repoPath&gt;/include-config.gob
        <span class="cov0" title="0">includeConfigPath := filepath.Join(catalogBasePath, config.IncludeConfigFile)

        o.Logger.Debugf("writing target catalog %q include config to %s", targetCtlg.Exact(), includeConfigPath)

        includeFile, err := os.Create(includeConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating include config file: %v", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := includeFile.Close(); err != nil </span><span class="cov0" title="0">{
                        o.Logger.Error(err)
                }</span>
                <span class="cov0" title="0">if err := indexFile.Close(); err != nil </span><span class="cov0" title="0">{
                        o.Logger.Error(err)
                }</span>
        }()

        <span class="cov0" title="0">if err := declcfg.WriteJSON(*dc, indexFile); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error writing diff catalog: %v", err)
        }</span>
        <span class="cov0" title="0">if err := ic.Encode(includeFile); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error writing include config file: %v", err)
        }</span>

        <span class="cov0" title="0">return indexDir, nil</span>
}

func (o *OperatorOptions) newMirrorCatalogOptions(ctlgRef imgreference.DockerImageReference, fileDir string) (*catalog.MirrorCatalogOptions, error) <span class="cov0" title="0">{

        opts := catalog.NewMirrorCatalogOptions(o.IOStreams)
        opts.DryRun = o.DryRun
        opts.FileDir = fileDir
        opts.MaxPathComponents = 2

        // Create the manifests dir in tmp so it gets cleaned up if desired.
        // TODO(estroz): if the CLI is meant to be re-entrant, check if this file exists
        // and use it directly if so.
        opts.ManifestDir = filepath.Join(o.tmp, fmt.Sprintf("manifests-%s", ctlgRef.Name))
        if err := os.MkdirAll(opts.ManifestDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating manifests dir: %v", err)
        }</span>
        <span class="cov0" title="0">o.Logger.Debugf("running mirrorer with manifests dir %s", opts.ManifestDir)

        opts.SecurityOptions.Insecure = o.insecure

        regctx, err := image.NewContext(o.SkipVerification)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating registry context: %v", err)
        }</span>
        <span class="cov0" title="0">opts.SecurityOptions.CachedContext = regctx

        return opts, nil</span>
}

// Copied from https://github.com/openshift/oc/blob/4df50be4d929ce036c4f07893c07a1782eadbbba/pkg/cli/admin/catalog/mirror.go#L449-L503
// Hoping this can be temporary, and `oc adm mirror catalog` libs support index.yaml direct mirroring.

type declcfgMeta struct {
        Schema        string                `json:"schema"`
        Image         string                `json:"image"`
        RelatedImages []declcfgRelatedImage `json:"relatedImages,omitempty"`
}

type declcfgRelatedImage struct {
        Name  string `json:"name"`
        Image string `json:"image"`
}

func parseRelatedImages(root string) (map[string]struct{}, error) <span class="cov0" title="0">{
        rootFS := os.DirFS(root)

        matcher, err := ignore.NewMatcher(rootFS, ".indexignore")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">relatedImages := map[string]struct{}{}
        if err := fs.WalkDir(rootFS, ".", func(path string, entry fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if entry.IsDir() || matcher.Match(path, false) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">f, err := rootFS.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer f.Close()
                dec := yaml.NewYAMLOrJSONDecoder(f, 4096)
                for </span><span class="cov0" title="0">{
                        var blob declcfgMeta
                        if err := dec.Decode(&amp;blob); err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov0" title="0">relatedImages[blob.Image] = struct{}{}
                        for _, ri := range blob.RelatedImages </span><span class="cov0" title="0">{
                                relatedImages[ri.Image] = struct{}{}
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">delete(relatedImages, "")
        return relatedImages, nil</span>
}

// validate declarative config
func validate(dc *declcfg.DeclarativeConfig) error <span class="cov8" title="1">{
        if dc == nil </span><span class="cov8" title="1">{
                return errors.New("bug: nil declarative config")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// checkError will check validation errors
// from operator registry and return a modified
// error messages for mirror usage
// FIXME(jpower432): Checking against the errors string could be an issue since
// this is depending on the strings returned from `opm validate`. It would be better to propose that
// the validation error are exposed here https://github.com/operator-framework/operator-registry/blob/master/alpha/model/error.go
// and adds structure errors that return package and channels information.
func (o *OperatorOptions) checkValidationErr(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(o.ErrOut, "\nThe rendered catalog is invalid.")
        // handle known error causes
        var validationMsg string
        switch </span>{
        case strings.Contains(err.Error(), "channel must contain at least one bundle"):<span class="cov0" title="0">
                validationMsg = "\nPlease check the minVersion, maxVersion, and default channel for each invalid package."</span>
        case strings.Contains(err.Error(), "multiple channel heads found in graph"):<span class="cov0" title="0">
                validationMsg = "\nPlease check the minVersion and maxVersion for each invalid channel."</span>
        }
        <span class="cov0" title="0">fmt.Fprintln(o.ErrOut, "\nRun \"oc-mirror list operators --catalog CATALOG-NAME --package PACKAGE-NAME\" for more information.")
        fmt.Fprintln(o.ErrOut, validationMsg)
        return err</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package mirror

import (
        "context"
        "os"
        "os/signal"
        "sync"
        "syscall"

        "github.com/spf13/pflag"

        "github.com/openshift/oc-mirror/pkg/cli"
)

type MirrorOptions struct {
        *cli.RootOptions
        OutputDir                  string // directory path, whose value is dependent on how oc mirror was invoked
        ConfigPath                 string // Path to imageset configuration file
        SkipImagePin               bool   // Do not replace image tags with digest pins in operator catalogs
        ManifestsOnly              bool   // Generate manifests and do not mirror
        From                       string // Path to an input file (e.g. archived imageset)
        ToMirror                   string // Final destination for the mirror operation
        UserNamespace              string // The &lt;namespace&gt;/&lt;image&gt; portion of a docker reference only
        DryRun                     bool   // Print actions without mirroring images
        SourceSkipTLS              bool   // Disable TLS validation for source registry
        DestSkipTLS                bool   // Disable TLS validation for destination registry
        V2                         bool   // Redirect the flow to oc-mirror v2 - PLEASE DO NOT USE that. V2 is still under development and it is not ready to be used.
        SourcePlainHTTP            bool   // Use plain HTTP for source registry
        DestPlainHTTP              bool   // Use plain HTTP for destination registry
        SkipVerification           bool   // Skip verifying the integrity of the retrieved content.
        SkipCleanup                bool   // Skip removal of artifact directories
        SkipMissing                bool   // If an input image is not found, skip them.
        SkipMetadataCheck          bool   // Skip metadata when publishing an imageset
        SkipPruning                bool   // If set, will disable pruning globally
        ContinueOnError            bool   // If an error occurs, keep going and attempt to complete operations if possible
        IgnoreHistory              bool   // Ignore past mirrors when downloading images and packing layers
        MaxPerRegistry             int    // Number of concurrent requests allowed per registry
        OCIRegistriesConfig        string // Registries config file location (it works only with local oci catalogs)
        OCIInsecureSignaturePolicy bool   // If set, OCI catalog push will not try to push signatures
        MaxNestedPaths             int
        // cancelCh is a channel listening for command cancellations
        cancelCh                          &lt;-chan struct{}
        once                              sync.Once
        continuedOnError                  bool
        remoteRegFuncs                    RemoteRegFuncs
        operatorCatalogToFullArtifactPath map[string]string // stores temporary paths to declarative config directory key: OCI URI (e.g. oci://foo which originates with v1alpha2.Operator.Catalog) value: &lt;current working directory&gt;/olm_artifacts/&lt;repo&gt;/&lt;config folder&gt;
}

func (o *MirrorOptions) BindFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        fs.StringVarP(&amp;o.ConfigPath, "config", "c", o.ConfigPath, "Path to imageset configuration file")
        fs.BoolVar(&amp;o.SkipImagePin, "skip-image-pin", o.SkipImagePin, "Do not replace image tags with digest pins in operator catalogs")
        fs.StringVar(&amp;o.From, "from", o.From, "Path to an input file (e.g. archived imageset)")
        fs.BoolVar(&amp;o.ManifestsOnly, "manifests-only", o.ManifestsOnly, "Generate manifests and do not mirror")
        fs.BoolVar(&amp;o.DryRun, "dry-run", o.DryRun, "Print actions without mirroring images")
        fs.BoolVar(&amp;o.SourceSkipTLS, "source-skip-tls", o.SourceSkipTLS, "Disable TLS validation for source registry")
        fs.BoolVar(&amp;o.DestSkipTLS, "dest-skip-tls", o.DestSkipTLS, "Disable TLS validation for destination registry")
        fs.BoolVar(&amp;o.V2, "v2", o.V2, "Redirect the flow to oc-mirror v2 - PLEASE DO NOT USE that. V2 is still under development and it is not ready to be used.")
        fs.BoolVar(&amp;o.SourcePlainHTTP, "source-use-http", o.SourcePlainHTTP, "Use plain HTTP for source registry")
        fs.BoolVar(&amp;o.DestPlainHTTP, "dest-use-http", o.DestPlainHTTP, "Use plain HTTP for destination registry")
        fs.BoolVar(&amp;o.SkipVerification, "skip-verification", o.SkipVerification, "Skip verifying the integrity of the retrieved content."+
                "This is not recommended, but may be necessary when importing images from older image registries."+
                "Only bypass verification if the registry is known to be trustworthy.")
        fs.BoolVar(&amp;o.SkipCleanup, "skip-cleanup", o.SkipCleanup, "Skip removal of artifact directories")
        fs.BoolVar(&amp;o.IgnoreHistory, "ignore-history", o.IgnoreHistory, "Ignore past mirrors when downloading images and packing layers")
        fs.BoolVar(&amp;o.SkipMetadataCheck, "skip-metadata-check", o.SkipMetadataCheck, "Skip metadata when publishing an imageset."+
                "This is only recommended when the imageset was created --ignore-history")
        fs.BoolVar(&amp;o.ContinueOnError, "continue-on-error", o.ContinueOnError, "If an error occurs, keep going "+
                "and attempt to complete operations if possible")
        fs.BoolVar(&amp;o.SkipMissing, "skip-missing", o.SkipMissing, "If an input image is not found, skip them. "+
                "404/NotFound errors encountered while pulling images explicitly specified in the config "+
                "will not be skipped")
        fs.IntVar(&amp;o.MaxPerRegistry, "max-per-registry", 6, "Number of concurrent requests allowed per registry")
        fs.StringVar(&amp;o.OCIRegistriesConfig, "oci-registries-config", o.OCIRegistriesConfig, "Registries config file location (it works only with local oci catalogs)")
        fs.BoolVar(&amp;o.OCIInsecureSignaturePolicy, "oci-insecure-signature-policy", o.OCIInsecureSignaturePolicy, "If set, OCI catalog push will not try to push signatures")
        fs.BoolVar(&amp;o.SkipPruning, "skip-pruning", o.SkipPruning, "If set, will disable pruning globally")
        fs.IntVar(&amp;o.MaxNestedPaths, "max-nested-paths", 0, "Number of nested paths, for destination registries that limit nested paths")
}</span>

func (o *MirrorOptions) init() <span class="cov0" title="0">{
        o.cancelCh = makeCancelCh(syscall.SIGINT, syscall.SIGTERM)
}</span>

// CancelContext will return a cancellable context and listen for
// cancellation signals
func (o *MirrorOptions) CancelContext(parent context.Context) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        o.once.Do(o.init)
        ctx, cancel := context.WithCancel(parent)
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-o.cancelCh:<span class="cov0" title="0">
                        cancel()</span>
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                }
        }()
        <span class="cov0" title="0">return ctx, cancel</span>
}

// makeCancelCh creates an interrupt listener for os signals
// and will send a message on a returned channel
func makeCancelCh(signals ...os.Signal) &lt;-chan struct{} <span class="cov0" title="0">{
        resultCh := make(chan struct{})
        signalCh := make(chan os.Signal, 1)
        signal.Notify(signalCh, signals...)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        &lt;-signalCh
                        resultCh &lt;- struct{}{}
                }</span>
        }()
        <span class="cov0" title="0">return resultCh</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/archive"
        "github.com/openshift/oc-mirror/pkg/bundle"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/metadata"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
)

var (
        // ErrNoUpdatesExist should be returned by Create() when no updates are found
        ErrNoUpdatesExist = errors.New("no updates detected, process stopping")
)

const (
        // defaultSegSize is the default maximum archive size.
        defaultSegSize int64 = 500
        // segMultiplier is the multiplier used to
        // convert segSize to GiB
        segMultiplier int64 = 1024 * 1024 * 1024
)

// Pack will pack the imageset and return a temporary backend storing metadata for final push
// The metadata has been updated by the plan stage at this point but not pushed to the backend
func (o *MirrorOptions) Pack(ctx context.Context, prevAssocs, currAssocs image.AssociationSet, meta *v1alpha2.Metadata, archiveSize int64) (storage.Backend, error) <span class="cov8" title="1">{
        tmpdir, _, err := o.mktempDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tmpBackend, err := storage.NewLocalBackend(tmpdir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update metadata files and get newly created filepaths.
        <span class="cov8" title="1">diskPath := filepath.Join(o.Dir, config.SourceDir, config.V2Dir)
        // Define a map that associates locations
        // on disk to location in archive
        paths := map[string]string{diskPath: config.V2Dir}
        reconcileAssociation := image.AssociationSet{}
        if !o.IgnoreHistory </span><span class="cov8" title="1">{
                reconcileAssociation = prevAssocs
        }</span>
        <span class="cov8" title="1">manifests, blobs, err := bundle.ReconcileV2Dir(reconcileAssociation, paths)
        if err != nil </span><span class="cov0" title="0">{
                return tmpBackend, fmt.Errorf("error reconciling v2 files: %v", err)
        }</span>

        // Stop the process if no new blobs
        <span class="cov8" title="1">if len(blobs) == 0 </span><span class="cov8" title="1">{
                return tmpBackend, ErrNoUpdatesExist
        }</span>

        // Update Association in PastMirror to the current value and update
        <span class="cov8" title="1">meta.PastMirror.Associations, err = image.ConvertFromAssociationSet(currAssocs)
        if err != nil </span><span class="cov0" title="0">{
                return tmpBackend, err
        }</span>
        <span class="cov8" title="1">prevAssocs.Merge(currAssocs)
        meta.PastAssociations, err = image.ConvertFromAssociationSet(prevAssocs)
        if err != nil </span><span class="cov0" title="0">{
                return tmpBackend, err
        }</span>
        <span class="cov8" title="1">if err := metadata.UpdateMetadata(ctx, tmpBackend, meta, filepath.Join(o.Dir, config.SourceDir), o.SourceSkipTLS, o.SourcePlainHTTP); err != nil </span><span class="cov0" title="0">{
                return tmpBackend, err
        }</span>

        <span class="cov8" title="1">if err := o.prepareArchive(ctx, tmpBackend, archiveSize, meta.PastMirror.Sequence, manifests, blobs); err != nil </span><span class="cov0" title="0">{
                return tmpBackend, err
        }</span>

        /* Commenting out temporarily because no concrete types implement this
        if committer, isCommitter := backend.(storage.Committer); isCommitter {
                if err := committer.Commit(ctx); err != nil {
                        return err
                }
        }*/

        <span class="cov8" title="1">return tmpBackend, nil</span>
}

func (o *MirrorOptions) prepareArchive(ctx context.Context, backend storage.Backend, archiveSize int64, seq int, manifests, blobs []string) error <span class="cov8" title="1">{

        segSize := defaultSegSize
        if archiveSize != 0 </span><span class="cov0" title="0">{
                segSize = archiveSize
                klog.V(2).Infof("Using user provided archive size %d GiB", segSize)
        }</span>
        <span class="cov8" title="1">segSize *= segMultiplier

        // Set get absolute path to output dir
        // to avoid issue with directory change
        output, err := filepath.Abs(o.OutputDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Change directory before archiving to
        // avoid broken symlink paths
        <span class="cov8" title="1">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.Chdir(filepath.Join(o.Dir, config.SourceDir)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer os.Chdir(cwd)

        packager := archive.NewPackager(manifests, blobs)
        prefix := fmt.Sprintf("mirror_seq%d", seq)
        if err := packager.CreateSplitArchive(ctx, backend, segSize, output, ".", prefix, o.SkipCleanup); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create archive: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *MirrorOptions) mktempDir() (string, func(), error) <span class="cov8" title="1">{
        // Placing this under the source directory, so it will be cleaned up
        // at the end of operators if cleanup func is not used
        dir := filepath.Join(o.Dir, config.SourceDir, fmt.Sprintf("tmpbackend.%d", time.Now().Unix()))
        return dir, func() </span><span class="cov0" title="0">{
                if err := os.RemoveAll(dir); err != nil </span><span class="cov0" title="0">{
                        klog.Error(err)
                }</span>
        }, os.MkdirAll(dir, os.ModePerm)
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package mirror

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"
        "sort"
        "sync"

        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/google/go-containerregistry/pkg/v1/remote/transport"
        "github.com/openshift/library-go/pkg/image/reference"
        "github.com/openshift/oc/pkg/cli/admin/prune/imageprune"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/image"
)

// pruneRegistry plans and executes registry pruning based on current and previous Associations.
func (o *MirrorOptions) pruneRegistry(ctx context.Context, prev, curr image.AssociationSet) error <span class="cov0" title="0">{
        //CFE-739
        if !o.SkipPruning </span><span class="cov0" title="0">{
                deleter, toRemove, err := o.planImagePruning(ctx, curr, prev)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // We can use MaxPerRegistry for maxWorkers because
                // we only prune from one registry
                <span class="cov0" title="0">return o.pruneImages(deleter, toRemove, o.MaxPerRegistry)</span>
        }
        <span class="cov0" title="0">klog.Info("skipped pruning")
        return nil</span>
}

// planImagePruning creates a ManifestDeleter and map of manifests scheduled for deletion.
func (o *MirrorOptions) planImagePruning(ctx context.Context, curr, prev image.AssociationSet) (imageprune.ManifestDeleter, map[string][]string, error) <span class="cov8" title="1">{
        var insecure bool
        if o.DestPlainHTTP || o.DestSkipTLS </span><span class="cov0" title="0">{
                insecure = true
        }</span>
        <span class="cov8" title="1">deleter := NewManifestDeleter(ctx, o.Out, o.ErrOut, o.ToMirror, insecure)
        manifestsByRepo := map[string][]string{}

        // We compare repo locations to allow the translation between
        // mirror-to-mirror and disk-to-mirror association paths.
        getRepoLoc := func(assocPath string) (string, error) </span><span class="cov8" title="1">{
                ref, err := reference.Parse(assocPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid association set")
                }</span>

                <span class="cov8" title="1">var repoLoc string
                // If the imageAssoc path is the location
                // in the target registry (i.e. mirror to mirror), unset the
                // registry information and use the repo location as is.
                if ref.Registry != "" </span><span class="cov8" title="1">{
                        ref.Registry = ""
                        repoLoc = ref.AsRepository().String()
                }</span> else<span class="cov8" title="1"> {
                        repoLoc = path.Join(o.UserNamespace, ref.AsRepository().String())
                }</span>

                <span class="cov8" title="1">return repoLoc, nil</span>
        }

        <span class="cov8" title="1">keyforUniqueName := func(assoc v1alpha2.Association) (string, error) </span><span class="cov8" title="1">{
                // Combine the source image or child manifest digest with the
                // target location.
                repoLoc, err := getRepoLoc(assoc.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%v-%v", assoc.ID, repoLoc), nil</span>
        }

        // Gather all manifests that exists
        // current set.
        <span class="cov8" title="1">currSet := map[string]v1alpha2.Association{}
        for _, assocs := range curr </span><span class="cov8" title="1">{
                for _, assoc := range assocs </span><span class="cov8" title="1">{
                        unique, err := keyforUniqueName(assoc)
                        if err != nil </span><span class="cov0" title="0">{
                                return deleter, manifestsByRepo, err
                        }</span>
                        <span class="cov8" title="1">currSet[unique] = assoc</span>
                }

        }

        <span class="cov8" title="1">outputSet := map[string]v1alpha2.Association{}
        for _, assocs := range prev </span><span class="cov8" title="1">{
                for _, assoc := range assocs </span><span class="cov8" title="1">{
                        unique, err := keyforUniqueName(assoc)
                        if err != nil </span><span class="cov0" title="0">{
                                return deleter, manifestsByRepo, err
                        }</span>
                        <span class="cov8" title="1">if _, exists := currSet[unique]; exists </span><span class="cov8" title="1">{
                                // Do not add to the output set if the manifest
                                // exists for the image in the current set
                                continue</span>
                        }
                        <span class="cov8" title="1">outputSet[unique] = assoc</span>
                }
        }

        <span class="cov8" title="1">for _, assoc := range outputSet </span><span class="cov8" title="1">{

                // We are only processing keys where we have
                // access to the manifest digest. Associated
                // tags will be deleted with the manifest.
                if assoc.ID == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">repoLoc, err := getRepoLoc(assoc.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return deleter, manifestsByRepo, err
                }</span>

                <span class="cov8" title="1">manifests := manifestsByRepo[repoLoc]
                manifests = append(manifests, assoc.ID)
                sortManifests(manifests)
                manifestsByRepo[repoLoc] = manifests</span>
        }
        <span class="cov8" title="1">return deleter, manifestsByRepo, nil</span>
}

// pruneImages performs the image deletion based on the provided map of repos and manifests.
func (o *MirrorOptions) pruneImages(deleter imageprune.ManifestDeleter, manifestsByRepo map[string][]string, maxWorkers int) error <span class="cov8" title="1">{
        if len(manifestsByRepo) == 0 </span><span class="cov0" title="0">{
                klog.V(2).Info("No images specified for pruning")
                return nil
        }</span>

        <span class="cov8" title="1">var keys []string
        for repo, manifests := range manifestsByRepo </span><span class="cov8" title="1">{
                klog.Infof("Pruning %d manifest(s) from repository %s", len(manifests), repo)
                keys = append(keys, repo)
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        var mutex sync.Mutex
        workQueue := make(chan string)
        errorsCh := make(chan error)

        for i := 0; i &lt; maxWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for k := range workQueue </span><span class="cov8" title="1">{
                                mutex.Lock()
                                manifests := manifestsByRepo[k]
                                mutex.Unlock()

                                for _, manifest := range manifests </span><span class="cov8" title="1">{
                                        err := deleter.DeleteManifest(k, manifest)
                                        if err != nil </span><span class="cov8" title="1">{
                                                err = fmt.Errorf("repo %q manifest %s: %w", k, manifest, err)
                                                errorsCh &lt;- err
                                        }</span>
                                }
                        }
                }()
        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for _, k := range keys </span><span class="cov8" title="1">{
                        workQueue &lt;- k
                }</span>
                <span class="cov8" title="1">close(workQueue)
                wg.Wait()
                close(errorsCh)</span>
        }()

        <span class="cov8" title="1">var errs []error

        skipErr := func(err error) bool </span><span class="cov8" title="1">{
                var terr *transport.Error
                return errors.As(err, &amp;terr)
        }</span>

        <span class="cov8" title="1">logMessage := func(err error) string </span><span class="cov8" title="1">{
                var terr *transport.Error
                if errors.As(err, &amp;terr) </span><span class="cov8" title="1">{
                        switch terr.StatusCode </span>{
                        case 405:<span class="cov0" title="0">
                                return fmt.Sprintf("image deletion is not permitted on registry %s: %v", o.ToMirror, err.Error())</span>
                        case 401:<span class="cov8" title="1">
                                return fmt.Sprintf("unauthorized image deletion on registry %s: %v", o.ToMirror, err.Error())</span>
                        default:<span class="cov0" title="0">
                                return err.Error()</span>
                        }
                }
                <span class="cov0" title="0">return err.Error()</span>
        }

        <span class="cov8" title="1">for err := range errorsCh </span><span class="cov8" title="1">{
                errs = append(errs, o.checkErr(err, skipErr, logMessage))
        }</span>

        <span class="cov8" title="1">return utilerrors.NewAggregate(errs)</span>
}

type pruneImagePlan struct {
        Registry     string       `json:"registry,omitempty"`
        Repositories []repository `json:"repositories,omitempty"`
}

type repository struct {
        Name      string   `json:"name,omitempty"`
        Manifests []string `json:"manifests,omitempty"`
}

// outputPruneImagePlan will write a plan for pruning images to disk.
func (o *MirrorOptions) outputPruneImagePlan(ctx context.Context, prev, curr image.AssociationSet) error <span class="cov0" title="0">{
        _, toRemove, err := o.planImagePruning(ctx, curr, prev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(toRemove) == 0 </span><span class="cov0" title="0">{
                klog.V(2).Info("No images planned for pruning")
                return nil
        }</span>
        <span class="cov0" title="0">planFilePath := filepath.Join(o.Dir, "pruning-plan.json")
        cleanPlanFilePath := filepath.Clean(planFilePath)
        klog.Infof("Writing image pruning plan to %s", planFilePath)
        planFile, err := os.Create(cleanPlanFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer planFile.Close()

        plan := aggregateImageInformation(o.ToMirror, toRemove)

        if err := writePruneImagePlan(planFile, plan); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return planFile.Sync()</span>
}

// writePruneImagePlan will write the prune image plan in JSON format.
func writePruneImagePlan(w io.Writer, plan pruneImagePlan) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(&amp;plan, "", " ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = w.Write(data)
        return err</span>
}

// aggregateImageInformation will create a prune image plan from registry
// and manifest information.
func aggregateImageInformation(registry string, manifestsByRepo map[string][]string) pruneImagePlan <span class="cov8" title="1">{
        plan := pruneImagePlan{}
        plan.Registry = registry

        for repo, manifests := range manifestsByRepo </span><span class="cov8" title="1">{
                r := repository{
                        Name:      repo,
                        Manifests: manifests,
                }
                sortManifests(r.Manifests)
                plan.Repositories = append(plan.Repositories, r)
        }</span>
        <span class="cov8" title="1">sortRepos(plan.Repositories)
        return plan</span>
}

func sortRepos(repos []repository) <span class="cov8" title="1">{
        sort.Slice(repos, func(i, j int) bool </span><span class="cov8" title="1">{
                return repos[i].Name &lt; repos[j].Name
        }</span>)
}

func sortManifests(manifests []string) <span class="cov8" title="1">{
        sort.Slice(manifests, func(i, j int) bool </span><span class="cov8" title="1">{
                return manifests[i] &lt; manifests[j]
        }</span>)
}

// manifestDeleter prints information about each repo manifest being
// deleted. Implement the ManifestDeleter interface for `oc adm prune images“.
// TODO(jpower432): Factor out go-containerregistry in favor of the concrete types
// defined in this imageprune package.
type manifestDeleter struct {
        w        io.Writer
        errOut   io.Writer
        nopts    []name.Option
        ropts    []remote.Option
        registry string
}

var _ imageprune.ManifestDeleter = &amp;manifestDeleter{}

// NewManifestDeleter create a new implementation of the ManifestDeleter interface
func NewManifestDeleter(ctx context.Context, w, errOut io.Writer, registry string, insecure bool) imageprune.ManifestDeleter <span class="cov8" title="1">{
        getNameOpts(insecure)
        return &amp;manifestDeleter{
                w:        w,
                errOut:   errOut,
                nopts:    getNameOpts(insecure),
                ropts:    getRemoteOpts(ctx, insecure),
                registry: registry,
        }
}</span>

// DeleteManifest deletes manifest from a repository.
func (p *manifestDeleter) DeleteManifest(repo, manifest string) error <span class="cov0" title="0">{
        fmt.Fprintf(p.w, "Deleting manifest %s from repo %s\n", manifest, repo)
        ref := path.Join(p.registry, repo)
        ref = fmt.Sprintf("%s@%s", ref, manifest)

        nameRef, err := name.ParseReference(ref, p.nopts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing image reference %s: %v", ref, err)
        }</span>

        <span class="cov0" title="0">return remote.Delete(nameRef, p.ropts...)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"

        "github.com/opencontainers/go-digest"
        "github.com/openshift/library-go/pkg/image/reference"
        "github.com/openshift/library-go/pkg/image/registryclient"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        imagemanifest "github.com/openshift/oc/pkg/cli/image/manifest"
        imgmirror "github.com/openshift/oc/pkg/cli/image/mirror"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/archive"
        "github.com/openshift/oc-mirror/pkg/bundle"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
)

type ErrArchiveFileNotFound struct {
        filename string
}

func (e *ErrArchiveFileNotFound) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("file %s not found in archive", e.filename)
}</span>

// Publish will plan a mirroring operation based on provided imageset on disk
func (o *MirrorOptions) Publish(ctx context.Context) (image.TypedImageMapping, error) <span class="cov0" title="0">{

        klog.Infof("Publishing image set from archive %q to registry %q", o.From, o.ToMirror)
        allMappings := image.TypedImageMapping{}

        // Set target dir for resulting artifacts
        if o.OutputDir == "" </span><span class="cov0" title="0">{
                dir, err := o.createResultsDir()
                if err != nil </span><span class="cov0" title="0">{
                        return allMappings, err
                }</span>
                <span class="cov0" title="0">o.OutputDir = dir</span>
        }

        // Create workspace
        <span class="cov0" title="0">cleanup, tmpdir, err := mktempDir(o.Dir)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        // Handle cleanup of disk
        <span class="cov0" title="0">if !o.SkipCleanup </span><span class="cov0" title="0">{
                defer cleanup()
        }</span>

        <span class="cov0" title="0">klog.V(2).Infof("Unarchiving metadata into %s", tmpdir)

        // Get file information from the source archives
        filesInArchive, err := bundle.ReadImageSet(archive.NewArchiver(), o.From)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        <span class="cov0" title="0">backend, incomingMeta, currentMeta, err := o.remoteRegFuncs.handleMetadata(ctx, tmpdir, filesInArchive)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>
        <span class="cov0" title="0">incomingAssocs, err := image.ConvertToAssociationSet(incomingMeta.PastAssociations)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, fmt.Errorf("error processing incoming past associations: %v", err)
        }</span>

        // Unpack chart to user destination if it exists
        <span class="cov0" title="0">klog.V(1).Infof("Unpacking any provided Helm charts to %s", o.OutputDir)
        if err := unpack(config.HelmDir, o.OutputDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        // Load image associations to find layers not present locally.
        <span class="cov0" title="0">assocs, err := image.ConvertToAssociationSet(incomingMeta.PastMirror.Associations)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>
        <span class="cov0" title="0">if err := assocs.UpdatePath(); err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        <span class="cov0" title="0">klog.V(3).Infof("Process all images in imageset")
        imgMappings, err := o.processMirroredImages(ctx, assocs, filesInArchive, currentMeta)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, fmt.Errorf("error occurred during image processing: %v", err)
        }</span>
        <span class="cov0" title="0">allMappings.Merge(imgMappings)

        currentAssocs, err := image.ConvertToAssociationSet(currentMeta.PastAssociations)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, fmt.Errorf("error processing incoming past associations: %v", err)
        }</span>

        <span class="cov0" title="0">if o.DryRun </span><span class="cov0" title="0">{
                if err := o.outputPruneImagePlan(ctx, currentAssocs, incomingAssocs); err != nil </span><span class="cov0" title="0">{
                        return allMappings, err
                }</span>
                <span class="cov0" title="0">return allMappings, nil</span>
        }

        <span class="cov0" title="0">if err := o.pruneRegistry(ctx, currentAssocs, incomingAssocs); err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        <span class="cov0" title="0">klog.V(1).Infof("Unpack release signatures")
        if err = o.unpackReleaseSignatures(o.OutputDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        <span class="cov0" title="0">customMappings, err := o.processCustomImages(ctx, tmpdir, filesInArchive)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>
        <span class="cov0" title="0">allMappings.Merge(customMappings)

        // Replace old metadata with new metadata if metadata is not single use
        if !incomingMeta.SingleUse </span><span class="cov0" title="0">{
                if err := backend.WriteMetadata(ctx, &amp;incomingMeta, config.MetadataBasePath); err != nil </span><span class="cov0" title="0">{
                        return allMappings, err
                }</span>
        }

        <span class="cov0" title="0">return allMappings, nil</span>
}

// handleMetadata unpacks and performs sequence checks on metadata coming from the imageset and metadata
// exists in the registry.
func (o *MirrorOptions) handleMetadata(ctx context.Context, tmpdir string, filesInArchive map[string]string) (backend storage.Backend, incoming, curr v1alpha2.Metadata, err error) <span class="cov8" title="1">{
        // Extract metadata from archive
        if err := unpack(config.MetadataBasePath, tmpdir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                return backend, incoming, curr, err
        }</span>

        <span class="cov8" title="1">var insecure bool
        if o.DestPlainHTTP || o.DestSkipTLS </span><span class="cov8" title="1">{
                insecure = true
        }</span>
        // Create a local workspace backend for incoming data
        <span class="cov8" title="1">workspace, err := storage.NewLocalBackend(tmpdir)
        if err != nil </span><span class="cov0" title="0">{
                return backend, incoming, curr, fmt.Errorf("error opening local backend: %v", err)
        }</span>
        // Load incoming metadta
        <span class="cov8" title="1">if err := workspace.ReadMetadata(ctx, &amp;incoming, config.MetadataBasePath); err != nil </span><span class="cov0" title="0">{
                return backend, incoming, curr, fmt.Errorf("error reading incoming metadata: %v", err)
        }</span>

        <span class="cov8" title="1">metaImage := o.newMetadataImage(incoming.Uid.String())
        // Determine stateless or stateful mode
        if incoming.SingleUse </span><span class="cov0" title="0">{
                klog.Warning("metadata has single-use label, using stateless mode")
                // Create backend for any temporary storage
                // but skips metadata sequence checks
                backend, err = storage.NewLocalBackend(o.Dir)
                if err != nil </span><span class="cov0" title="0">{
                        return backend, incoming, curr, fmt.Errorf("error creating temporary backend for metadata at %s: %v", o.Dir, err)
                }</span>
                <span class="cov0" title="0">return backend, incoming, curr, nil</span>
        }

        <span class="cov8" title="1">cfg := &amp;v1alpha2.RegistryConfig{
                ImageURL: metaImage,
                SkipTLS:  insecure,
        }
        backend, err = storage.NewRegistryBackend(cfg, o.Dir)
        if err != nil </span><span class="cov0" title="0">{
                return backend, incoming, curr, fmt.Errorf("error creating backend for metadata at %s: %v", metaImage, err)
        }</span>

        // Read in current metadata, if present
        <span class="cov8" title="1">berr := backend.ReadMetadata(ctx, &amp;curr, config.MetadataBasePath)
        if err := o.checkSequence(incoming, curr, berr); err != nil </span><span class="cov8" title="1">{
                return backend, incoming, curr, err
        }</span>
        <span class="cov8" title="1">return backend, incoming, curr, nil</span>
}

// processMirroredImages unpacks, reconstructs, and published all images in the provided imageset to the specified registry.
func (o *MirrorOptions) processMirroredImages(ctx context.Context, assocs image.AssociationSet, filesInArchive map[string]string, currentMeta v1alpha2.Metadata) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        allMappings := image.TypedImageMapping{}
        var errs []error
        toMirrorRef, err := imagesource.ParseReference(o.ToMirror)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, fmt.Errorf("error parsing mirror registry %q: %v", o.ToMirror, err)
        }</span>
        <span class="cov0" title="0">klog.V(2).Infof("mirror reference: %#v", toMirrorRef)
        if toMirrorRef.Type != imagesource.DestinationRegistry </span><span class="cov0" title="0">{
                return allMappings, fmt.Errorf("destination %q must be a registry reference", o.ToMirror)
        }</span>

        <span class="cov0" title="0">for _, imageName := range assocs.Keys() </span><span class="cov0" title="0">{

                var mmapping []imgmirror.Mapping

                values, _ := assocs.Search(imageName)

                // Create temp workspace for image processing
                cleanUnpackDir, unpackDir, err := mktempDir(o.Dir)
                if err != nil </span><span class="cov0" title="0">{
                        return allMappings, err
                }</span>

                <span class="cov0" title="0">for _, assoc := range values </span><span class="cov0" title="0">{

                        // Map of remote layer digest to the set of paths they should be fetched to.
                        missingLayers := map[string][]string{}
                        manifestPath := filepath.Join(config.V2Dir, assoc.Path, "manifests")

                        // Ensure child manifests are all unpacked
                        klog.V(3).Infof("reading assoc: %s", assoc.Name)
                        if len(assoc.ManifestDigests) != 0 </span><span class="cov0" title="0">{
                                for _, manifestDigest := range assoc.ManifestDigests </span><span class="cov0" title="0">{
                                        if hasManifest := assocs.ContainsKey(imageName, manifestDigest); !hasManifest </span><span class="cov0" title="0">{
                                                errs = append(errs, fmt.Errorf("image %q: expected associations to have manifest %s but was not found", imageName, manifestDigest))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">manifestArchivePath := filepath.Join(manifestPath, manifestDigest)
                                        switch _, err := os.Stat(manifestArchivePath); </span>{
                                        case err == nil:<span class="cov0" title="0">
                                                klog.V(4).Infof("Manifest found %s found in %s", manifestDigest, assoc.Path)</span>
                                        case errors.Is(err, os.ErrNotExist):<span class="cov0" title="0">
                                                if err := unpack(manifestArchivePath, unpackDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                                                        errs = append(errs, err)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                errs = append(errs, fmt.Errorf("accessing image %q manifest %q: %v", imageName, manifestDigest, err))</span>
                                        }
                                }
                        }

                        // Unpack association main manifest
                        <span class="cov0" title="0">if err := unpack(filepath.Join(manifestPath, assoc.ID), unpackDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("error occured during unpacking %v", err))
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, layerDigest := range assoc.LayerDigests </span><span class="cov0" title="0">{
                                klog.V(4).Infof("Found layer %v for image %s", layerDigest, imageName)
                                // Construct blob path, which is adjacent to the manifests path.
                                blobPath := filepath.Join("blobs", layerDigest)
                                imagePath := filepath.Join(unpackDir, config.V2Dir, assoc.Path)
                                imageBlobPath := filepath.Join(imagePath, blobPath)
                                aerr := &amp;ErrArchiveFileNotFound{}
                                switch err := unpack(blobPath, imagePath, filesInArchive); </span>{
                                case err == nil:<span class="cov0" title="0">
                                        klog.V(4).Infof("Blob %s found in %s", layerDigest, assoc.Path)</span>
                                case errors.Is(err, os.ErrNotExist) || errors.As(err, &amp;aerr):<span class="cov0" title="0">
                                        // Image layer must exist in the mirror registry since it wasn't archived,
                                        // so fetch the layer and place it in the blob dir so it can be mirrored by `oc`.
                                        missingLayers[layerDigest] = append(missingLayers[layerDigest], imageBlobPath)</span>
                                default:<span class="cov0" title="0">
                                        errs = append(errs, fmt.Errorf("accessing image %q blob %q at %s: %v", imageName, layerDigest, blobPath, err))</span>
                                }
                        }

                        <span class="cov0" title="0">m := imgmirror.Mapping{Name: assoc.Name}
                        if m.Source, err = imagesource.ParseReference("file://" + assoc.Path); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("error parsing source ref %q: %v", assoc.Path, err))
                                continue</span>
                        }

                        <span class="cov0" title="0">if assoc.TagSymlink != "" </span><span class="cov0" title="0">{
                                if err := unpack(filepath.Join(manifestPath, assoc.TagSymlink), unpackDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, fmt.Errorf("error unpacking symlink %v", err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">m.Source.Ref.Tag = assoc.TagSymlink</span>
                        }

                        <span class="cov0" title="0">m.Source.Ref.ID = assoc.ID
                        m.Destination = toMirrorRef
                        m.Destination.Ref.Name = m.Source.Ref.Name
                        m.Destination.Ref.Tag = m.Source.Ref.Tag
                        m.Destination.Ref.ID = m.Source.Ref.ID
                        m.Destination.Ref.Namespace = path.Join(o.UserNamespace, m.Source.Ref.Namespace)

                        // Add references for the mirror mapping
                        mmapping = append(mmapping, m)

                        // Add top level association to the ICSP mapping
                        if assoc.Name == imageName </span><span class="cov0" title="0">{
                                source, err := image.ParseReference(imageName)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">dst := image.TypedImageReference{
                                        Ref:  m.Destination.Ref,
                                        Type: m.Destination.Type,
                                }
                                allMappings.Add(source, dst, assoc.Type)</span>
                        }

                        <span class="cov0" title="0">if len(missingLayers) != 0 </span><span class="cov0" title="0">{
                                // Fetch all layers and mount them at the specified paths.
                                // Must use metadata for current published run to find images already mirrored.
                                if err := o.fetchBlobs(ctx, currentMeta, missingLayers); err != nil </span><span class="cov0" title="0">{
                                        return allMappings, err
                                }</span>
                        }
                }

                // Mirror all mappings for this image
                <span class="cov0" title="0">if len(mmapping) != 0 </span><span class="cov0" title="0">{
                        if err := o.publishImage(mmapping, unpackDir); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                        }</span>
                }

                // Cleanup temp image processing workspace as images are processed
                <span class="cov0" title="0">if !o.SkipCleanup </span><span class="cov0" title="0">{
                        cleanUnpackDir()
                }</span>
        }
        <span class="cov0" title="0">return allMappings, utilerrors.NewAggregate(errs)</span>
}

// processCustomImages builds custom images for operator catalogs or Cincinnati graph data if data is present in the archive
func (o *MirrorOptions) processCustomImages(ctx context.Context, dir string, filesInArchive map[string]string) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        allMappings := image.TypedImageMapping{}
        // process catalogs
        klog.V(2).Infof("rebuilding catalog images")
        found, err := o.unpackCatalog(dir, filesInArchive)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                ctlgRefs, err := o.rebuildCatalogs(ctx, dir)
                if err != nil </span><span class="cov0" title="0">{
                        return allMappings, fmt.Errorf("error rebuilding catalog images from file-based catalogs: %v", err)
                }</span>
                <span class="cov0" title="0">allMappings.Merge(ctlgRefs)</span>
        }

        <span class="cov0" title="0">klog.V(2).Infof("building cincinnati graph data image")
        // process cincinnati graph image
        found, err = o.unpackRelease(dir, filesInArchive)
        if err != nil </span><span class="cov0" title="0">{
                return allMappings, err
        }</span>

        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                graphRef, err := o.buildGraphImage(ctx, dir)
                if err != nil </span><span class="cov0" title="0">{
                        return allMappings, fmt.Errorf("error building cincinnati graph image: %v", err)
                }</span>
                <span class="cov0" title="0">allMappings.Merge(graphRef)</span>
        }

        <span class="cov0" title="0">return allMappings, nil</span>
}

// TODO(estroz): symlink blobs instead of copying them to avoid data duplication.
// `oc` mirror libs should be able to follow these symlinks.
func copyBlobFile(src io.Reader, dstPath string) error <span class="cov0" title="0">{
        klog.V(4).Infof("copying blob to %s", dstPath)
        if err := os.MkdirAll(filepath.Dir(dstPath), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Allowing exisitng files to be written to for now since we
        // some blobs appears to be written multiple time
        // TODO: investigate this issue
        <span class="cov0" title="0">dst, err := os.OpenFile(filepath.Clean(dstPath), os.O_CREATE|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating blob file: %v", err)
        }</span>
        <span class="cov0" title="0">defer dst.Close()
        if _, err := io.Copy(dst, src); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error copying blob %q: %v", filepath.Base(dstPath), err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *MirrorOptions) fetchBlobs(ctx context.Context, meta v1alpha2.Metadata, missingLayers map[string][]string) error <span class="cov0" title="0">{
        regctx, err := image.NewContext(o.SkipVerification)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating registry context: %v", err)
        }</span>

        <span class="cov0" title="0">asSet, err := image.ConvertToAssociationSet(meta.PastAssociations)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var errs []error
        pathsByLayer := image.AssocPathsForBlobs(asSet)
        for layerDigest, dstBlobPaths := range missingLayers </span><span class="cov0" title="0">{
                imgRef, err := o.findBlobRepo(pathsByLayer, layerDigest)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("error finding remote layer %q: %v", layerDigest, err))
                        continue</span>
                }
                <span class="cov0" title="0">if err := o.fetchBlob(ctx, regctx, imgRef.Ref, layerDigest, dstBlobPaths); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("layer %s: %v", layerDigest, err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">return utilerrors.NewAggregate(errs)</span>
}

// fetchBlob fetches a blob at &lt;o.ToMirror&gt;/&lt;resource&gt;/blobs/&lt;layerDigest&gt;
// then copies it to each path in dstPaths.
func (o *MirrorOptions) fetchBlob(ctx context.Context, regctx *registryclient.Context, ref reference.DockerImageReference, layerDigest string, dstPaths []string) error <span class="cov0" title="0">{
        var insecure bool
        if o.DestPlainHTTP || o.DestSkipTLS </span><span class="cov0" title="0">{
                insecure = true
        }</span>
        <span class="cov0" title="0">klog.V(4).Infof("copying blob %s from %s", layerDigest, ref.Exact())
        repo, err := regctx.RepositoryForRef(ctx, ref, insecure)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create repo for %s: %v", ref, err)
        }</span>
        <span class="cov0" title="0">dgst, err := digest.Parse(layerDigest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rc, err := repo.Blobs(ctx).Open(ctx, dgst)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open blob: %v", err)
        }</span>
        <span class="cov0" title="0">defer rc.Close()
        for _, dstPath := range dstPaths </span><span class="cov0" title="0">{
                if err := copyBlobFile(rc, dstPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("copy blob for %s: %v", ref, err)
                }</span>
                <span class="cov0" title="0">if _, err := rc.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("seek to start of blob: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func unpack(archiveFilePath, dest string, filesInArchive map[string]string) error <span class="cov8" title="1">{
        archivePath, found := filesInArchive[archiveFilePath]
        if !found </span><span class="cov0" title="0">{
                return &amp;ErrArchiveFileNotFound{archiveFilePath}
        }</span>
        <span class="cov8" title="1">if err := archive.NewArchiver().Extract(archivePath, archiveFilePath, dest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(dest, archiveFilePath)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func mktempDir(dir string) (func(), string, error) <span class="cov0" title="0">{
        dir, err := os.MkdirTemp(dir, "images.*")
        return func() </span><span class="cov0" title="0">{
                if err := os.RemoveAll(dir); err != nil </span><span class="cov0" title="0">{
                        klog.Fatal(err)
                }</span>
        }, dir, err
}

// publishImages uses the `oc mirror` library to mirror generic images
func (o *MirrorOptions) publishImage(mappings []imgmirror.Mapping, fromDir string) error <span class="cov0" title="0">{
        var insecure bool
        if o.DestPlainHTTP || o.DestSkipTLS </span><span class="cov0" title="0">{
                insecure = true
        }</span>
        // Mirror all file sources of each available image type to mirror registry.

        <span class="cov0" title="0">var srcs []string
        for _, m := range mappings </span><span class="cov0" title="0">{
                srcs = append(srcs, m.Source.String())
        }</span>
        <span class="cov0" title="0">klog.V(2).Infof("mirroring generic images: %q", srcs)

        regctx, err := image.NewContext(o.SkipVerification)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating registry context: %v", err)
        }</span>

        <span class="cov0" title="0">genOpts := imgmirror.NewMirrorImageOptions(o.IOStreams)
        genOpts.Mappings = mappings
        genOpts.DryRun = o.DryRun
        genOpts.FromFileDir = fromDir
        genOpts.SkipMissing = o.SkipMissing
        genOpts.ContinueOnError = o.ContinueOnError
        // Filter must be a wildcard for publishing because we
        // cannot filter images within a catalog
        genOpts.FilterOptions = imagemanifest.FilterOptions{FilterByOS: ".*"}
        genOpts.SkipMultipleScopes = true
        genOpts.KeepManifestList = true
        genOpts.SecurityOptions.CachedContext = regctx
        genOpts.SecurityOptions.Insecure = insecure
        if err := genOpts.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid image mirror options: %v", err)
        }</span>
        <span class="cov0" title="0">if err := genOpts.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error running generic image mirror: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o *MirrorOptions) findBlobRepo(assocPathsByLayer map[string]string, layerDigest string) (imagesource.TypedImageReference, error) <span class="cov8" title="1">{

        srcRef, ok := assocPathsByLayer[layerDigest]
        if !ok </span><span class="cov8" title="1">{
                return imagesource.TypedImageReference{}, fmt.Errorf("layer %q is not present in the archive", layerDigest)
        }</span>

        <span class="cov8" title="1">dstRef, err := imagesource.ParseReference(srcRef)
        if err != nil </span><span class="cov0" title="0">{
                return imagesource.TypedImageReference{}, err

        }</span>

        // If the imageAssoc path is the location
        // in the target registry (i.e. mirror to mirror), do nothing.
        // If a local reference add the registry and user namespace.
        <span class="cov8" title="1">if dstRef.Ref.Registry == "" </span><span class="cov8" title="1">{
                dstRef.Ref.Registry = o.ToMirror
                dstRef.Ref.Namespace = path.Join(o.UserNamespace, dstRef.Ref.Namespace)
        }</span>

        <span class="cov8" title="1">return dstRef, err</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package mirror

import (
        "bytes"
        "context"
        _ "embed"
        "errors"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "strings"

        semver "github.com/blang/semver/v4"
        "github.com/google/uuid"
        "github.com/openshift/library-go/pkg/manifest"
        "github.com/openshift/library-go/pkg/verify"
        "github.com/openshift/library-go/pkg/verify/store/sigstore"
        "github.com/openshift/library-go/pkg/verify/util"
        "github.com/openshift/oc/pkg/cli/admin/release"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/cincinnati"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
)

const (
        releaseRepo = "release-images"

        // maxDigestHashLen is used to truncate digest hash portion before using as part of
        // signature file name.
        maxDigestHashLen = 16

        // signatureFileNameFmt defines format of the release image signature file name.
        signatureFileNameFmt = "signature-%s-%s.json"
)

// ReleaseOptions configures either a Full or Diff mirror operation
// on a particular release image.
type ReleaseOptions struct {
        *MirrorOptions
        // insecure indicates whether the source
        // registry is insecure
        insecure bool
        uuid     uuid.UUID
}

// NewReleaseOptions defaults ReleaseOptions.
func NewReleaseOptions(mo *MirrorOptions) *ReleaseOptions <span class="cov0" title="0">{
        relOpts := &amp;ReleaseOptions{
                MirrorOptions: mo,
                uuid:          uuid.New(),
        }
        if mo.SourcePlainHTTP || mo.SourceSkipTLS </span><span class="cov0" title="0">{
                relOpts.insecure = true
        }</span>
        <span class="cov0" title="0">return relOpts</span>
}

// Plan will pull release payloads based on user configuration
func (o *ReleaseOptions) Plan(ctx context.Context, lastRun v1alpha2.PastMirror, cfg *v1alpha2.ImageSetConfiguration) (image.TypedImageMapping, error) <span class="cov0" title="0">{

        var (
                srcDir           = filepath.Join(o.Dir, config.SourceDir)
                releaseDownloads = downloads{}
                mmapping         = image.TypedImageMapping{}
                errs             = []error{}
        )

        prevChannels := make(map[string]string, len(lastRun.Platforms))
        for _, ch := range lastRun.Platforms </span><span class="cov0" title="0">{
                prevChannels[ch.ReleaseChannel] = ch.MinVersion
        }</span>

        <span class="cov0" title="0">for _, arch := range cfg.Mirror.Platform.Architectures </span><span class="cov0" title="0">{

                versionsByChannel := make(map[string]v1alpha2.ReleaseChannel, len(cfg.Mirror.Platform.Channels))

                for _, ch := range cfg.Mirror.Platform.Channels </span><span class="cov0" title="0">{

                        var client cincinnati.Client
                        var err error
                        switch ch.Type </span>{
                        case v1alpha2.TypeOCP:<span class="cov0" title="0">
                                client, err = cincinnati.NewOCPClient(o.uuid)</span>
                        case v1alpha2.TypeOKD:<span class="cov0" title="0">
                                client, err = cincinnati.NewOKDClient(o.uuid)</span>
                        default:<span class="cov0" title="0">
                                errs = append(errs, fmt.Errorf("invalid platform type %v", ch.Type))
                                continue</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(ch.MaxVersion) == 0 || len(ch.MinVersion) == 0 </span><span class="cov0" title="0">{

                                // Find channel maximum value and only set the minimum as well if heads-only is true
                                if len(ch.MaxVersion) == 0 </span><span class="cov0" title="0">{
                                        latest, err := cincinnati.GetChannelMinOrMax(ctx, client, arch, ch.Name, false)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }

                                        // Update version to release channel
                                        <span class="cov0" title="0">ch.MaxVersion = latest.String()
                                        klog.V(2).Infof("Detected minimum version as %s", ch.MaxVersion)
                                        if len(ch.MinVersion) == 0 &amp;&amp; ch.IsHeadsOnly() </span><span class="cov0" title="0">{
                                                min, found := prevChannels[ch.Name]
                                                if !found </span><span class="cov0" title="0">{
                                                        // Starting at a new headsOnly channels
                                                        min = latest.String()
                                                }</span>
                                                <span class="cov0" title="0">ch.MinVersion = min
                                                klog.V(2).Infof("Detected minimum version as %s", ch.MinVersion)</span>
                                        }
                                }

                                // Find channel minimum if full is true or just the minimum is not set
                                // in the config
                                <span class="cov0" title="0">if len(ch.MinVersion) == 0 </span><span class="cov0" title="0">{
                                        first, err := cincinnati.GetChannelMinOrMax(ctx, client, arch, ch.Name, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">ch.MinVersion = first.String()
                                        klog.V(2).Infof("Detected minimum version as %s", ch.MinVersion)</span>
                                }
                                <span class="cov0" title="0">versionsByChannel[ch.Name] = ch</span>
                        } else<span class="cov0" title="0"> {
                                // Range is set. Ensure full is true so this
                                // is skipped when processing release metadata.
                                klog.V(2).Infof("Processing minimum version %s and maximum version %s", ch.MinVersion, ch.MaxVersion)
                                ch.Full = true
                                versionsByChannel[ch.Name] = ch
                        }</span>

                        <span class="cov0" title="0">downloads, err := o.getChannelDownloads(ctx, client, lastRun.Mirror.Platform.Channels, ch, arch)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">releaseDownloads.Merge(downloads)</span>
                }

                // Update cfg release channels with maximum and minimum versions
                // if applicable
                <span class="cov0" title="0">for i, ch := range cfg.Mirror.Platform.Channels </span><span class="cov0" title="0">{
                        ch, found := versionsByChannel[ch.Name]
                        if found </span><span class="cov0" title="0">{
                                cfg.Mirror.Platform.Channels[i] = ch
                        }</span>
                }

                <span class="cov0" title="0">if len(cfg.Mirror.Platform.Channels) &gt; 1 </span><span class="cov0" title="0">{
                        client, err := cincinnati.NewOCPClient(o.uuid)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">newDownloads, err := o.getCrossChannelDownloads(ctx, client, arch, cfg.Mirror.Platform.Channels)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("error calculating cross channel upgrades: %v", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">releaseDownloads.Merge(newDownloads)</span>
                }
        }
        <span class="cov0" title="0">if len(errs) != 0 </span><span class="cov0" title="0">{
                return mmapping, utilerrors.NewAggregate(errs)
        }</span>

        <span class="cov0" title="0">for img := range releaseDownloads </span><span class="cov0" title="0">{
                klog.V(3).Infof("Starting release download for version %s", img)
                opts, err := o.newMirrorReleaseOptions(srcDir)
                if err != nil </span><span class="cov0" title="0">{
                        return mmapping, err
                }</span>
                <span class="cov0" title="0">opts.From = img

                // Create release mapping and get images list
                // before mirroring actions
                mappings, err := o.getMapping(opts)
                if err != nil </span><span class="cov0" title="0">{
                        return mmapping, fmt.Errorf("error retrieving mapping information for %s: %v", img, err)
                }</span>
                <span class="cov0" title="0">mmapping.Merge(mappings)</span>
        }

        <span class="cov0" title="0">err := o.generateReleaseSignatures(ctx, releaseDownloads)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return mmapping, nil</span>
}

// getDownloads will prepare the downloads map for mirroring
func (o *ReleaseOptions) getChannelDownloads(ctx context.Context, c cincinnati.Client, lastChannels []v1alpha2.ReleaseChannel, channel v1alpha2.ReleaseChannel, arch string) (downloads, error) <span class="cov8" title="1">{
        allDownloads := downloads{}

        var prevChannel v1alpha2.ReleaseChannel
        for _, ch := range lastChannels </span><span class="cov8" title="1">{
                if ch.Name == channel.Name </span><span class="cov8" title="1">{
                        prevChannel = ch
                }</span>
        }

        <span class="cov8" title="1">if prevChannel.Name != "" </span><span class="cov8" title="1">{
                // If the requested min version is less than the previous, add downloads
                if prevChannel.MinVersion &gt; channel.MinVersion </span><span class="cov0" title="0">{
                        first, err := semver.Parse(channel.MinVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">last, err := semver.Parse(prevChannel.MinVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">newDownloads := gatherUpdates(current, newest, updates)
                        allDownloads.Merge(newDownloads)</span>
                }

                // If the requested max version is more than the previous, add downloads
                <span class="cov8" title="1">if prevChannel.MaxVersion &lt; channel.MaxVersion </span><span class="cov0" title="0">{
                        first, err := semver.Parse(prevChannel.MaxVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">last, err := semver.Parse(channel.MinVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">newDownloads := gatherUpdates(current, newest, updates)
                        allDownloads.Merge(newDownloads)</span>
                }
        }

        // Plot between min and max of channel
        <span class="cov8" title="1">first, err := semver.Parse(channel.MinVersion)
        if err != nil </span><span class="cov0" title="0">{
                return allDownloads, err
        }</span>
        <span class="cov8" title="1">last, err := semver.Parse(channel.MaxVersion)
        if err != nil </span><span class="cov8" title="1">{
                return allDownloads, err
        }</span>

        <span class="cov8" title="1">var newDownloads downloads
        if channel.ShortestPath </span><span class="cov8" title="1">{
                current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">newDownloads = gatherUpdates(current, newest, updates)</span>

        } else<span class="cov8" title="1"> {
                lowRange, err := semver.ParseRange(fmt.Sprintf("&gt;=%s", first))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">highRange, err := semver.ParseRange(fmt.Sprintf("&lt;=%s", last))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">versions, err := cincinnati.GetUpdatesInRange(ctx, c, channel.Name, arch, highRange.AND(lowRange))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">newDownloads = gatherUpdates(cincinnati.Update{}, cincinnati.Update{}, versions)</span>
        }
        <span class="cov8" title="1">allDownloads.Merge(newDownloads)

        return allDownloads, nil</span>
}

// getCrossChannelDownloads will determine required downloads between channel versions (for OCP only)
func (o *ReleaseOptions) getCrossChannelDownloads(ctx context.Context, ocpClient cincinnati.Client, arch string, channels []v1alpha2.ReleaseChannel) (downloads, error) <span class="cov8" title="1">{
        // Strip any OKD channels from the list
        var ocpChannels []v1alpha2.ReleaseChannel
        for _, ch := range channels </span><span class="cov8" title="1">{
                if ch.Type == v1alpha2.TypeOCP </span><span class="cov8" title="1">{
                        ocpChannels = append(ocpChannels, ch)
                }</span>
        }
        // If no other channels exist, return no downloads
        <span class="cov8" title="1">if len(ocpChannels) == 0 </span><span class="cov0" title="0">{
                return downloads{}, nil
        }</span>

        <span class="cov8" title="1">firstCh, first, err := cincinnati.FindRelease(ocpChannels, true)
        if err != nil </span><span class="cov0" title="0">{
                return downloads{}, fmt.Errorf("failed to find minimum release version: %v", err)
        }</span>
        <span class="cov8" title="1">lastCh, last, err := cincinnati.FindRelease(ocpChannels, false)
        if err != nil </span><span class="cov8" title="1">{
                return downloads{}, fmt.Errorf("failed to find maximum release version: %v", err)
        }</span>
        <span class="cov8" title="1">current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, ocpClient, arch, firstCh, lastCh, first, last)
        if err != nil </span><span class="cov0" title="0">{
                return downloads{}, fmt.Errorf("failed to get upgrade graph: %v", err)
        }</span>
        <span class="cov8" title="1">return gatherUpdates(current, newest, updates), nil</span>
}

func gatherUpdates(current, newest cincinnati.Update, updates []cincinnati.Update) downloads <span class="cov8" title="1">{
        releaseDownloads := downloads{}
        for _, update := range updates </span><span class="cov8" title="1">{
                klog.V(1).Infof("Found update %s", update.Version)
                releaseDownloads[update.Image] = struct{}{}
        }</span>

        <span class="cov8" title="1">if current.Image != "" </span><span class="cov8" title="1">{
                releaseDownloads[current.Image] = struct{}{}
        }</span>

        <span class="cov8" title="1">if newest.Image != "" </span><span class="cov8" title="1">{
                releaseDownloads[newest.Image] = struct{}{}
        }</span>

        <span class="cov8" title="1">return releaseDownloads</span>
}

func (o *ReleaseOptions) newMirrorReleaseOptions(fileDir string) (*release.MirrorOptions, error) <span class="cov8" title="1">{
        opts := release.NewMirrorOptions(o.IOStreams)
        opts.DryRun = o.DryRun
        opts.ToDir = fileDir

        opts.SecurityOptions.Insecure = o.insecure
        opts.SecurityOptions.SkipVerification = o.SkipVerification

        regctx, err := image.NewContext(o.SkipVerification)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating registry context: %v", err)
        }</span>
        <span class="cov8" title="1">opts.SecurityOptions.CachedContext = regctx

        return opts, nil</span>
}

// getMapping will run release mirror with ToMirror set to true to get mapping information
func (o *ReleaseOptions) getMapping(opts *release.MirrorOptions) (image.TypedImageMapping, error) <span class="cov0" title="0">{
        mappingPath := filepath.Join(o.Dir, mappingFile)
        file, err := os.Create(filepath.Clean(mappingPath))
        defer os.Remove(mappingPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        opts.IOStreams.Out = file
        opts.ToMirror = true
        opts.KeepManifestList = true
        if err := opts.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := opts.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mappings, err := image.ReadImageMapping(mappingPath, " ", v1alpha2.TypeOCPReleaseContent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">releaseImageRef, err := image.ParseTypedImage(opts.From, v1alpha2.TypeOCPReleaseContent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dstReleaseRef, ok := mappings[releaseImageRef]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("release images %s not found in mapping", opts.From)
        }</span>
        // Remove and readd the release image to the
        // mapping with the correct repo name and image type.
        <span class="cov0" title="0">mappings.Remove(releaseImageRef)
        dstReleaseRef.Ref.Name = releaseRepo
        mappings.Add(releaseImageRef.TypedImageReference, dstReleaseRef.TypedImageReference, v1alpha2.TypeOCPRelease)

        return mappings, nil</span>
}

// Define download types
type downloads map[string]struct{}

func (d downloads) Merge(in downloads) <span class="cov8" title="1">{
        for k, v := range in </span><span class="cov8" title="1">{
                _, ok := d[k]
                if ok </span><span class="cov0" title="0">{
                        klog.V(1).Infof("download %s exists", k)
                        continue</span>
                }
                <span class="cov8" title="1">d[k] = v</span>
        }
}

//go:embed release-configmap.yaml
var b []byte

func (o *ReleaseOptions) generateReleaseSignatures(ctx context.Context, releaseDownloads downloads) error <span class="cov0" title="0">{

        httpClientConstructor := sigstore.NewCachedHTTPClientConstructor(o.HTTPClient, nil)

        manifests, err := manifest.ParseManifests(bytes.NewReader(b))

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Attempt to load a verifier as defined by the release being mirrored
        <span class="cov0" title="0">imageVerifier, err := verify.NewFromManifests(manifests, httpClientConstructor.HTTPClient)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">signatureBasePath := filepath.Join(o.Dir, config.SourceDir, config.ReleaseSignatureDir)
        if err := os.MkdirAll(signatureBasePath, 0750); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for image := range releaseDownloads </span><span class="cov0" title="0">{
                digest := strings.Split(image, "@")[1]

                if err := imageVerifier.Verify(ctx, digest); err != nil </span><span class="cov0" title="0">{
                        // This may be a OKD release image hence no valid signature
                        klog.Warningf("An image was retrieved that failed verification: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">cmData, err := verify.GetSignaturesAsConfigmap(digest, imageVerifier.Signatures()[digest])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">cmDataBytes, err := util.ConfigMapAsBytes(cmData)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fileName, err := createSignatureFileName(digest)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">signaturePath := filepath.Join(signatureBasePath, fileName)

                if err := os.WriteFile(signaturePath, cmDataBytes, 0640); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func createSignatureFileName(digest string) (string, error) <span class="cov0" title="0">{
        parts := strings.SplitN(digest, ":", 3)
        if len(parts) != 2 || len(parts[0]) == 0 || len(parts[1]) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("the provided digest, %s, must be of the form ALGO:HASH", digest)
        }</span>
        <span class="cov0" title="0">algo, hash := parts[0], parts[1]

        if len(hash) &gt; maxDigestHashLen </span><span class="cov0" title="0">{
                hash = hash[:maxDigestHashLen]
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf(signatureFileNameFmt, algo, hash), nil</span>
}

func (o *ReleaseOptions) HTTPClient() (*http.Client, error) <span class="cov0" title="0">{
        return &amp;http.Client{}, nil
}</span>

// unpackReleaseSignatures will unpack the release signatures if they exist
func (o *MirrorOptions) unpackReleaseSignatures(dstDir string, filesInArchive map[string]string) error <span class="cov0" title="0">{
        if err := unpack(config.ReleaseSignatureDir, dstDir, filesInArchive); err != nil </span><span class="cov0" title="0">{
                nferr := &amp;ErrArchiveFileNotFound{}
                if errors.As(err, &amp;nferr) || errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        klog.V(2).Infof("No release signatures found in archive, skipping")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">klog.Infof("Wrote release signatures to %s", dstDir)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package mirror

import (
        "errors"
        "fmt"

        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
)

// ErrInvalidSequence defines an error in imageset sequencing during
// mirroring operations.
type ErrInvalidSequence struct {
        wantSeq int
        gotSeq  int
}

type ErrMirrorSequence struct {
        msg string
}

func (s *ErrInvalidSequence) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid mirror sequence order, want %v, got %v", s.wantSeq, s.gotSeq)
}</span>

func (s *ErrMirrorSequence) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf(s.msg)
}</span>

func (o *MirrorOptions) checkSequence(incoming, current v1alpha2.Metadata, backendErr error) error <span class="cov8" title="1">{
        switch </span>{
        case backendErr != nil &amp;&amp; !errors.Is(backendErr, storage.ErrMetadataNotExist):<span class="cov8" title="1">
                return backendErr</span>
        case o.SkipMetadataCheck:<span class="cov8" title="1">
                return nil</span>
        case backendErr != nil:<span class="cov8" title="1">
                klog.V(1).Infof("No existing metadata found. Setting up new workspace")
                // Check that this is the first imageset
                incomingRun := incoming.PastMirror
                if incomingRun.Sequence != 1 </span><span class="cov8" title="1">{
                        return &amp;ErrInvalidSequence{1, incomingRun.Sequence}
                }</span>
        default:<span class="cov8" title="1">
                // Complete metadata checks
                // UUID mismatch will now be seen as a new workspace.
                klog.V(3).Info("Checking metadata sequence number")
                currRun := current.PastMirror
                incomingRun := incoming.PastMirror
                // OCPBUGS-4959
                if incomingRun.Sequence == currRun.Sequence </span><span class="cov0" title="0">{
                        return &amp;ErrMirrorSequence{msg: "mirror sequence is the same"}
                }</span>
                <span class="cov8" title="1">if incomingRun.Sequence != (currRun.Sequence + 1) </span><span class="cov8" title="1">{
                        return &amp;ErrInvalidSequence{currRun.Sequence + 1, incomingRun.Sequence}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package mirror

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "net"
        "net/http"
        "os"
        "path"
        "path/filepath"
        "runtime"
        "time"

        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/crane"
        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "k8s.io/klog/v2"
)

const mappingFile = "mapping.txt"

func getRemoteOpts(ctx context.Context, insecure bool) []remote.Option <span class="cov8" title="1">{
        return []remote.Option{
                remote.WithAuthFromKeychain(authn.DefaultKeychain),
                remote.WithTransport(createRT(insecure)),
                remote.WithContext(ctx),
        }
}</span>

func getCraneOpts(ctx context.Context, insecure bool) []crane.Option <span class="cov0" title="0">{
        currentPlatform := v1.Platform{
                Architecture: runtime.GOARCH,
                OS:           runtime.GOOS,
        }
        opts := []crane.Option{
                crane.WithAuthFromKeychain(authn.DefaultKeychain),
                crane.WithTransport(createRT(insecure)),
                crane.WithContext(ctx),
                crane.WithPlatform(&amp;currentPlatform),
        }
        if insecure </span><span class="cov0" title="0">{
                opts = append(opts, crane.Insecure)
        }</span>
        <span class="cov0" title="0">return opts</span>
}

func getNameOpts(insecure bool) (options []name.Option) <span class="cov8" title="1">{
        if insecure </span><span class="cov0" title="0">{
                options = append(options, name.Insecure)
        }</span>
        <span class="cov8" title="1">return options</span>
}

func createRT(insecure bool) http.RoundTripper <span class="cov8" title="1">{
        return &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        // By default, we wrap the transport in retries, so reduce the
                        // default dial timeout to 5s to avoid 5x 30s of connection
                        // timeouts when doing the "ping" on certain http registries.
                        Timeout:   5 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: insecure,
                        MinVersion:         tls.VersionTLS12,
                },
        }
}</span>

func (o *MirrorOptions) createResultsDir() (resultsDir string, err error) <span class="cov0" title="0">{
        resultsDir = filepath.Join(
                o.Dir,
                fmt.Sprintf("results-%v", time.Now().Unix()),
        )
        if err := os.MkdirAll(resultsDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return resultsDir, err
        }</span>
        <span class="cov0" title="0">return resultsDir, nil</span>
}

func (o *MirrorOptions) newMetadataImage(uid string) string <span class="cov8" title="1">{
        repo := path.Join(o.ToMirror, o.UserNamespace, "oc-mirror")
        return fmt.Sprintf("%s:%s", repo, uid)
}</span>

func getTLSConfig() (*tls.Config, error) <span class="cov0" title="0">{
        certPool, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">config := &amp;tls.Config{
                RootCAs:    certPool,
                MinVersion: tls.VersionTLS12,
        }
        return config, nil</span>
}

func (o *MirrorOptions) checkErr(err error, acceptableErr func(error) bool, logMessage func(error) string) error <span class="cov8" title="1">{

        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var skip, skipAllTypes bool
        if acceptableErr != nil </span><span class="cov8" title="1">{
                skip = acceptableErr(err)
        }</span> else<span class="cov0" title="0"> {
                skipAllTypes = true
        }</span>

        <span class="cov8" title="1">message := err.Error()
        if logMessage != nil </span><span class="cov8" title="1">{
                message = logMessage(err)
        }</span>

        // Instead of returning an error, just log it.
        <span class="cov8" title="1">if o.ContinueOnError &amp;&amp; (skip || skipAllTypes) </span><span class="cov8" title="1">{
                klog.Errorf("error: %v", message)
                o.continuedOnError = true
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%v", message)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package version

import (
        "encoding/json"
        "errors"
        "fmt"

        "github.com/spf13/cobra"
        apimachineryversion "k8s.io/apimachinery/pkg/version"
        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"
        "sigs.k8s.io/yaml"

        "github.com/openshift/oc-mirror/pkg/cli"
        "github.com/openshift/oc-mirror/pkg/version"
)

type VersionOptions struct {
        *cli.RootOptions
        Output string
        Short  bool
}

// Version is a struct for version information
type Version struct {
        ClientVersion *apimachineryversion.Info `json:"clientVersion,omitempty" yaml:"clientVersion,omitempty"`
}

func NewVersionCommand(f kcmdutil.Factory, ro *cli.RootOptions) *cobra.Command <span class="cov0" title="0">{
        o := VersionOptions{
                RootOptions: ro,
        }

        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Output version",
                Example: templates.Examples(`
                        # Get oc-mirror version
                        oc-mirror version
                `),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        kcmdutil.CheckErr(o.Validate())
                        kcmdutil.CheckErr(o.Run())
                }</span>,
        }

        <span class="cov0" title="0">fs := cmd.Flags()
        fs.BoolVar(&amp;o.Short, "short", o.Short, "Print just the version number")
        fs.MarkDeprecated("short", "and will be removed in a future release. Use oc-mirror version instead.")
        fs.StringVar(&amp;o.Output, "output", o.Output, "One of 'yaml' or 'json'.")
        flags := cmd.PersistentFlags()
        o.BindFlags(flags)
        flags.MarkDeprecated("verbose", "and will be removed in a future release.")

        return cmd</span>
}

// Validate validates the provided options
func (o *VersionOptions) Validate() error <span class="cov8" title="1">{
        if o.Output != "" &amp;&amp; o.Output != "yaml" &amp;&amp; o.Output != "json" </span><span class="cov8" title="1">{
                return errors.New(`--output must be 'yaml' or 'json'`)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Run executes version command
func (o *VersionOptions) Run() error <span class="cov0" title="0">{
        var versionInfo Version

        clientVersion := version.Get()
        versionInfo.ClientVersion = &amp;clientVersion

        switch o.Output </span>{
        case "":<span class="cov0" title="0">
                if o.Short </span><span class="cov0" title="0">{
                        fmt.Fprintf(o.Out, "Client Version: %s\n", clientVersion.GitVersion)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(o.ErrOut, "WARNING: This version information is deprecated and will be replaced with the output from --short. Use --output=yaml|json to get the full version.\n")
                        fmt.Fprintf(o.Out, "Client Version: %#v\n", clientVersion)
                }</span>
        case "yaml":<span class="cov0" title="0">
                marshalled, err := yaml.Marshal(&amp;versionInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(o.Out, string(marshalled))</span>
        case "json":<span class="cov0" title="0">
                marshalled, err := json.MarshalIndent(&amp;versionInfo, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(o.Out, string(marshalled))</span>
        default:<span class="cov0" title="0">
                // There is a bug in the program if we hit this case.
                // However, we follow a policy of never panicking.
                return fmt.Errorf("VersionOptions were not validated: --output=%q should have been rejected", o.Output)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package config

import (
        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
)

// Complete set default values in the ImageSetConfiguration
// when applicable
func Complete(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        completeReleaseArchitectures(cfg)
}</span>

func completeReleaseArchitectures(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        if len(cfg.Mirror.Platform.Channels) != 0 &amp;&amp; len(cfg.Mirror.Platform.Architectures) == 0 </span><span class="cov8" title="1">{
                cfg.Mirror.Platform.Architectures = []string{v1alpha2.DefaultPlatformArchitecture}
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package config

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "path/filepath"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/yaml"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
)

// TODO(estroz): create interface scheme such that configuration and metadata
// versions do not matter to the caller.
// See https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/config/config.go

// ReadConfig opens an imageset configuration file at the given path
// and loads it into a v1alpha2.ImageSetConfiguration instance for processing and validation.
func ReadConfig(configPath string) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov0" title="0">{

        data, err := ioutil.ReadFile(filepath.Clean(configPath))
        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>
        <span class="cov0" title="0">typeMeta, err := getTypeMeta(data)

        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">switch typeMeta.GroupVersionKind() </span>{
        case v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind):<span class="cov0" title="0">
                c, err = LoadConfig(data)
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>
        default:<span class="cov0" title="0">
                return c, fmt.Errorf("config GVK not recognized: %s", typeMeta.GroupVersionKind())</span>
        }

        <span class="cov0" title="0">Complete(&amp;c)

        return c, Validate(&amp;c)</span>
}

// LoadConfig loads data into a v1alpha2.ImageSetConfiguration instance
func LoadConfig(data []byte) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind)

        if data, err = yaml.YAMLToJSON(data); err != nil </span><span class="cov0" title="0">{
                return c, fmt.Errorf("yaml to json %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;c); err != nil </span><span class="cov8" title="1">{
                return c, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">c.SetGroupVersionKind(gvk)

        return c, nil</span>
}

// LoadMetadata loads data into a v1alpha2.Metadata instance
func LoadMetadata(data []byte) (m v1alpha2.Metadata, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.MetadataKind)

        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;m); err != nil </span><span class="cov8" title="1">{
                return m, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">m.SetGroupVersionKind(gvk)

        return m, nil</span>
}

func getTypeMeta(data []byte) (typeMeta metav1.TypeMeta, err error) <span class="cov0" title="0">{
        if err := yaml.Unmarshal(data, &amp;typeMeta); err != nil </span><span class="cov0" title="0">{
                return typeMeta, fmt.Errorf("get type meta: %v", err)
        }</span>
        <span class="cov0" title="0">return typeMeta, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package config

import (
        "fmt"

        utilerrors "k8s.io/apimachinery/pkg/util/errors"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
)

type validationFunc func(cfg *v1alpha2.ImageSetConfiguration) error

var validationChecks = []validationFunc{validateOperatorOptions, validateReleaseChannels}

// Validate will check an ImagesetConfiguration for input errors.
func Validate(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        var errs []error
        for _, check := range validationChecks </span><span class="cov8" title="1">{
                if err := check(cfg); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("invalid configuration: %v", err))
                }</span>
        }
        <span class="cov8" title="1">return utilerrors.NewAggregate(errs)</span>
}

func validateOperatorOptions(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, ctlg := range cfg.Mirror.Operators </span><span class="cov8" title="1">{
                ctlgName, err := ctlg.GetUniqueName()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if seen[ctlgName] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "catalog %q: duplicate found in configuration", ctlgName,
                        )
                }</span>
                <span class="cov8" title="1">seen[ctlgName] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateReleaseChannels(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, channel := range cfg.Mirror.Platform.Channels </span><span class="cov8" title="1">{
                if seen[channel.Name] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "release channel %q: duplicate found in configuration", channel.Name,
                        )
                }</span>
                <span class="cov8" title="1">seen[channel.Name] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package image

import (
        "context"
        "errors"
        "fmt"
        "io/fs"
        "os"
        "path/filepath"

        ctrsimgmanifest "github.com/containers/image/v5/manifest"
        "github.com/docker/distribution"
        "github.com/docker/distribution/manifest/manifestlist"
        "github.com/docker/distribution/manifest/schema2"
        "github.com/opencontainers/go-digest"
        imgspecv1 "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        "github.com/operator-framework/operator-registry/pkg/image/containerdregistry"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
)

type ErrInvalidImage struct {
        image string
        cause error
}

func (e *ErrInvalidImage) Error() string <span class="cov0" title="0">{
        message := fmt.Sprintf("image %q is invalid or does not exist", e.image)
        if e.cause != nil </span><span class="cov0" title="0">{
                message = fmt.Sprintf("%s: %v", message, e.cause)
        }</span>
        <span class="cov0" title="0">return message</span>
}

type ErrInvalidComponent struct {
        image string
        tag   string
}

func (e *ErrInvalidComponent) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("image %q has invalid component %q", e.image, e.tag)
}</span>

// AssociateLocalImageLayers traverses a V2 directory and gathers all child manifests and layer digest information
// for mirrored images
func AssociateLocalImageLayers(rootDir string, imgMappings TypedImageMapping) (AssociationSet, utilerrors.Aggregate) <span class="cov8" title="1">{
        errs := []error{}
        bundleAssociations := AssociationSet{}

        skipParse := func(ref string) bool </span><span class="cov8" title="1">{
                seen := bundleAssociations.SetContainsKey(ref)
                return seen
        }</span>

        <span class="cov8" title="1">localRoot := filepath.Join(rootDir, config.V2Dir)
        for image, diskLoc := range imgMappings </span><span class="cov8" title="1">{
                if diskLoc.Type != imagesource.DestinationFile </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("image destination for %q is not type file", image.Ref.Exact()))
                        continue</span>
                }
                <span class="cov8" title="1">dirRef := diskLoc.Ref.AsRepository().String()
                imagePath := filepath.Join(localRoot, dirRef)

                // Verify that the dirRef exists before proceeding
                if _, err := os.Stat(imagePath); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, &amp;ErrInvalidImage{image.String(), nil})
                        continue</span>
                }

                <span class="cov8" title="1">var tagOrID string
                if diskLoc.Ref.Tag != "" </span><span class="cov8" title="1">{
                        tagOrID = diskLoc.Ref.Tag
                }</span> else<span class="cov8" title="1"> {
                        tagOrID = diskLoc.Ref.ID
                }</span>

                <span class="cov8" title="1">if tagOrID == "" </span><span class="cov8" title="1">{
                        errs = append(errs, &amp;ErrInvalidComponent{image.String(), tagOrID})
                        continue</span>
                }

                // TODO(estroz): parallelize
                <span class="cov8" title="1">associations, err := associateLocalImageLayers(image.Ref.String(), localRoot, dirRef, tagOrID, "oc-mirror", image.Category, skipParse)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }
                <span class="cov8" title="1">for _, association := range associations </span><span class="cov8" title="1">{
                        bundleAssociations.Add(image.Ref.String(), association)
                }</span>
        }

        <span class="cov8" title="1">return bundleAssociations, utilerrors.NewAggregate(errs)</span>
}

func associateLocalImageLayers(image, localRoot, dirRef, tagOrID, defaultTag string, typ v1alpha2.ImageType, skipParse func(string) bool) (associations []v1alpha2.Association, err error) <span class="cov8" title="1">{
        if skipParse(image) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">manifestPath := filepath.Join(localRoot, filepath.FromSlash(dirRef), "manifests", tagOrID)
        // TODO(estroz): this file mode checking block is likely only necessary
        // for the first recursion leaf since image manifest layers always contain id's,
        // so unroll this component into AssociateImageLayers.

        info, err := os.Lstat(manifestPath)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return nil, &amp;ErrInvalidImage{image, nil}
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Tags are always symlinks due to how `oc` libraries mirror manifest files.
        <span class="cov8" title="1">id, tag := tagOrID, tagOrID
        switch m := info.Mode(); </span>{
        case m&amp;fs.ModeSymlink != 0:<span class="cov8" title="1">
                // Tag is the file name, so follow the symlink to the layer ID-named file.
                dst, err := os.Readlink(manifestPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error evaluating image tag symlink: %v", err)
                }</span>
                <span class="cov8" title="1">id = filepath.Base(dst)</span>
        case m.IsRegular():<span class="cov8" title="1">
                // Layer ID is the file name, and no tag exists.
                tag = defaultTag
                if defaultTag != "" </span><span class="cov8" title="1">{
                        // If set, add a subset of the digest to randomize the
                        // tag in the event multiple digests are pulled for the same
                        // image.
                        partial, err := getPartialDigest(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error calculating partial digest for %s: %v", id, err)
                        }</span>
                        <span class="cov8" title="1">tag = defaultTag + partial
                        manifestDir := filepath.Dir(manifestPath)
                        symlink := filepath.Join(manifestDir, tag)
                        if err := os.Symlink(info.Name(), symlink); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expected symlink or regular file mode, got: %b", m)</span>
        }
        <span class="cov8" title="1">manifestBytes, err := os.ReadFile(filepath.Clean(manifestPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading image manifest file: %v", err)
        }</span>

        <span class="cov8" title="1">association := v1alpha2.Association{
                Name:       image,
                Path:       dirRef,
                ID:         id,
                TagSymlink: tag,
                Type:       typ,
        }
        switch mt := ctrsimgmanifest.GuessMIMEType(manifestBytes); mt </span>{
        case "":<span class="cov0" title="0">
                return nil, errors.New("unparseable manifest mediaType")</span>
        case imgspecv1.MediaTypeImageIndex, ctrsimgmanifest.DockerV2ListMediaType:<span class="cov8" title="1">
                list, err := ctrsimgmanifest.ListFromBlob(manifestBytes, mt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, instance := range list.Instances() </span><span class="cov8" title="1">{
                        digestStr := instance.String()
                        // Add manifest references so publish can recursively look up image layers
                        // for the manifests of this list.
                        association.ManifestDigests = append(association.ManifestDigests, digestStr)
                        // Recurse on child manifests, which should be in the same directory
                        // with the same file name as it's digest.
                        childAssocs, err := associateLocalImageLayers(digestStr, localRoot, dirRef, digestStr, "", typ, skipParse)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">associations = append(associations, childAssocs...)</span>
                }
        default:<span class="cov8" title="1">
                // Treat all others as image manifests.
                manifest, err := ctrsimgmanifest.FromBlob(manifestBytes, mt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, layerInfo := range manifest.LayerInfos() </span><span class="cov8" title="1">{
                        association.LayerDigests = append(association.LayerDigests, layerInfo.Digest.String())
                }</span>
                // The config is just another blob, so associate it opaquely.
                <span class="cov8" title="1">association.LayerDigests = append(association.LayerDigests, manifest.ConfigInfo().Digest.String())</span>
        }

        <span class="cov8" title="1">associations = append(associations, association)

        return associations, nil</span>
}

// AssociateRemoteImageLayers queries remote manifests and gathers all child manifests and layer digest information
// for mirrored images
func AssociateRemoteImageLayers(ctx context.Context, imgMappings TypedImageMapping, skipTlS, plainHTTP, skipVerification bool) (AssociationSet, utilerrors.Aggregate) <span class="cov8" title="1">{
        var insecure bool
        if skipTlS || plainHTTP </span><span class="cov8" title="1">{
                insecure = true
        }</span>
        <span class="cov8" title="1">errs := []error{}
        bundleAssociations := AssociationSet{}

        skipParse := func(ref string) bool </span><span class="cov8" title="1">{
                seen := bundleAssociations.SetContainsKey(ref)
                return seen
        }</span>

        <span class="cov8" title="1">resolver, err := containerdregistry.NewResolver("", skipTlS, plainHTTP, nil)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("error creating image resolver: %v", err)
                return bundleAssociations, utilerrors.NewAggregate([]error{err})
        }</span>

        <span class="cov8" title="1">regctx, err := NewContext(skipVerification)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("error creating registry context: %v", err)
                return bundleAssociations, utilerrors.NewAggregate([]error{err})
        }</span>

        <span class="cov8" title="1">for srcImg, dstImg := range imgMappings </span><span class="cov8" title="1">{
                if dstImg.Type != imagesource.DestinationRegistry </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("image destination for %q is not type registry", srcImg.Ref.Exact()))
                        continue</span>
                }

                <span class="cov8" title="1">if srcImg.Ref.ID == "" </span><span class="cov8" title="1">{
                        if srcImg.Ref.Tag == "" </span><span class="cov8" title="1">{
                                errs = append(errs, &amp;ErrInvalidComponent{srcImg.String(), srcImg.Ref.Tag})
                                continue</span>
                        }
                        <span class="cov8" title="1">imgWithID, err := ResolveToPin(ctx, resolver, srcImg.Ref.Exact())
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, &amp;ErrInvalidImage{srcImg.String(), err})
                                continue</span>
                        }
                        <span class="cov8" title="1">pinnedRef, err := imagesource.ParseReference(imgWithID)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("error parsing source image %s: %v", imgWithID, err))
                                continue</span>
                        }
                        <span class="cov8" title="1">srcImg.Ref.ID = pinnedRef.Ref.ID</span>
                }

                <span class="cov8" title="1">repo, err := regctx.RepositoryForRef(ctx, srcImg.Ref, insecure)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, &amp;ErrInvalidImage{srcImg.Ref.Exact(), err})
                        continue</span>
                }

                <span class="cov8" title="1">ms, err := repo.Manifests(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("open blob: %v", err))
                        continue</span>
                }

                // TODO(estroz): parallelize
                <span class="cov8" title="1">associations, err := associateRemoteImageLayers(ctx, srcImg.String(), dstImg.String(), srcImg, ms, skipParse, insecure)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }
                <span class="cov8" title="1">for _, association := range associations </span><span class="cov8" title="1">{
                        bundleAssociations.Add(srcImg.String(), association)
                }</span>
        }

        <span class="cov8" title="1">return bundleAssociations, utilerrors.NewAggregate(errs)</span>
}

func associateRemoteImageLayers(ctx context.Context, srcImg, dstImg string, srcInfo TypedImage, ms distribution.ManifestService, skipParse func(string) bool, insecure bool) (associations []v1alpha2.Association, err error) <span class="cov8" title="1">{
        if skipParse(srcImg) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">dgst, err := digest.Parse(srcInfo.Ref.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">mn, err := ms.Get(ctx, dgst, preferManifestList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;ErrInvalidImage{srcImg, err}
        }</span>
        <span class="cov8" title="1">mt, payload, err := mn.Payload()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">association := v1alpha2.Association{
                Name:       srcImg,
                Path:       dstImg,
                ID:         srcInfo.Ref.ID,
                TagSymlink: srcInfo.Ref.Tag,
                Type:       srcInfo.Category,
        }
        switch mt </span>{
        case "":<span class="cov0" title="0">
                return nil, errors.New("unparseable manifest mediaType")</span>
        case imgspecv1.MediaTypeImageIndex, ctrsimgmanifest.DockerV2ListMediaType:<span class="cov8" title="1">
                list, err := ctrsimgmanifest.ListFromBlob(payload, mt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, instance := range list.Instances() </span><span class="cov8" title="1">{
                        digestStr := instance.String()
                        // Add manifest references so publish can recursively look up image layers
                        // for the manifests of this list.
                        association.ManifestDigests = append(association.ManifestDigests, digestStr)
                        // Recurse on child manifests, which should be in the same directory
                        // with the same file name as it's digest.
                        childInfo := srcInfo
                        childInfo.Ref.ID = digestStr
                        childInfo.Ref.Tag = ""
                        childAssocs, err := associateRemoteImageLayers(ctx, digestStr, dstImg, childInfo, ms, skipParse, insecure)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">associations = append(associations, childAssocs...)</span>
                }
        default:<span class="cov8" title="1">
                // Treat all others as image manifests.
                manifest, err := ctrsimgmanifest.FromBlob(payload, mt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, layerInfo := range manifest.LayerInfos() </span><span class="cov8" title="1">{
                        association.LayerDigests = append(association.LayerDigests, layerInfo.Digest.String())
                }</span>
                // The config is just another blob, so associate it opaquely.
                <span class="cov8" title="1">association.LayerDigests = append(association.LayerDigests, manifest.ConfigInfo().Digest.String())</span>
        }

        <span class="cov8" title="1">associations = append(associations, association)

        return associations, nil</span>
}

// PreferManifestList specifically requests a manifest list first
var preferManifestList = distribution.WithManifestMediaTypes([]string{
        manifestlist.MediaTypeManifestList,
        schema2.MediaTypeManifest,
        imgspecv1.MediaTypeImageManifest,
        imgspecv1.MediaTypeImageIndex,
})
</pre>
		
		<pre class="file" id="file44" style="display: none">package image

import (
        "encoding/gob"
        "errors"
        "fmt"
        "io"
        "path/filepath"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"
)

// Associations is a map for Association
// searching
type Associations map[string]v1alpha2.Association

// AssociationSet is a set of image Associations
// mapped to their images
type AssociationSet map[string]Associations

// Search will return all Associations for the specificed key
func (as AssociationSet) Search(key string) (values []v1alpha2.Association, found bool) <span class="cov8" title="1">{
        assocs, found := as[key]
        values = make([]v1alpha2.Association, len(assocs))
        count := 0
        for _, value := range assocs </span><span class="cov8" title="1">{
                values[count] = value
                count++
        }</span>
        <span class="cov8" title="1">return</span>
}

// UpdateKey will move values under oldKey to newKey in Assocations.
// Old entries will be deleted.
func (as AssociationSet) UpdateKey(oldKey, newKey string) error <span class="cov8" title="1">{

        // make sure we don't delete the
        // same key we just set
        if newKey == oldKey </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">values, found := as.Search(oldKey)
        if !found </span><span class="cov0" title="0">{
                return errors.New("key does not exist in map")
        }</span>
        <span class="cov8" title="1">as.Add(newKey, values...)
        delete(as, oldKey)

        return nil</span>
}

// UpdateValue will update the Association values for a given key
func (as AssociationSet) UpdateValue(key string, value v1alpha2.Association) error <span class="cov8" title="1">{

        assocs, found := as[key]
        if !found </span><span class="cov0" title="0">{
                return errors.New("key does not exist in map")
        }</span>
        <span class="cov8" title="1">assocs[value.Name] = value

        return nil</span>
}

// Add stores a key-value pair in this multimap.
func (as AssociationSet) Add(key string, values ...v1alpha2.Association) <span class="cov8" title="1">{
        assocs, found := as[key]
        for _, value := range values </span><span class="cov8" title="1">{
                if found </span><span class="cov8" title="1">{
                        assocs[value.Name] = value
                }</span> else<span class="cov8" title="1"> {
                        assocs = make(Associations)
                        assocs[value.Name] = value
                        as[key] = assocs
                }</span>
        }
}

// Keys returns all unique keys contained in map
func (as AssociationSet) Keys() []string <span class="cov8" title="1">{
        keys := make([]string, len(as))
        count := 0
        for key := range as </span><span class="cov8" title="1">{
                keys[count] = key
                count++
        }</span>
        <span class="cov8" title="1">return keys</span>
}

// SetContainsKey checks if the AssociationSet map contains a key
func (as AssociationSet) SetContainsKey(key string) (found bool) <span class="cov8" title="1">{
        _, found = as[key]
        return
}</span>

// ContainsKey checks if the Associations map contains the specified key
func (as AssociationSet) ContainsKey(setKey, key string) (found bool) <span class="cov8" title="1">{
        asSet, found := as[setKey]
        if !found </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">_, found = asSet[key]
        return</span>
}

// Merge Associations into the receiver.
func (as AssociationSet) Merge(in AssociationSet) <span class="cov8" title="1">{
        for imageName, assocs := range in </span><span class="cov8" title="1">{
                for _, value := range assocs </span><span class="cov8" title="1">{
                        as.Add(imageName, value)
                }</span>
        }
}

// Encode Associations in an efficient, opaque format.
func (as AssociationSet) Encode(w io.Writer) error <span class="cov0" title="0">{
        if err := as.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid image associations: %v", err)
        }</span>
        <span class="cov0" title="0">enc := gob.NewEncoder(w)
        if err := enc.Encode(as); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error encoding image associations: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Decode Associations from an opaque format. Only useable if Associations
// was encoded with Encode().
func (as *AssociationSet) Decode(r io.Reader) error <span class="cov0" title="0">{
        dec := gob.NewDecoder(r)
        if err := dec.Decode(as); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error decoding image associations: %v", err)
        }</span>
        // Update paths for local usage.
        <span class="cov0" title="0">for imageName, assocs := range *as </span><span class="cov0" title="0">{
                for _, assoc := range assocs </span><span class="cov0" title="0">{
                        assoc.Path = filepath.FromSlash(assoc.Path)
                        if err := as.UpdateValue(imageName, assoc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// UpdatePath path will update path values for local
// AssociationSet use
func (as *AssociationSet) UpdatePath() error <span class="cov0" title="0">{
        // Update paths for local usage.
        for imageName, assocs := range *as </span><span class="cov0" title="0">{
                for _, assoc := range assocs </span><span class="cov0" title="0">{
                        assoc.Path = filepath.FromSlash(assoc.Path)
                        if err := as.UpdateValue(imageName, assoc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Validate AssociationSet and all contained Associations
func (as AssociationSet) Validate() error <span class="cov0" title="0">{
        var errs []error
        for imageName, assocs := range as </span><span class="cov0" title="0">{
                for _, assoc := range assocs </span><span class="cov0" title="0">{
                        if len(assoc.ManifestDigests) != 0 </span><span class="cov0" title="0">{
                                for _, digest := range assoc.ManifestDigests </span><span class="cov0" title="0">{
                                        if _, found := assocs[digest]; !found </span><span class="cov0" title="0">{
                                                errs = append(errs, fmt.Errorf("image %q: digest %s not found", imageName, digest))
                                                continue</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if err := assoc.Validate(); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return utilerrors.NewAggregate(errs)</span>
}

// GetDigests will return all layer and manifest digests in the AssociationSet
func (as *AssociationSet) GetDigests() []string <span class="cov8" title="1">{
        var digests []string
        for _, assocs := range *as </span><span class="cov8" title="1">{
                for _, assoc := range assocs </span><span class="cov8" title="1">{
                        digests = append(digests, assoc.LayerDigests...)
                        digests = append(digests, assoc.ManifestDigests...)
                        digests = append(digests, assoc.ID)
                }</span>
        }
        <span class="cov8" title="1">return digests</span>
}

// AssocPathsForBlobs returns a map with the first association path found
// for each layer digest in the Association Set. This can be used
// to pull layers to reform images. As defined in the Association spec,
// the path can be a local or remote reference.
func AssocPathsForBlobs(as AssociationSet) map[string]string <span class="cov8" title="1">{
        reposByBlob := map[string]string{}
        for _, assocs := range as </span><span class="cov8" title="1">{
                for _, assoc := range assocs </span><span class="cov8" title="1">{
                        for _, dgst := range assoc.LayerDigests </span><span class="cov8" title="1">{
                                if _, found := reposByBlob[dgst]; found </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">reposByBlob[dgst] = assoc.Path</span>
                        }
                }
        }
        <span class="cov8" title="1">return reposByBlob</span>
}

// Prune will return a pruned AssociationSet containing provided keys
func Prune(in AssociationSet, keepKey []string) (AssociationSet, error) <span class="cov0" title="0">{
        // return a new map with the pruned mapping
        pruned := AssociationSet{}
        for _, key := range keepKey </span><span class="cov0" title="0">{
                assocs, ok := in[key]
                if !ok </span><span class="cov0" title="0">{
                        return pruned, fmt.Errorf("key %s does not exist in provided associations", key)
                }</span>
                <span class="cov0" title="0">pruned[key] = assocs</span>
        }
        <span class="cov0" title="0">return pruned, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package builder

import (
        "archive/tar"
        "bytes"
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/go-logr/logr"
        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/layout"
        "github.com/google/go-containerregistry/pkg/v1/match"
        "github.com/google/go-containerregistry/pkg/v1/mutate"
        "github.com/google/go-containerregistry/pkg/v1/partial"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/google/go-containerregistry/pkg/v1/tarball"
        "github.com/google/go-containerregistry/pkg/v1/types"
        "k8s.io/klog/v2"
)

// ImageBuilder use an OCI workspace to add layers and change configuration to images.
type ImageBuilder struct {
        NameOpts   []name.Option
        RemoteOpts []remote.Option
        Logger     klog.Logger
}

// ErrInvalidReference is returned the target reference is a digest.
type ErrInvalidReference struct {
        image string
}

func (e ErrInvalidReference) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("target reference %q must have a tag reference", e.image)
}</span>

// NewImageBuilder creates a new instance of an ImageBuilder.
func NewImageBuilder(nameOpts []name.Option, remoteOpts []remote.Option) *ImageBuilder <span class="cov8" title="1">{
        b := &amp;ImageBuilder{
                NameOpts:   nameOpts,
                RemoteOpts: remoteOpts,
        }
        b.init()
        return b
}</span>

func (b *ImageBuilder) init() <span class="cov8" title="1">{
        if b.Logger == (logr.Logger{}) </span><span class="cov8" title="1">{
                b.Logger = klog.NewKlogr()
        }</span>
}

/*
configUpdateFunc allows callers of ImageBuilder.Run to modify the *v1.ConfigFile argument as appropriate for
the circumstances.
*/
type configUpdateFunc func(*v1.ConfigFile)

/*
Run modifies and pushes the catalog image existing in an OCI layout. The image configuration will be updated
with the required labels and any provided layers will be appended.

# Arguments

• ctx: a cancellation context

• targetRef: a docker image reference

• layoutPath: an OCI image layout path

• update: an optional function that allows callers to modify the *v1.ConfigFile if necessary

• layers: zero or more layers to add to the images discovered during processing

# Returns

error: non-nil on error, nil otherwise
*/
func (b *ImageBuilder) Run(ctx context.Context, targetRef string, layoutPath layout.Path, update configUpdateFunc, layers ...v1.Layer) error <span class="cov8" title="1">{
        b.init()
        var v2format bool

        // Target can't have a digest since we are
        // adding layers and possibly updating the
        // configuration. This will result in a failure
        // due to computed hash differences.
        targetIdx := strings.Index(targetRef, "@")
        if targetIdx != -1 </span><span class="cov8" title="1">{
                return &amp;ErrInvalidReference{targetRef}
        }</span>

        <span class="cov8" title="1">tag, err := name.NewTag(targetRef, b.NameOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">idx, err := layoutPath.ImageIndex()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // make a copy of the original manifest for later
        <span class="cov8" title="1">originalIdxManifest, err := idx.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">originalIdxManifest = originalIdxManifest.DeepCopy()

        // process the image index for updates to images discovered along the way
        resultIdx, err := b.processImageIndex(ctx, idx, &amp;v2format, update, targetRef, layers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure the index media type is a docker manifest list
        // if child manifests are docker V2 schema
        <span class="cov8" title="1">if v2format </span><span class="cov8" title="1">{
                resultIdx = mutate.IndexMediaType(resultIdx, types.DockerManifestList)
        }</span>
        // get the hashes from the original manifest since we need to remove them
        <span class="cov8" title="1">originalHashes := []v1.Hash{}
        for _, desc := range originalIdxManifest.Manifests </span><span class="cov8" title="1">{
                originalHashes = append(originalHashes, desc.Digest)
        }</span>
        // write out the index, replacing the old value
        <span class="cov8" title="1">err = layoutPath.ReplaceIndex(resultIdx, match.Digests(originalHashes...))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // "Pull" the updated index
        <span class="cov8" title="1">idx, err = layoutPath.ImageIndex()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // while it's entirely valid to have nested "manifest list" (i.e. an ImageIndex) within an OCI layout,
        // this does NOT work for remote registries. So if we have those, then we need to get the nested
        // ImageIndex and push that to the remote registry. In theory there could be any number of nested
        // ImageIndexes, but in practice, there's only one level deep, and its a "singleton".
        <span class="cov8" title="1">topLevelIndexManifest, err := idx.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var imageIndexToPush v1.ImageIndex
        for _, descriptor := range topLevelIndexManifest.Manifests </span><span class="cov8" title="1">{
                if descriptor.MediaType.IsImage() </span><span class="cov0" title="0">{
                        // if we find an image, then this top level index can be used to push to remote registry
                        imageIndexToPush = idx
                        // no need to look any further
                        break</span>
                } else<span class="cov8" title="1"> if descriptor.MediaType.IsIndex() </span><span class="cov8" title="1">{
                        // if we find an image index, we can push that to the remote registry
                        imageIndexToPush, err = idx.ImageIndex(descriptor.Digest)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // we're not going to look any deeper or look for other indexes at this level
                        <span class="cov8" title="1">break</span>
                }
        }
        // push to the remote
        <span class="cov8" title="1">return remote.WriteIndex(tag, imageIndexToPush, b.RemoteOpts...)</span>
}

/*
processImageIndex is a recursive helper function that allows for traversal of the hierarchy of
parent/child indexes that can exist for a multi arch image. There's always
at least one index at the root since this is an OCI layout that we're dealing with.
In theory there can be "infinite levels" of "index indirection" for multi arch images, but typically
its only two levels deep (i.e. index.json itself which is level one, and the manifest list
defined in the blobs directory, which is level two).

Each image that is encountered is updated using the update function (if provided) and whatever layers are provided.

# Arguments

• ctx: a cancellation context

• idx: the "current" image index for this stage of recursion

• v2format: a boolean used to keep track of the type of image we're dealing with. false means OCI media types
should be used and true means docker v2s2 media types should be used

• update: an optional function that allows callers to modify the *v1.ConfigFile if necessary

• targetRef: the docker image reference, which is only used for error reporting in this function

• layers: zero or more layers to add to the images discovered during processing

# Returns

• v1.ImageIndex: The resulting image index after processing has completed. Will be nil if an error occurs, otherwise non-nil.

• error: non-nil if an error occurs, nil otherwise
*/
func (b *ImageBuilder) processImageIndex(ctx context.Context, idx v1.ImageIndex, v2format *bool, update configUpdateFunc, targetRef string, layers ...v1.Layer) (v1.ImageIndex, error) <span class="cov8" title="1">{
        var resultIdx v1.ImageIndex
        resultIdx = idx
        idxManifest, err := idx.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, manifest := range idxManifest.Manifests </span><span class="cov8" title="1">{
                currentHash := *manifest.Digest.DeepCopy()
                switch manifest.MediaType </span>{
                case types.DockerManifestList, types.OCIImageIndex:<span class="cov8" title="1">
                        innerIdx, err := idx.ImageIndex(currentHash)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // recursive call
                        <span class="cov8" title="1">processedIdx, err := b.processImageIndex(ctx, innerIdx, v2format, update, targetRef, layers...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">resultIdx = processedIdx
                        // making an assumption here that at any given point in the parent/child
                        // hierarchy, there's only a single image index entry
                        return resultIdx, nil</span>
                case types.DockerManifestSchema2:<span class="cov8" title="1">
                        *v2format = true</span>
                case types.OCIManifestSchema1:<span class="cov0" title="0">
                        *v2format = false</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("image %q: unsupported manifest format %q", targetRef, manifest.MediaType)</span>
                }

                <span class="cov8" title="1">img, err := idx.Image(currentHash)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Add new layers to image.
                // Ensure they have the right media type.
                <span class="cov8" title="1">var mt types.MediaType
                if *v2format </span><span class="cov8" title="1">{
                        mt = types.DockerLayer
                }</span> else<span class="cov0" title="0"> {
                        mt = types.OCILayer
                }</span>
                <span class="cov8" title="1">additions := make([]mutate.Addendum, 0, len(layers))
                for _, layer := range layers </span><span class="cov8" title="1">{
                        additions = append(additions, mutate.Addendum{Layer: layer, MediaType: mt})
                }</span>
                <span class="cov8" title="1">img, err = mutate.Append(img, additions...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if update != nil </span><span class="cov8" title="1">{
                        // Update image config
                        cfg, err := img.ConfigFile()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">update(cfg)
                        img, err = mutate.Config(img, cfg.Config)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">desc, err := partial.Descriptor(img)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // if the platform is not set, we need to attempt to do something about that
                <span class="cov8" title="1">if desc.Platform == nil </span><span class="cov8" title="1">{
                        if manifest.Platform != nil </span><span class="cov8" title="1">{
                                // use the value from the manifest
                                desc.Platform = manifest.Platform
                        }</span> else<span class="cov8" title="1"> {
                                if config, err := img.ConfigFile(); err != nil </span><span class="cov0" title="0">{
                                        // we can't get the config file so fall back to linux/amd64
                                        desc.Platform = &amp;v1.Platform{Architecture: "amd64", OS: "linux"}
                                }</span> else<span class="cov8" title="1"> {
                                        // if one of the required values is missing, fall back to linux/amd64
                                        if config.Architecture == "" || config.OS == "" </span><span class="cov8" title="1">{
                                                desc.Platform = &amp;v1.Platform{Architecture: "amd64", OS: "linux"}
                                        }</span> else<span class="cov0" title="0"> {
                                                // use the value provided by the image config
                                                desc.Platform = &amp;v1.Platform{Architecture: config.Architecture, OS: config.OS}
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">add := mutate.IndexAddendum{
                        Add:        img,
                        Descriptor: *desc,
                }
                modifiedIndex := mutate.AppendManifests(mutate.RemoveManifests(resultIdx, match.Digests(currentHash)), add)
                resultIdx = modifiedIndex</span>
        }
        <span class="cov8" title="1">return resultIdx, nil</span>
}

/*
CreateLayout will create an OCI image layout from an image or return
a layout path from an existing OCI layout.

# Arguments

• srcRef: if empty string, the dir argument is used for the layout.Path, otherwise
this value is used to pull an image into dir.

• dir: a pre-populated OCI layout directory if srcRef is empty string, otherwise
this directory will be created

# Returns

• layout.Path: a OCI layout path if successful or an empty string if an error occurs

• error: non-nil if an error occurs, nil otherwise
*/
func (b *ImageBuilder) CreateLayout(srcRef, dir string) (layout.Path, error) <span class="cov8" title="1">{
        b.init()
        if srcRef == "" </span><span class="cov8" title="1">{
                b.Logger.V(1).Info("Using existing OCI layout to " + dir)
                return layout.FromPath(dir)
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(dir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // Pull source reference image
        <span class="cov8" title="1">ref, err := name.ParseReference(srcRef, b.NameOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">idx, err := remote.Index(ref, b.RemoteOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">b.Logger.V(1).Info("Writing OCI layout to " + dir)
        return layout.Write(dir, idx)</span>
}

// LayerFromPath will write the contents of the path(s) the target
// directory and build a v1.Layer
func LayerFromPath(targetPath, path string) (v1.Layer, error) <span class="cov8" title="1">{
        return LayerFromPathWithUidGid(targetPath, path, -1, -1)
}</span>

// LayerFromPath will write the contents of the path(s) the target
// directory specifying the target UID/GID and build a v1.Layer.
// Use gid = -1 , uid = -1 if you don't want to override.
func LayerFromPathWithUidGid(targetPath, path string, uid int, gid int) (v1.Layer, error) <span class="cov8" title="1">{
        var b bytes.Buffer
        tw := tar.NewWriter(&amp;b)

        pathInfo, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">processPaths := func(hdr *tar.Header, info os.FileInfo, fp string) error </span><span class="cov8" title="1">{
                if !info.IsDir() </span><span class="cov8" title="1">{
                        hdr.Size = info.Size()
                }</span>
                <span class="cov8" title="1">hdr.ChangeTime = time.Now()
                if info.Mode().IsDir() </span><span class="cov8" title="1">{
                        hdr.Typeflag = tar.TypeDir
                }</span> else<span class="cov8" title="1"> if info.Mode().IsRegular() </span><span class="cov8" title="1">{
                        hdr.Typeflag = tar.TypeReg
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("not implemented archiving file type %s (%s)", info.Mode(), info.Name())
                }</span>

                <span class="cov8" title="1">if err := tw.WriteHeader(hdr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write tar header: %w", err)
                }</span>
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        f, err := os.Open(filepath.Clean(fp))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if _, err := io.Copy(tw, f); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read file into the tar: %w", err)
                        }</span>
                        <span class="cov8" title="1">err = f.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if pathInfo.IsDir() </span><span class="cov8" title="1">{
                err := filepath.Walk(path, func(fp string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">rel, err := filepath.Rel(path, fp)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to calculate relative path: %w", err)
                        }</span>

                        <span class="cov8" title="1">hdr := &amp;tar.Header{
                                Name: filepath.Join(targetPath, filepath.ToSlash(rel)),
                                Mode: int64(info.Mode()),
                        }
                        if uid != -1 </span><span class="cov0" title="0">{
                                hdr.Uid = uid
                        }</span>
                        <span class="cov8" title="1">if gid != -1 </span><span class="cov0" title="0">{
                                hdr.Gid = gid
                        }</span>
                        <span class="cov8" title="1">if err := processPaths(hdr, info, fp); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan files: %w", err)
                }</span>

        } else<span class="cov8" title="1"> {
                base := filepath.Base(path)
                hdr := &amp;tar.Header{
                        Name: filepath.Join(targetPath, filepath.ToSlash(base)),
                        Mode: int64(pathInfo.Mode()),
                }
                if uid != -1 </span><span class="cov0" title="0">{ // uid was specified in the input param
                        hdr.Uid = uid
                }</span>
                <span class="cov8" title="1">if gid != -1 </span><span class="cov0" title="0">{ // gid was specified in the input param
                        hdr.Gid = gid
                }</span>
                <span class="cov8" title="1">if err := processPaths(hdr, pathInfo, path); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if err := tw.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to finish tar: %w", err)
        }</span>
        <span class="cov8" title="1">return tarball.LayerFromReader(&amp;b)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package image

import (
        "fmt"

        utilerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
)

// ConvertToAssociationSet will return an AssociationSet from a slice of Associations
func ConvertToAssociationSet(assocs []v1alpha2.Association) (AssociationSet, error) <span class="cov8" title="1">{
        assocSet := AssociationSet{}

        assocMapping := make(map[string]v1alpha2.Association, len(assocs))
        var errs []error
        for _, a := range assocs </span><span class="cov8" title="1">{
                if err := a.Validate(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                // The association name itself
                // is not unique because images can
                // share child manifest so using the
                // name and path/image as the key for
                // unique combination.
                <span class="cov8" title="1">assocMapping[a.Name+a.Path] = a</span>
        }
        <span class="cov8" title="1">if len(errs) != 0 </span><span class="cov0" title="0">{
                return assocSet, utilerrors.NewAggregate(errs)
        }</span>

        // Process and remove all index manifest and the child image manifests
        <span class="cov8" title="1">visited := make(map[string]struct{}, len(assocMapping))
        for _, value := range assocMapping </span><span class="cov8" title="1">{
                if len(value.ManifestDigests) != 0 </span><span class="cov8" title="1">{
                        if ok := assocSet.SetContainsKey(value.Name); !ok </span><span class="cov8" title="1">{
                                assocSet[value.Name] = make(Associations)
                        }</span>
                        <span class="cov8" title="1">assocSet.Add(value.Name, value)
                        for _, digest := range value.ManifestDigests </span><span class="cov8" title="1">{
                                klog.V(4).Info("image %q: processing child manifest %s", value.Name, digest)
                                child, ok := assocMapping[digest+value.Path]
                                if !ok </span><span class="cov8" title="1">{
                                        return assocSet, fmt.Errorf("invalid associations: association for %q is missing", digest)
                                }</span>
                                <span class="cov8" title="1">assocSet.Add(value.Name, child)
                                visited[child.Name] = struct{}{}</span>
                        }
                        <span class="cov8" title="1">visited[value.Name] = struct{}{}</span>
                }
        }

        // Process image manifests with no parent
        <span class="cov8" title="1">for _, value := range assocMapping </span><span class="cov8" title="1">{
                if _, found := visited[value.Name]; !found </span><span class="cov8" title="1">{
                        assocSet.Add(value.Name, value)
                }</span>
        }

        <span class="cov8" title="1">return assocSet, nil</span>
}

// ConvertFromAssociationSet will return a slice of Association from an AssociationSet
func ConvertFromAssociationSet(assocSet AssociationSet) ([]v1alpha2.Association, error) <span class="cov0" title="0">{
        assocs := []v1alpha2.Association{}
        var errs []error
        for _, as := range assocSet </span><span class="cov0" title="0">{
                for _, a := range as </span><span class="cov0" title="0">{
                        if err := a.Validate(); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">assocs = append(assocs, a)</span>
                }
        }
        <span class="cov0" title="0">return assocs, utilerrors.NewAggregate(errs)</span>
}

// ConvertToTypedMapping will return a TypedMappingFrom an AssociationSet
func ConvertToTypedMapping(assocs []v1alpha2.Association) (TypedImageMapping, error) <span class="cov8" title="1">{
        mapping := TypedImageMapping{}
        var errs []error
        childManifest := make(map[string]struct{})
        for _, a := range assocs </span><span class="cov8" title="1">{
                if err := a.Validate(); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                        continue</span>
                }
                <span class="cov8" title="1">for _, digest := range a.ManifestDigests </span><span class="cov8" title="1">{
                        childManifest[digest] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">for _, a := range assocs </span><span class="cov8" title="1">{
                if _, ok := childManifest[a.Name]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">typedImg, err := ParseReference(a.Name)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }
                <span class="cov8" title="1">mapping.Add(typedImg, typedImg, a.Type)</span>
        }
        <span class="cov8" title="1">return mapping, utilerrors.NewAggregate(errs)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package image

import (
        "errors"
        "os"
        "path/filepath"

        dockercfg "github.com/docker/cli/cli/config"
        "github.com/openshift/library-go/pkg/image/registryclient"
        "github.com/openshift/oc/pkg/cli/image/manifest/dockercredentials"
        "k8s.io/client-go/rest"
)

// NewContext creates a context for the registryClient of `oc mirror`
func NewContext(skipVerification bool) (*registryclient.Context, error) <span class="cov8" title="1">{
        userAgent := rest.DefaultKubernetesUserAgent()
        rt, err := rest.TransportFor(&amp;rest.Config{UserAgent: userAgent})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">insecureRT, err := rest.TransportFor(&amp;rest.Config{TLSClientConfig: rest.TLSClientConfig{Insecure: true}, UserAgent: userAgent})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ctx := registryclient.NewContext(rt, insecureRT)

        // Set default options
        var registryConfig string
        dockerConfigJSON := filepath.Join(dockercfg.Dir(), dockercfg.ConfigFileName)
        switch _, err := os.Stat(dockerConfigJSON); </span>{
        case err == nil:<span class="cov8" title="1">
                registryConfig = dockerConfigJSON</span>
        case errors.Is(err, os.ErrNotExist):<span class="cov0" title="0">
                podmanConfig := filepath.Join(os.Getenv("XDG_RUNTIME_DIR"), "containers/auth.json")
                if _, err := os.Stat(podmanConfig); err == nil </span><span class="cov0" title="0">{
                        registryConfig = podmanConfig
                }</span> else<span class="cov0" title="0"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if len(registryConfig) != 0 </span><span class="cov8" title="1">{
                creds, err := dockercredentials.NewCredentialStoreFactory(registryConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ctx.WithCredentialsFactory(creds)</span>
        }
        <span class="cov8" title="1">ctx.Retries = 3
        ctx.DisableDigestVerification = skipVerification
        return ctx, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package image

import (
        "fmt"

        "github.com/opencontainers/go-digest"
)

// getPartialDigest returns the first 6 characters of a digest,
// if valid. The purpose is to use this as a unique image tag.
// The since the algorithm and deletimeter are the first 7 characters,
// range 7-13 is used here.
// Ex. sha256:fc07c1e2a5f012320ae672ca8546ff0d09eb8dba3c5acbbfc426c7984169ee84
// would result in fc07c1.
func getPartialDigest(d string) (string, error) <span class="cov8" title="1">{
        _, err := digest.Parse(d)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">tagStart := 7
        tagEnd := 13

        if len(d) &lt; tagEnd </span><span class="cov0" title="0">{
                return "", fmt.Errorf("digest %q does not meet length requirements for partial calculations", d)
        }</span>
        <span class="cov8" title="1">return d[tagStart:tagEnd], nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package image

import (
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        gcr "github.com/google/go-containerregistry/pkg/v1/layout"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        libgoref "github.com/openshift/library-go/pkg/image/reference"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
)

var (
        DestinationOCI imagesource.DestinationType = "oci"
)

type TypedImageReference struct {
        Type       imagesource.DestinationType   // the destination type for this image
        Ref        libgoref.DockerImageReference // docker image reference (NOTE: if OCIFBCPath is not empty, this is just an approximation of a docker reference)
        OCIFBCPath string                        // the path to the OCI layout on the file system. Will be empty string if reference is not OCI.
}

func (t TypedImageReference) String() string <span class="cov8" title="1">{
        switch t.Type </span>{
        case imagesource.DestinationFile:<span class="cov8" title="1">
                return fmt.Sprintf("file://%s", t.Ref.Exact())</span>
        case imagesource.DestinationS3:<span class="cov8" title="1">
                return fmt.Sprintf("s3://%s", t.Ref.Exact())</span>
        case DestinationOCI:<span class="cov8" title="1">
                return fmt.Sprintf("oci://%s", t.Ref.Exact())</span>
        default:<span class="cov8" title="1">
                if len(t.Ref.Namespace) == 0 &amp;&amp; libgoref.IsRegistryDockerHub(t.Ref.Registry) </span><span class="cov8" title="1">{
                        t.Ref.Namespace = "library"
                }</span>
                <span class="cov8" title="1">return t.Ref.Exact()</span>
        }
}

// GetVersionsFromImage gets the set of versions after stripping a dash-suffix,
// effectively stripping out timestamps. Example: tag "v4.11-1648566121" becomes version "v4.11"
func GetVersionsFromImage(catalog string) (map[string]int, error) <span class="cov0" title="0">{
        versionTags, err := GetTagsFromImage(catalog)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">versions := make(map[string]int)
        for _, vt := range versionTags </span><span class="cov0" title="0">{
                v := strings.Split(vt, "-")
                versions[v[0]] += 1
        }</span>
        <span class="cov0" title="0">return versions, nil</span>
}

// GetTagsFromImage gets the tags for an image
func GetTagsFromImage(image string) ([]string, error) <span class="cov0" title="0">{
        repo, err := name.NewRepository(image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tags, err := remote.List(repo, remote.WithAuthFromKeychain(authn.DefaultKeychain))
        return tags, err</span>
}

/*
ParseReference is a wrapper function of imagesource.ParseReference

        It provides support for oci: prefixes
*/
func ParseReference(ref string) (TypedImageReference, error) <span class="cov8" title="1">{
        if !strings.HasPrefix(ref, v1alpha2.OCITransportPrefix) </span><span class="cov8" title="1">{
                orig, err := imagesource.ParseReference(ref)
                if err != nil </span><span class="cov0" title="0">{
                        return TypedImageReference{}, err
                }</span>
                <span class="cov8" title="1">return TypedImageReference{
                        Ref:  orig.Ref,
                        Type: orig.Type,
                }, nil</span>
        }

        <span class="cov8" title="1">dstType := DestinationOCI

        // Take the reference and convert it into a docker image reference.
        reg, ns, name, tag, id := v1alpha2.ParseImageReference(ref)
        dst := libgoref.DockerImageReference{
                Registry:  reg,
                Namespace: ns,
                Name:      name,
                Tag:       tag,
                ID:        id,
        }

        // Because this docker reference is based on a path to the OCI layout
        // we need to convert the name and namespace to lower case to comply with the
        // docker reference spec (see https://github.com/distribution/distribution/blob/main/reference/reference.go).
        // Failure to do this will result in parsing errors for some docker reference parsers that
        // perform strict validation.
        // Example: when "ref" is oci:///Users/bob/temp/ocmirror the uppercase U will cause parsing errors.
        dst.Name = strings.ToLower(dst.Name)
        dst.Namespace = strings.ToLower(dst.Namespace)

        // if manifest does not exist (in case of TargetName and TargetTag replacing the original name,
        // the returned path will not exist on disk), invalidate the ID since parsing the path
        // to the OCI layout won't mean anything, and you'll likely get bogus
        // information for the ID
        digest, err := getFirstDigestFromPath(ref)
        if err != nil </span><span class="cov8" title="1">{
                // invalidate the ID
                dst.ID = ""

                if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                        // we know the error could be due to ref not pointing at a real directory
                        klog.V(1).Infof("path to oci layout does not exist (this is expected): %v", err)
                }</span> else<span class="cov0" title="0"> {
                        // be noisy about this, but don't fail
                        klog.Infof("unexpected error encountered while getting digest from oci layout path: %v", err)
                }</span>

        } else<span class="cov0" title="0"> {
                dst.ID = digest.String()
        }</span>
        <span class="cov8" title="1">return TypedImageReference{Ref: dst, Type: dstType, OCIFBCPath: ref}, nil</span>
}

/*
getFirstDigestFromPath will inspect a OCI layout path provided by
the ref argument and return the **first available digest** within the layout.

- If this layout stores a multi arch image, it returns the SHA of the manifest list itself.
This handles the case where index.json directly references a multi arch image
as well when a manifest list is indirectly referenced in the blobs directory.

- If this layout stores a single arch image, it returns the SHA of the image manifest.

This function will error when:

- the index.json has no manifests

- the index.json has more than one manifest (assuming that the index is not directly
referencing a multi arch image as described above)

- other unexpected errors encountered during processing
*/
func getFirstDigestFromPath(ref string) (*v1.Hash, error) <span class="cov8" title="1">{
        filepath := v1alpha2.TrimProtocol(ref)
        layoutPath, err := gcr.FromPath(filepath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ii, err := layoutPath.ImageIndex()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">idxManifest, err := ii.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle use case where the index.json does not use
        // indirection to point at a manifest list in the blobs directory.
        // Do this by looking at the media type... its normally not present
        // but when it is, this is a direct reference to the manifest list.
        <span class="cov8" title="1">if idxManifest.MediaType.IsIndex() </span><span class="cov8" title="1">{
                hash, err := ii.Digest()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;hash, nil</span>
        }

        // if manifest has more than one entry, throw error
        <span class="cov8" title="1">if len(idxManifest.Manifests) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("more than one image reference found in OCI layout %s, which usually indicates multiple images are being stored in the layout", ref)
        }</span>

        // grab the first manifest and return its digest
        // using range here despite the prior length check for safety
        // because we could have zero or one entries
        <span class="cov8" title="1">for _, descriptor := range idxManifest.Manifests </span><span class="cov8" title="1">{
                if descriptor.MediaType.IsImage() </span><span class="cov8" title="1">{
                        // if its an image, make sure it can be obtained
                        img, err := ii.Image(descriptor.Digest)
                        if err != nil </span><span class="cov0" title="0">{
                                // this is unlikely to happen but if it does, move on to the next item
                                continue</span>
                        }
                        <span class="cov8" title="1">_, err = img.ConfigFile()
                        if err != nil </span><span class="cov8" title="1">{
                                // this is unlikely to happen but if it does, move on to the next item
                                continue</span>
                        }
                        <span class="cov8" title="1">return &amp;descriptor.Digest, nil</span>
                } else<span class="cov8" title="1"> if descriptor.MediaType.IsIndex() </span><span class="cov8" title="1">{
                        // if its an image index, make sure it can be obtained
                        _, err := ii.ImageIndex(descriptor.Digest)
                        if err != nil </span><span class="cov0" title="0">{
                                // this is unlikely to happen but if it does, move on to the next item
                                continue</span>
                        }
                        // return the digest for the manifest list
                        <span class="cov8" title="1">return &amp;descriptor.Digest, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("OCI layout %s did not contain any usable manifest entries", ref)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package image

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"
        "strings"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
        "k8s.io/klog/v2"
)

// Format refers to the container image format.
// It defines the structure of the image, and can be
// * [Docker Image Manifest V2, Schema 1](https://docs.docker.com/registry/spec/manifest-v2-1/)
// * [Docker Image Manifest V2, Schema 2](https://docs.docker.com/registry/spec/manifest-v2-2/)
// * [OCI](https://github.com/opencontainers/image-spec)
type Format int64

const (
        // OtherFormat is used when no analysis into the image is done to determine its format

        OtherFormat Format = iota
        DockerV2Format
        OCIFormat
)

// TypedImage defines an a image with the destination and content type
type TypedImage struct {
        TypedImageReference
        ImageFormat Format
        // Category adds image category type to TypedImageReference
        Category v1alpha2.ImageType
}

// ParseTypedImage will create a TypedImage from a string and type
func ParseTypedImage(image string, typ v1alpha2.ImageType) (TypedImage, error) <span class="cov8" title="1">{
        ref, err := ParseReference(image)
        if err != nil </span><span class="cov0" title="0">{
                return TypedImage{}, err
        }</span>
        <span class="cov8" title="1">t := TypedImage{
                TypedImageReference: ref,
                Category:            typ,
        }
        return t.SetDefaults(), nil</span>
}

// SetDefaults sets the default values for TypedImage fields
func (t TypedImage) SetDefaults() TypedImage <span class="cov8" title="1">{
        if len(t.Ref.Tag) == 0 </span><span class="cov8" title="1">{
                partial, err := getPartialDigest(t.Ref.ID)
                // If unable to get a partial digest
                // Set the tag to latest
                if err != nil </span><span class="cov8" title="1">{
                        t.Ref.Tag = "latest"
                }</span> else<span class="cov8" title="1"> {
                        t.Ref.Tag = partial
                }</span>
        }
        <span class="cov8" title="1">return t</span>
}

// TypedImageMapping is a mapping that contains a key,value pairs of
// image sources and destinations.
type TypedImageMapping map[TypedImage]TypedImage

// ToRegistry will convert all mapping values to a registry destination
func (m TypedImageMapping) ToRegistry(registry, namespace string) <span class="cov8" title="1">{
        for src, dest := range m </span><span class="cov8" title="1">{
                dest.Type = imagesource.DestinationRegistry
                dest.Ref.Registry = registry
                dest.Ref.Namespace = path.Join(namespace, dest.Ref.Namespace)
                dest.Ref.ID = src.Ref.ID
                dest = dest.SetDefaults()
                m[src] = dest
        }</span>
}

// Merge will add new image maps to current map
func (m TypedImageMapping) Merge(in TypedImageMapping) <span class="cov0" title="0">{
        for k, v := range in </span><span class="cov0" title="0">{
                _, found := m[k]
                if found </span><span class="cov0" title="0">{
                        klog.V(1).Infof("source image %s already exists in mapping", k.String())
                        continue</span>
                }
                <span class="cov0" title="0">m[k] = v</span>
        }
}

// Add stores a key-value pair into image map
func (m TypedImageMapping) Add(srcRef, dstRef TypedImageReference, typ v1alpha2.ImageType) <span class="cov8" title="1">{
        srcTypedRef := TypedImage{
                TypedImageReference: srcRef,
                Category:            typ,
        }
        dstTypedRef := TypedImage{
                TypedImageReference: dstRef,
                Category:            typ,
        }
        m[srcTypedRef] = dstTypedRef
}</span>

// Remove will remove a TypedImage from the mapping
func (m TypedImageMapping) Remove(images ...TypedImage) <span class="cov0" title="0">{
        for _, img := range images </span><span class="cov0" title="0">{
                delete(m, img)
        }</span>
}

// ByCategory will return a pruned mapping containing provided types
func ByCategory(m TypedImageMapping, types ...v1alpha2.ImageType) TypedImageMapping <span class="cov8" title="1">{
        foundTypes := map[v1alpha2.ImageType]struct{}{}
        for _, typ := range types </span><span class="cov8" title="1">{
                foundTypes[typ] = struct{}{}
        }</span>
        // return a new map with the pruned mapping
        <span class="cov8" title="1">prunedMap := TypedImageMapping{}
        for key, val := range m </span><span class="cov8" title="1">{
                _, ok := foundTypes[key.Category]
                if ok </span><span class="cov8" title="1">{
                        prunedMap[key] = val
                }</span>
        }
        <span class="cov8" title="1">return prunedMap</span>
}

// ReadImageMapping reads a mapping.txt file and parses each line into a map k/v.
func ReadImageMapping(mappingsPath, separator string, typ v1alpha2.ImageType) (TypedImageMapping, error) <span class="cov8" title="1">{
        f, err := os.Open(filepath.Clean(mappingsPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        mappings := TypedImageMapping{}
        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov8" title="1">{
                text := scanner.Text()
                split := strings.Split(text, separator)
                if len(split) != 2 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("mapping %q expected to have exactly one \"%s\"", separator, text)
                }</span>
                <span class="cov8" title="1">srcTypedRef, err := ParseTypedImage(strings.TrimSpace(split[0]), typ)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">dstTypedRef, err := ParseTypedImage(strings.TrimSpace(split[1]), typ)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">mappings[srcTypedRef] = dstTypedRef</span>
        }

        <span class="cov8" title="1">return mappings, scanner.Err()</span>
}

// WriteImageMapping writes key map k/v to an io.Writer.
func WriteImageMapping(nestedPaths int, m TypedImageMapping, output io.Writer) error <span class="cov8" title="1">{
        var strFrom, strTo string
        for fromImage, toImage := range m </span><span class="cov8" title="1">{
                // Prefer tag over id for mapping file for
                // compatability with `oc image mirror`.
                if toImage.Ref.Tag != "" </span><span class="cov8" title="1">{
                        toImage.Ref.ID = ""
                }</span>

                <span class="cov8" title="1">strFrom = fromImage.String()
                strTo = toImage.String()

                _, err := output.Write([]byte(fmt.Sprintf("%s=%s\n", strFrom, strTo)))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (f Format) String() string <span class="cov0" title="0">{
        switch f </span>{
        case OtherFormat:<span class="cov0" title="0">
                return "OtherFormat"</span>
        case DockerV2Format:<span class="cov0" title="0">
                return "DockerV2Format"</span>
        case OCIFormat:<span class="cov0" title="0">
                return "OCIFormat"</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package image

import (
        "context"
        "strings"

        "github.com/containerd/containerd/remotes"
        imgreference "github.com/openshift/library-go/pkg/image/reference"
)

// ResolveToPin returns unresolvedImage's digest-pinned string representation.
func ResolveToPin(ctx context.Context, resolver remotes.Resolver, unresolvedImage string) (string, error) <span class="cov8" title="1">{

        // Add the digest to the Reference to use it's Stringer implementation
        // to get the full image pin.
        ref, err := imgreference.Parse(unresolvedImage)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ref = ref.DockerClientDefaults()

        // Get the image's registry-specific digest.
        _, desc, err := resolver.Resolve(ctx, ref.String())
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">ref.ID = desc.Digest.String()

        return ref.String(), nil</span>
}

// IsImagePinned returns true if img looks canonical.
func IsImagePinned(img string) bool <span class="cov0" title="0">{
        return strings.Contains(img, "@")
}</span>

// IsImageTagged returns true if img has a tag.
func IsImageTagged(img string) bool <span class="cov0" title="0">{
        return strings.Contains(img, ":")
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/spf13/afero"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
)

var _ Backend = &amp;localDirBackend{}

type localDirBackend struct {
        fs  afero.Fs
        dir string
}

func NewLocalBackend(dir string) (Backend, error) <span class="cov8" title="1">{

        // Get absolute path for provided dir
        absDir, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b := localDirBackend{
                dir: absDir,
        }
        return &amp;b, b.init()</span>
}

func (b *localDirBackend) init() error <span class="cov8" title="1">{
        if b.fs == nil </span><span class="cov8" title="1">{
                b.fs = afero.NewOsFs()
        }</span>

        <span class="cov8" title="1">if err := b.fs.MkdirAll(b.dir, 0750); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use a basepath FS to obviate joining paths later.
        // Do this after creating the dir using the underlying fs
        // so b.dir is not created under the base (itself).
        <span class="cov8" title="1">b.fs = afero.NewBasePathFs(b.fs, b.dir)

        return nil</span>
}

// ReadMetadata reads the provided metadata from disk.
func (b *localDirBackend) ReadMetadata(_ context.Context, meta *v1alpha2.Metadata, path string) error <span class="cov8" title="1">{

        klog.V(2).Infof("looking for metadata file at %q", path)

        data, err := afero.ReadFile(b.fs, path)
        if err != nil </span><span class="cov8" title="1">{
                // Non-existent metadata is allowed.
                if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                        return ErrMetadataNotExist
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">typeMeta, err := getTypeMeta(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch typeMeta.GroupVersionKind() </span>{
        case v1alpha2.GroupVersion.WithKind(v1alpha2.MetadataKind):<span class="cov8" title="1">
                *meta, err = config.LoadMetadata(data)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("config GVK not recognized: %s", typeMeta.GroupVersionKind())</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteMetadata writes the provided metadata to disk.
func (b *localDirBackend) WriteMetadata(ctx context.Context, meta *v1alpha2.Metadata, path string) error <span class="cov8" title="1">{
        return b.WriteObject(ctx, path, meta)
}</span>

// ReadObject reads the provided object from disk.
// In this implementation, key is a file path.
func (b *localDirBackend) ReadObject(_ context.Context, fpath string, obj interface{}) error <span class="cov8" title="1">{

        data, err := afero.ReadFile(b.fs, fpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch v := obj.(type) </span>{
        case []byte:<span class="cov0" title="0">
                if len(v) &lt; len(data) </span><span class="cov0" title="0">{
                        return io.ErrShortBuffer
                }</span>
                <span class="cov0" title="0">copy(v, data)</span>
        case io.Writer:<span class="cov0" title="0">
                _, err = v.Write(data)</span>
        default:<span class="cov8" title="1">
                err = json.Unmarshal(data, obj)</span>
        }
        <span class="cov8" title="1">return err</span>
}

// WriteObject writes the provided object to disk.
// In this implementation, key is a file path.
func (b *localDirBackend) WriteObject(ctx context.Context, fpath string, obj interface{}) error <span class="cov8" title="1">{

        w, err := b.GetWriter(ctx, fpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer w.(io.WriteCloser).Close()

        var data []byte
        switch v := obj.(type) </span>{
        case []byte:<span class="cov0" title="0">
                data = v</span>
        case string:<span class="cov0" title="0">
                data = []byte(v)</span>
        case io.Reader:<span class="cov0" title="0">
                data, err = io.ReadAll(v)</span>
        default:<span class="cov8" title="1">
                data, err = json.Marshal(obj)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = w.Write(data)
        return err</span>
}

// GetWriter returns an os.File as a writer.
// In this implementation, key is a file path.
func (b *localDirBackend) GetWriter(_ context.Context, fpath string) (io.Writer, error) <span class="cov8" title="1">{

        // Create a child dirs necessary.
        if err := b.fs.MkdirAll(filepath.Dir(fpath), 0750); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating object child path: %v", err)
        }</span>

        <span class="cov8" title="1">w, err := b.fs.OpenFile(fpath, os.O_WRONLY|os.O_CREATE, 0640)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening object file: %v", err)
        }</span>

        <span class="cov8" title="1">return w, nil</span>
}

// Open reads the provided object from a local source and provides an io.ReadCloser
func (b *localDirBackend) Open(_ context.Context, fpath string) (io.ReadCloser, error) <span class="cov8" title="1">{
        return b.fs.Open(fpath)
}</span>

// Stat checks the existence of the metadata from a local source
func (b *localDirBackend) Stat(_ context.Context, fpath string) (os.FileInfo, error) <span class="cov8" title="1">{
        info, err := b.fs.Stat(fpath)
        switch </span>{
        case err != nil &amp;&amp; errors.Is(err, os.ErrNotExist):<span class="cov0" title="0">
                return nil, ErrMetadataNotExist</span>
        case err != nil:<span class="cov0" title="0">
                return nil, err</span>
        default:<span class="cov8" title="1">
                return info, nil</span>
        }
}

// Cleanup removes remove metadata from existing metadata from backend location
func (b *localDirBackend) Cleanup(_ context.Context, fpath string) error <span class="cov8" title="1">{
        return b.fs.RemoveAll(fpath)
}</span>

func (b *localDirBackend) CheckConfig(storage v1alpha2.StorageConfig) error <span class="cov8" title="1">{
        if storage.Local == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("not local backend")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package storage

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "time"

        "github.com/docker/distribution/registry/client/auth"
        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/crane"
        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/google/go-containerregistry/pkg/v1/remote/transport"
        "github.com/mholt/archiver/v3"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc/pkg/cli/image/imagesource"
)

var _ Backend = &amp;registryBackend{}

type registryBackend struct {
        // Since image contents are represented locally as directories,
        // use the local dir backend as the underlying Backend.
        *localDirBackend
        // Image to use when pushing and pulling
        src imagesource.TypedImageReference
        // Registry client options
        insecure bool
}

func NewRegistryBackend(cfg *v1alpha2.RegistryConfig, dir string) (Backend, error) <span class="cov8" title="1">{
        b := registryBackend{}
        b.insecure = cfg.SkipTLS

        ref, err := imagesource.ParseReference(cfg.ImageURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(ref.Ref.Tag) == 0 </span><span class="cov8" title="1">{
                ref.Ref.Tag = "latest"
        }</span>
        <span class="cov8" title="1">b.src = ref

        if b.localDirBackend == nil </span><span class="cov8" title="1">{
                // Create the local dir backend for local r/w.
                lb, err := NewLocalBackend(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating local backend for registry: %w", err)
                }</span>
                <span class="cov8" title="1">b.localDirBackend = lb.(*localDirBackend)</span>
        }

        <span class="cov8" title="1">return &amp;b, nil</span>
}

// ReadMetadata unpacks the metadata image and read it from disk
func (b *registryBackend) ReadMetadata(ctx context.Context, meta *v1alpha2.Metadata, path string) error <span class="cov8" title="1">{
        klog.V(1).Infof("Checking for existing metadata image at %s", b.src)
        if err := b.exists(ctx); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := b.unpack(ctx, path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return b.localDirBackend.ReadMetadata(ctx, meta, path)</span>
}

// WriteMetadata writes the provided metadata to disk anf registry.
func (b *registryBackend) WriteMetadata(ctx context.Context, meta *v1alpha2.Metadata, path string) error <span class="cov8" title="1">{
        return b.WriteObject(ctx, path, meta)
}</span>

// ReadObject reads the provided object from disk.
// In this implementation, key is a file path.
func (b *registryBackend) ReadObject(ctx context.Context, fpath string, obj interface{}) error <span class="cov0" title="0">{
        return b.localDirBackend.ReadObject(ctx, fpath, obj)
}</span>

// WriteObject writes the provided object to disk and registry.
// In this implementation, key is a file path.
func (b *registryBackend) WriteObject(ctx context.Context, fpath string, obj interface{}) (err error) <span class="cov8" title="1">{
        var data []byte
        switch v := obj.(type) </span>{
        case []byte:<span class="cov0" title="0">
                data = v</span>
        case string:<span class="cov0" title="0">
                data = []byte(v)</span>
        case io.Reader:<span class="cov0" title="0">
                data, err = io.ReadAll(v)</span>
        default:<span class="cov8" title="1">
                data, err = json.Marshal(obj)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write metadata to disk for packing into archive
        <span class="cov8" title="1">if err := b.localDirBackend.WriteObject(ctx, fpath, obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">klog.V(1).Infof("Pushing metadata to registry at %s", b.src)
        return b.pushImage(ctx, data, fpath)</span>
}

// GetWriter returns an os.File as a writer.
// In this implementation, key is a file path.
func (b *registryBackend) GetWriter(ctx context.Context, fpath string) (io.Writer, error) <span class="cov8" title="1">{
        return b.localDirBackend.GetWriter(ctx, fpath)
}</span>

// Open reads the provided object from a registry source and provides an io.ReadCloser
func (b *registryBackend) Open(ctx context.Context, fpath string) (io.ReadCloser, error) <span class="cov8" title="1">{
        if _, err := b.Stat(ctx, fpath); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := b.unpack(ctx, fpath); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return b.localDirBackend.Open(ctx, fpath)</span>
}

func (b *registryBackend) unpack(ctx context.Context, fpath string) error <span class="cov8" title="1">{
        tempTar := fmt.Sprintf("%s.tar", b.src.Ref.Name)
        opts := b.getOpts(ctx)
        img, err := crane.Pull(b.src.Ref.Exact(), opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">w, err := b.GetWriter(ctx, tempTar)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer b.localDirBackend.fs.Remove(tempTar)

        if err := crane.Export(img, w); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">arc := archiver.Tar{
                OverwriteExisting:      true,
                MkdirAll:               true,
                ImplicitTopLevelFolder: false,
                StripComponents:        0,
                ContinueOnError:        false,
        }
        tempTar = filepath.Join(b.localDirBackend.dir, tempTar)
        if err := arc.Unarchive(tempTar, b.localDirBackend.dir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // adjust perms, unpack leaves the file user-writable only
        <span class="cov8" title="1">if err := b.localDirBackend.fs.Chmod(fpath, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("metadata %q does not contain required content: %v", b.src.Ref.Exact(), err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Stat checks the existence of the metadata from a registry source
func (b *registryBackend) Stat(ctx context.Context, fpath string) (os.FileInfo, error) <span class="cov8" title="1">{
        klog.V(1).Infof("Checking for existing metadata image at %s", b.src.String())
        // Check if image exists
        if err := b.exists(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return b.localDirBackend.Stat(ctx, fpath)</span>
}

// Cleanup removes metadata from existing metadata from backend location
func (b *registryBackend) Cleanup(ctx context.Context, fpath string) error <span class="cov8" title="1">{
        opts := b.getOpts(ctx)
        if err := crane.Delete(b.src.Ref.Exact(), opts...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return b.localDirBackend.Cleanup(ctx, fpath)</span>
}

// CheckConfig will return an error if the StorageConfig
// is not a registry
func (b *registryBackend) CheckConfig(storage v1alpha2.StorageConfig) error <span class="cov8" title="1">{
        if storage.Registry == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not registry backend")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// pushImage will push a v1.Image with provided contents
func (b *registryBackend) pushImage(ctx context.Context, data []byte, fpath string) error <span class="cov8" title="1">{
        opts := b.getOpts(ctx)
        contents := map[string][]byte{
                fpath: data,
        }
        i, _ := crane.Image(contents)
        return crane.Push(i, b.src.Ref.Exact(), opts...)
}</span>

// exists checks if the image exists
func (b *registryBackend) exists(ctx context.Context) error <span class="cov8" title="1">{

        var defaultScheme = "https://"
        var terr *transport.Error
        opts := b.getOpts(ctx)
        _, err := crane.Manifest(b.src.Ref.Exact(), opts...)
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                // fail fast
                return nil</span>
        case errors.As(err, &amp;terr) &amp;&amp; terr.StatusCode == 404:<span class="cov8" title="1">
                regLoc := defaultScheme + b.src.Ref.Registry
                reg, err := url.Parse(regLoc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := b.ping(ctx, *reg); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return ErrMetadataNotExist</span>
        case errors.As(err, &amp;terr) &amp;&amp; terr.StatusCode == 401:<span class="cov8" title="1">
                var nameOpts []name.Option
                if b.insecure </span><span class="cov8" title="1">{
                        nameOpts = append(nameOpts, name.Insecure)
                }</span>
                <span class="cov8" title="1">ref, err := name.ParseReference(b.src.Ref.Exact(), nameOpts...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = remote.CheckPushPermission(ref, authn.DefaultKeychain, b.createRT())
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // return metadata does not exist
                // if push permission does not throw an error
                <span class="cov0" title="0">return ErrMetadataNotExist</span>
        default:<span class="cov8" title="1">
                return err</span>
        }
}

func (b *registryBackend) createRT() http.RoundTripper <span class="cov8" title="1">{
        return &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        // By default we wrap the transport in retries, so reduce the
                        // default dial timeout to 5s to avoid 5x 30s of connection
                        // timeouts when doing the "ping" on certain http registries.
                        Timeout:   5 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: b.insecure,
                },
        }
}</span>

// TODO: Get default auth will need to update if user
// can specify custom locations
func (b *registryBackend) getOpts(ctx context.Context) []crane.Option <span class="cov8" title="1">{
        options := []crane.Option{
                crane.WithAuthFromKeychain(authn.DefaultKeychain),
                crane.WithContext(ctx),
                crane.WithTransport(b.createRT()),
        }
        if b.insecure </span><span class="cov8" title="1">{
                options = append(options, crane.Insecure)
        }</span>
        <span class="cov8" title="1">return options</span>
}

// ping checks the registry and ensures it responds to a v2 endpoint.
func (b *registryBackend) ping(ctx context.Context, registry url.URL) error <span class="cov8" title="1">{
        pingClient := &amp;http.Client{
                Transport: b.createRT(),
        }

        target := registry
        target.Path = path.Join(target.Path, "v2") + "/"

        req, err := http.NewRequest(http.MethodGet, target.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resp, err := pingClient.Do(req.WithContext(ctx))
        if err != nil </span><span class="cov8" title="1">{
                if b.insecure &amp;&amp; registry.Scheme == "https" </span><span class="cov8" title="1">{
                        klog.V(5).Infof("Falling back to an HTTP check for an insecure registry %s: %v", registry.String(), err)
                        registry.Scheme = "http"
                        if iErr := b.ping(ctx, registry); err != nil </span><span class="cov8" title="1">{
                                return iErr
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer resp.Body.Close()

        versions := auth.APIVersions(resp, "Docker-Distribution-API-Version")
        if len(versions) == 0 </span><span class="cov0" title="0">{
                klog.V(5).Infof("Registry responded to v2 Docker endpoint, but has no header for Docker Distribution %s: %d, %#v", req.URL, resp.StatusCode, resp.Header)
                switch </span>{
                case resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300:<span class="cov0" title="0"></span>
                        // valid v2
                case resp.StatusCode == http.StatusUnauthorized:<span class="cov0" title="0"></span>
                        // valid v2
                case resp.StatusCode == http.StatusForbidden:<span class="cov0" title="0"></span>
                        // valid v2
                default:<span class="cov0" title="0">
                        return fmt.Errorf("registry %q is not an accessible registry with a v2 Docker endpoint", registry.Hostname())</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/klog/v2"
        "sigs.k8s.io/yaml"
)

var (
        // ErrMetadataNotExist should be returned by ReadMetadata() when no metadata is found.
        // Callers should check for this error, since in certain conditions no metadata is desired.
        ErrMetadataNotExist = errors.New("metadata does not exist")
)

// TODO: consider consolidating {Read,Write}Metadata() into the
// generic {Read,Write}Object() methods respectively.

type Backend interface {
        ReadMetadata(context.Context, *v1alpha2.Metadata, string) error
        WriteMetadata(context.Context, *v1alpha2.Metadata, string) error
        ReadObject(context.Context, string, interface{}) error
        WriteObject(context.Context, string, interface{}) error
        GetWriter(context.Context, string) (io.Writer, error)
        CheckConfig(v1alpha2.StorageConfig) error
        Open(context.Context, string) (io.ReadCloser, error)
        Stat(context.Context, string) (os.FileInfo, error)
        Cleanup(context.Context, string) error
}

// Committer is a Backend that collects a set of write operations into a transaction
// then commits them atomically. The technologies underlying these Backends are
// typically transactional by nature (like git); this interface exposes that nature.
type Committer interface {
        // Commit the set of writes to the Backend for persistence.
        // Commit is NOT guaranteed to be threadsafe, see implementer comments for details.
        Commit(context.Context) error
}

var backends = []Backend{
        &amp;localDirBackend{},
        &amp;registryBackend{},
}

// ByConfig returns backend interface based on provided config
func ByConfig(dir string, storage v1alpha2.StorageConfig) (Backend, error) <span class="cov8" title="1">{
        var b interface{}
        for _, bk := range backends </span><span class="cov8" title="1">{
                if err := bk.CheckConfig(storage); err == nil </span><span class="cov8" title="1">{
                        b = bk
                        break</span>
                }
        }
        <span class="cov8" title="1">switch b.(type) </span>{
        case *localDirBackend:<span class="cov8" title="1">
                klog.V(1).Infof("Using local backend at location %s", storage.Local.Path)
                return NewLocalBackend(storage.Local.Path)</span>
        case *registryBackend:<span class="cov8" title="1">
                klog.V(1).Infof("Using registry backend at location %s", storage.Registry.ImageURL)
                return NewRegistryBackend(storage.Registry, dir)</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("unsupported backend configuration")</span>
        }
}

func getTypeMeta(data []byte) (typeMeta metav1.TypeMeta, err error) <span class="cov8" title="1">{
        if err := yaml.Unmarshal(data, &amp;typeMeta); err != nil </span><span class="cov0" title="0">{
                return typeMeta, fmt.Errorf("get type meta: %v", err)
        }</span>
        <span class="cov8" title="1">return typeMeta, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package metadata

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/containerd/containerd/remotes"
        "github.com/operator-framework/operator-registry/pkg/image/containerdregistry"
        "github.com/sirupsen/logrus"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/klog/v2"

        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/openshift/oc-mirror/pkg/config"
        "github.com/openshift/oc-mirror/pkg/image"
        "github.com/openshift/oc-mirror/pkg/metadata/storage"
        "github.com/openshift/oc-mirror/pkg/operator"
)

// SyncMetadata copies Metadata from one Backend to another
func SyncMetadata(ctx context.Context, first storage.Backend, second storage.Backend) error <span class="cov0" title="0">{
        var meta v1alpha2.Metadata
        if err := first.ReadMetadata(ctx, &amp;meta, config.MetadataBasePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading metadata: %v", err)
        }</span>
        // Add mirror as a new PastMirror
        <span class="cov0" title="0">if err := second.WriteMetadata(ctx, &amp;meta, config.MetadataBasePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing metadata: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateMetadata runs some reconciliation functions on Metadata to ensure its state is consistent
// then uses the Backend to update the metadata storage medium.
func UpdateMetadata(ctx context.Context, backend storage.Backend, meta *v1alpha2.Metadata, workspace string, skipTLSVerify, plainHTTP bool) error <span class="cov8" title="1">{
        pastMeta := v1alpha2.NewMetadata()
        pastReleases := map[string]string{}
        merr := backend.ReadMetadata(ctx, &amp;pastMeta, config.MetadataBasePath)
        if merr != nil &amp;&amp; !errors.Is(merr, storage.ErrMetadataNotExist) </span><span class="cov0" title="0">{
                return merr
        }</span> else<span class="cov8" title="1"> if merr == nil </span><span class="cov0" title="0">{
                for _, ch := range pastMeta.PastMirror.Platforms </span><span class="cov0" title="0">{
                        pastReleases[ch.ReleaseChannel] = ch.MinVersion
                }</span>
        }

        <span class="cov8" title="1">mirror := meta.PastMirror
        // Store minimum versions for new catalogs
        klog.V(1).Info("Resolving operator metadata")
        var operatorErrs []error

        resolver, err := containerdregistry.NewResolver("", skipTLSVerify, plainHTTP, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating image resolver: %v", err)
        }</span>
        <span class="cov8" title="1">cacheDir, err := os.MkdirTemp("", "imageset-catalog-registry-")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">logger := logrus.New()
        logger.SetOutput(io.Discard)
        nullLogger := logrus.NewEntry(logger)

        reg, err := containerdregistry.NewRegistry(
                containerdregistry.WithCacheDir(cacheDir),
                containerdregistry.SkipTLSVerify(skipTLSVerify),
                containerdregistry.WithPlainHTTP(plainHTTP),
                // The containerd registry impl is somewhat verbose, even on the happy path,
                // so discard all logger logs. Any important failures will be returned from
                // registry methods and eventually logged as fatal errors.
                containerdregistry.WithLog(nullLogger),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer reg.Destroy()

        for _, operator := range mirror.Mirror.Operators </span><span class="cov8" title="1">{
                operatorMeta, err := resolveOperatorMetadata(ctx, operator, reg, resolver, workspace)
                if err != nil </span><span class="cov0" title="0">{
                        operatorErrs = append(operatorErrs, err)
                        continue</span>
                }

                <span class="cov8" title="1">meta.PastMirror.Operators = append(meta.PastMirror.Operators, operatorMeta)</span>
        }
        <span class="cov8" title="1">if len(operatorErrs) != 0 </span><span class="cov0" title="0">{
                return utilerrors.NewAggregate(operatorErrs)
        }</span>

        // Store minimum versions for new release channels
        <span class="cov8" title="1">klog.V(1).Info("Resolving OCP release metadata")
        for _, channel := range mirror.Mirror.Platform.Channels </span><span class="cov8" title="1">{

                // Only collect the information
                // for heads only work flow for conversions
                // from ranges to heads only.
                if !channel.IsHeadsOnly() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">min, ok := pastReleases[channel.Name]
                if !ok </span><span class="cov8" title="1">{
                        klog.V(2).Infof("channel %q not found, setting new min to %q", channel.Name, channel.MinVersion)
                        min = channel.MinVersion
                }</span>

                <span class="cov8" title="1">releaseMeta := v1alpha2.PlatformMetadata{}
                releaseMeta.ReleaseChannel = channel.Name
                releaseMeta.MinVersion = min
                meta.PastMirror.Platforms = append(meta.PastMirror.Platforms, releaseMeta)</span>
        }

        // Add mirror as a new PastMirror
        <span class="cov8" title="1">if err := backend.WriteMetadata(ctx, meta, config.MetadataBasePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing metadata: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func resolveOperatorMetadata(ctx context.Context, ctlg v1alpha2.Operator, reg *containerdregistry.Registry, resolver remotes.Resolver, workspace string) (operatorMeta v1alpha2.OperatorMetadata, err error) <span class="cov8" title="1">{
        ctlgName, err := ctlg.GetUniqueName()
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha2.OperatorMetadata{}, err
        }</span>
        <span class="cov8" title="1">operatorMeta.Catalog = ctlgName

        // Stick to Catalog here because we
        // are referencing the source
        if !image.IsImagePinned(ctlg.Catalog) </span><span class="cov0" title="0">{
                if ctlg.IsFBCOCI() </span><span class="cov0" title="0">{
                        ref, err := image.ParseReference(ctlg.Catalog)
                        if err != nil </span><span class="cov0" title="0">{
                                return v1alpha2.OperatorMetadata{}, err
                        }</span>
                        <span class="cov0" title="0">operatorMeta.ImagePin = ref.String()</span>
                } else<span class="cov0" title="0"> {
                        ctlgPin := ctlg.Catalog
                        ctlgPin, err := image.ResolveToPin(ctx, resolver, ctlg.Catalog)
                        if err != nil </span><span class="cov0" title="0">{
                                return v1alpha2.OperatorMetadata{}, fmt.Errorf("error resolving catalog image %q: %v", ctlg.Catalog, err)
                        }</span>
                        <span class="cov0" title="0">operatorMeta.ImagePin = ctlgPin</span>
                }

        }

        <span class="cov8" title="1">var ic v1alpha2.IncludeConfig
        // Only collect the information
        // for heads only work flows for conversions from ranges
        // or full catalogs to heads only.
        if ctlg.IsHeadsOnly() </span><span class="cov8" title="1">{

                if ctlg.IsFBCOCI() </span><span class="cov0" title="0">{
                        ctlgName = v1alpha2.OCITransportPrefix + "//" + ctlgName
                }</span>
                // Determine the location of the created FBC
                <span class="cov8" title="1">tir, err := image.ParseReference(ctlgName)
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha2.OperatorMetadata{}, err
                }</span>
                <span class="cov8" title="1">ctlgRef := tir.Ref
                ctlgLoc, err := operator.GenerateCatalogDir(ctlgRef)
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha2.OperatorMetadata{}, err
                }</span>

                <span class="cov8" title="1">icLoc := filepath.Join(workspace, config.CatalogsDir, ctlgLoc, config.IncludeConfigFile)
                includeFile, err := os.Open(icLoc)
                if err != nil </span><span class="cov0" title="0">{
                        return operatorMeta, fmt.Errorf("error opening include config file: %v", err)
                }</span>
                <span class="cov8" title="1">defer includeFile.Close()

                if err := ic.Decode(includeFile); err != nil </span><span class="cov0" title="0">{
                        return operatorMeta, fmt.Errorf("error decoding include config file: %v", err)
                }</span>

        }

        <span class="cov8" title="1">operatorMeta.IncludeConfig = ic

        return operatorMeta, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package operator

import (
        "fmt"
        "path/filepath"

        imgreference "github.com/openshift/library-go/pkg/image/reference"
)

// GenerateCatalogDir will generate a directory location for a catalog from a reference
func GenerateCatalogDir(ctlgRef imgreference.DockerImageReference) (string, error) <span class="cov8" title="1">{
        leafDir := ctlgRef.Tag
        if leafDir == "" </span><span class="cov0" title="0">{
                leafDir = ctlgRef.ID
        }</span>
        <span class="cov8" title="1">if leafDir == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("catalog %q must have either a tag or digest", ctlgRef.Exact())
        }</span>
        <span class="cov8" title="1">return filepath.Join(ctlgRef.Registry, ctlgRef.Namespace, ctlgRef.Name, leafDir), nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package operator

import (
        "sort"

        "github.com/blang/semver/v4"
        "github.com/openshift/oc-mirror/pkg/api/v1alpha2"
        "github.com/operator-framework/operator-registry/alpha/declcfg"
        "github.com/operator-framework/operator-registry/alpha/model"
)

// IncludeConfigManager defines methods for IncludeConfig creation and manipulation.
type IncludeConfigManager interface {
        ConvertDCToIncludeConfig(declcfg.DeclarativeConfig) (v1alpha2.IncludeConfig, error)
        UpdateIncludeConfig(declcfg.DeclarativeConfig, v1alpha2.IncludeConfig) (v1alpha2.IncludeConfig, error)
}

var _ IncludeConfigManager = &amp;catalogStrategy{}

type catalogStrategy struct{}

// NewCatalogStrategy will return the catalog implementation for the IncludeConfigManager.
func NewCatalogStrategy() IncludeConfigManager <span class="cov0" title="0">{
        return &amp;catalogStrategy{}
}</span>

// ConvertDCToIncludeConfig converts a heads-only rendered declarative config to an IncludeConfig
// with all of the package channels with the lowest bundle version.
func (s *catalogStrategy) ConvertDCToIncludeConfig(dc declcfg.DeclarativeConfig) (ic v1alpha2.IncludeConfig, err error) <span class="cov8" title="1">{
        inputModel, err := declcfg.ConvertToModel(dc)
        if err != nil </span><span class="cov0" title="0">{
                return ic, err
        }</span>
        <span class="cov8" title="1">for _, mpkg := range inputModel </span><span class="cov8" title="1">{
                icPkg := v1alpha2.IncludePackage{
                        Name: mpkg.Name,
                }
                // Pass in the empty includePackage here for
                // catalog strategy as there is in incoming
                // include config to process.
                icPkg.Channels = getFirstChannelBundles(*mpkg, icPkg)
                sortChannels(icPkg.Channels)
                ic.Packages = append(ic.Packages, icPkg)
        }</span>
        <span class="cov8" title="1">sortPackages(ic.Packages)
        return ic, nil</span>
}

// UpdateIncludeConfig will process the current IncludeConfig to add any new packages or channels. Starting versions are
// also validated and incremented if the version no longer exists in the catalog.
func (s *catalogStrategy) UpdateIncludeConfig(dc declcfg.DeclarativeConfig, curr v1alpha2.IncludeConfig) (ic v1alpha2.IncludeConfig, err error) <span class="cov8" title="1">{
        inputModel, err := declcfg.ConvertToModel(dc)
        if err != nil </span><span class="cov0" title="0">{
                return ic, err
        }</span>

        <span class="cov8" title="1">currPackages := make(map[string]v1alpha2.IncludePackage, len(curr.Packages))
        for _, pkg := range curr.Packages </span><span class="cov8" title="1">{
                currPackages[pkg.Name] = pkg
        }</span>

        // If there is a new package get the channel head.
        // If existing validate the starting bundle is
        // still in the catalog and iterate, if needed.
        <span class="cov8" title="1">for _, mpkg := range inputModel </span><span class="cov8" title="1">{
                icPkg := v1alpha2.IncludePackage{
                        Name: mpkg.Name,
                }
                currPkg, found := currPackages[mpkg.Name]
                if !found </span><span class="cov8" title="1">{
                        chWithHeads, err := getChannelHeads(*mpkg)
                        icPkg.Channels = chWithHeads
                        if err != nil </span><span class="cov0" title="0">{
                                return ic, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Pass in the empty includePackage here for
                        // catalog strategy as there is in incoming
                        // include config to process.
                        ch, err := getCurrentChannelBundles(*mpkg, currPkg, icPkg)
                        if err != nil </span><span class="cov0" title="0">{
                                return ic, err
                        }</span>
                        <span class="cov8" title="1">icPkg.Channels = ch</span>
                }

                <span class="cov8" title="1">sortChannels(icPkg.Channels)
                ic.Packages = append(ic.Packages, icPkg)</span>
        }
        <span class="cov8" title="1">sortPackages(ic.Packages)
        return ic, nil</span>
}

var _ IncludeConfigManager = &amp;packageStrategy{}

type packageStrategy struct {
        curr v1alpha2.IncludeConfig
}

// NewPackageStrategy will return the package implementation for the IncludeConfigManager.
// The current IncludeConfig specified through user-configuration is used to determine
// what packages should be managed and what packages have configuration information set.
func NewPackageStrategy(curr v1alpha2.IncludeConfig) IncludeConfigManager <span class="cov0" title="0">{
        return &amp;packageStrategy{curr}
}</span>

// ConvertDCToIncludeConfig converts a heads-only rendered declarative config to an IncludeConfig
// with all of the package channels with the lowest bundle version.
func (s *packageStrategy) ConvertDCToIncludeConfig(dc declcfg.DeclarativeConfig) (ic v1alpha2.IncludeConfig, err error) <span class="cov8" title="1">{
        inputModel, err := declcfg.ConvertToModel(dc)
        if err != nil </span><span class="cov0" title="0">{
                return ic, err
        }</span>

        <span class="cov8" title="1">currPackages := make(map[string]v1alpha2.IncludePackage, len(s.curr.Packages))
        for _, pkg := range s.curr.Packages </span><span class="cov8" title="1">{
                currPackages[pkg.Name] = pkg
        }</span>

        // Check if the package is new or has
        // version configuration set at the package level
        // if not process at the channel level.
        <span class="cov8" title="1">for _, mpkg := range inputModel </span><span class="cov8" title="1">{
                icPkg, found := currPackages[mpkg.Name]
                if !found || !includePackageVersionsSet(icPkg) </span><span class="cov8" title="1">{
                        icPkg = v1alpha2.IncludePackage{
                                Name:     mpkg.Name,
                                Channels: getFirstChannelBundles(*mpkg, icPkg),
                        }
                        sortChannels(icPkg.Channels)
                }</span>
                <span class="cov8" title="1">ic.Packages = append(ic.Packages, icPkg)</span>
        }
        <span class="cov8" title="1">sortPackages(ic.Packages)
        return ic, nil</span>
}

// UpdateIncludeConfig will process the currently managed IncludeConfig to add any new packages or channels. Starting versions are
// also validated and incremented if the version no longer exists in the catalog.
func (s *packageStrategy) UpdateIncludeConfig(dc declcfg.DeclarativeConfig, prev v1alpha2.IncludeConfig) (ic v1alpha2.IncludeConfig, err error) <span class="cov8" title="1">{
        inputModel, err := declcfg.ConvertToModel(dc)
        if err != nil </span><span class="cov0" title="0">{
                return ic, err
        }</span>

        // currPackages are the package from the user-defined IncludeConfig
        <span class="cov8" title="1">currPackages := make(map[string]v1alpha2.IncludePackage, len(s.curr.Packages))
        for _, pkg := range s.curr.Packages </span><span class="cov8" title="1">{
                currPackages[pkg.Name] = pkg
        }</span>

        // prevPackages is the most recent version of managed IncludeConfig values
        <span class="cov8" title="1">prevPackages := make(map[string]v1alpha2.IncludePackage, len(prev.Packages))
        for _, pkg := range prev.Packages </span><span class="cov8" title="1">{
                prevPackages[pkg.Name] = pkg
        }</span>

        // If there is a new package get the channel head.
        // If existing validate the starting bundle is
        // still in the catalog and iterate, if needed.
        <span class="cov8" title="1">for _, mpkg := range inputModel </span><span class="cov8" title="1">{
                // Check if the package is new or has
                // version configuration set at the package level
                // if not process at the channel level.
                icPkg, found := currPackages[mpkg.Name]
                if !found || !includePackageVersionsSet(icPkg) </span><span class="cov8" title="1">{
                        prevPkg, found := prevPackages[mpkg.Name]
                        if !found </span><span class="cov8" title="1">{
                                chWithHeads, err := getChannelHeads(*mpkg)
                                if err != nil </span><span class="cov0" title="0">{
                                        return ic, err
                                }</span>
                                <span class="cov8" title="1">icPkg = v1alpha2.IncludePackage{
                                        Name:     mpkg.Name,
                                        Channels: chWithHeads,
                                }</span>
                        } else<span class="cov8" title="1"> {
                                chs, err := getCurrentChannelBundles(*mpkg, prevPkg, icPkg)
                                if err != nil </span><span class="cov0" title="0">{
                                        return ic, err
                                }</span>
                                <span class="cov8" title="1">icPkg = v1alpha2.IncludePackage{
                                        Name:     mpkg.Name,
                                        Channels: chs,
                                }</span>
                        }
                        <span class="cov8" title="1">sortChannels(icPkg.Channels)</span>
                }
                <span class="cov8" title="1">ic.Packages = append(ic.Packages, icPkg)</span>
        }
        <span class="cov8" title="1">sortPackages(ic.Packages)
        return ic, nil</span>
}

// getFirstBundleByChannel will get the first bundle available in the channel in semver order
// for the model package for any channels that are not configured for the current
// include config package.
func getFirstChannelBundles(mpkg model.Package, icPkg v1alpha2.IncludePackage) []v1alpha2.IncludeChannel <span class="cov8" title="1">{
        currIncludeChannels := make(map[string]v1alpha2.IncludeChannel, len(icPkg.Channels))
        for _, ch := range icPkg.Channels </span><span class="cov8" title="1">{
                currIncludeChannels[ch.Name] = ch
        }</span>

        <span class="cov8" title="1">channels := []v1alpha2.IncludeChannel{}
        for _, ch := range mpkg.Channels </span><span class="cov8" title="1">{
                newCh, found := currIncludeChannels[ch.Name]
                if !found || !includeChannelVersionsSet(newCh) </span><span class="cov8" title="1">{
                        newCh = v1alpha2.IncludeChannel{
                                Name: ch.Name,
                        }

                        keys := make([]string, 0, len(ch.Bundles))
                        for k := range ch.Bundles </span><span class="cov8" title="1">{
                                keys = append(keys, k)
                        }</span>
                        <span class="cov8" title="1">sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                                return ch.Bundles[keys[i]].Version.GT(ch.Bundles[keys[j]].Version)
                        }</span>)

                        <span class="cov8" title="1">firstBundle := ch.Bundles[keys[len(keys)-1]].Version
                        b := v1alpha2.IncludeBundle{
                                MinVersion: firstBundle.String(),
                        }
                        newCh.IncludeBundle = b</span>

                }
                <span class="cov8" title="1">channels = append(channels, newCh)</span>
        }

        <span class="cov8" title="1">return channels</span>
}

// getCurrBundles will get the current bundle available in the channel in semver order
// for the model package.
// The channel heads are added for new channels
// Configuration channels from the current are added as is
// Channel bundles from the previously managed package are checked
// against the bundles in the model package.
func getCurrentChannelBundles(mpkg model.Package, prevPkg, currPkg v1alpha2.IncludePackage) ([]v1alpha2.IncludeChannel, error) <span class="cov8" title="1">{

        // Add every bundle with a specified bundle name or
        // directly satisfying a bundle version to bundles.
        prevBundleByChannel := make(map[string]v1alpha2.IncludeBundle, len(prevPkg.Channels))
        for _, ch := range prevPkg.Channels </span><span class="cov8" title="1">{
                prevBundleByChannel[ch.Name] = ch.IncludeBundle
        }</span>

        <span class="cov8" title="1">currIncludeChannels := make(map[string]v1alpha2.IncludeChannel, len(currPkg.Channels))
        for _, ch := range currPkg.Channels </span><span class="cov8" title="1">{
                currIncludeChannels[ch.Name] = ch
        }</span>

        <span class="cov8" title="1">channels := []v1alpha2.IncludeChannel{}

        for _, ch := range mpkg.Channels </span><span class="cov8" title="1">{

                newCh, found := currIncludeChannels[ch.Name]
                if !found || !includeChannelVersionsSet(newCh) </span><span class="cov8" title="1">{
                        newCh = v1alpha2.IncludeChannel{
                                Name: ch.Name,
                        }

                        // Gather bundle information from
                        // channel in declarative config to verify
                        // currently available bundles.
                        bundleSet := make(map[string]struct{}, len(ch.Bundles))
                        versionsToInclude := []semver.Version{}
                        for _, b := range ch.Bundles </span><span class="cov8" title="1">{
                                bundleSet[b.Version.String()] = struct{}{}
                                versionsToInclude = append(versionsToInclude, b.Version)
                        }</span>

                        // If the channel is new, return the channel head.
                        // If the channel is found and the bundle is found,
                        // keep the current include bundle. If the target version
                        // does not exist in the bundle set, sort by version and
                        // find the next version using binary search.
                        <span class="cov8" title="1">existsInBundleSet := func(v string) bool </span><span class="cov8" title="1">{
                                _, found := bundleSet[v]
                                return found
                        }</span>

                        <span class="cov8" title="1">var startingBundle v1alpha2.IncludeBundle
                        var err error
                        icBundle, found := prevBundleByChannel[ch.Name]
                        switch </span>{
                        case !found:<span class="cov8" title="1">
                                startingBundle, err = getHeadBundle(*ch)</span>
                        case existsInBundleSet(icBundle.MinVersion):<span class="cov8" title="1">
                                startingBundle = icBundle</span>
                        default:<span class="cov8" title="1">
                                minVer, merr := semver.Parse(icBundle.MinVersion)
                                if merr != nil </span><span class="cov0" title="0">{
                                        return nil, merr
                                }</span>
                                <span class="cov8" title="1">startingBundle, err = findNextBundle(versionsToInclude, minVer)</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">newCh.IncludeBundle = startingBundle</span>
                }
                <span class="cov8" title="1">channels = append(channels, newCh)</span>
        }
        <span class="cov8" title="1">return channels, nil</span>
}

// findNextBundle will find the next highest bundle in a set of versions in relation
// to the target.
func findNextBundle(versions []semver.Version, target semver.Version) (v1alpha2.IncludeBundle, error) <span class="cov8" title="1">{
        sort.Slice(versions, func(i, j int) bool </span><span class="cov8" title="1">{
                return versions[i].LT(versions[j])
        }</span>)
        <span class="cov8" title="1">nextVersion := search(versions, target, 0, len(versions)-1)
        return v1alpha2.IncludeBundle{MinVersion: nextVersion.String()}, nil</span>
}

// search perform a binary search to find the next highest version in relation
// to the target. Target can exist or not exist in versions.
func search(versions []semver.Version, target semver.Version, low, high int) semver.Version <span class="cov8" title="1">{
        // Handle some base cases.
        // If the target is the highest version or there are no bundles, there is no next
        // version so return
        if len(versions) == 0 || versions[len(versions)-1].EQ(target) </span><span class="cov8" title="1">{
                return semver.Version{}
        }</span>

        <span class="cov8" title="1">if len(versions) == 1 </span><span class="cov8" title="1">{
                return versions[0]
        }</span>

        <span class="cov8" title="1">if high &lt; low </span><span class="cov8" title="1">{
                return versions[low]
        }</span>

        <span class="cov8" title="1">mid := low + (high-low)/2
        if versions[mid].EQ(target) </span><span class="cov8" title="1">{
                return versions[mid+1]
        }</span>

        <span class="cov8" title="1">if target.GT(versions[mid]) </span><span class="cov8" title="1">{
                return search(versions, target, mid+1, high)
        }</span>

        <span class="cov8" title="1">return search(versions, target, low, mid-1)</span>
}

// getChannelHeads processes each channel in the package and sets the starting
// bundle to the channel head.
func getChannelHeads(mpkg model.Package) ([]v1alpha2.IncludeChannel, error) <span class="cov8" title="1">{
        channels := []v1alpha2.IncludeChannel{}

        for _, ch := range mpkg.Channels </span><span class="cov8" title="1">{
                // initialize channel
                c := v1alpha2.IncludeChannel{
                        Name: ch.Name,
                }

                b, err := getHeadBundle(*ch)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">c.IncludeBundle = b
                channels = append(channels, c)</span>
        }
        <span class="cov8" title="1">return channels, nil</span>
}

// getHeadBundle return the channel head bundle for the current channel.
func getHeadBundle(mch model.Channel) (v1alpha2.IncludeBundle, error) <span class="cov8" title="1">{
        bundle, err := mch.Head()
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha2.IncludeBundle{}, err
        }</span>

        <span class="cov8" title="1">return v1alpha2.IncludeBundle{MinVersion: bundle.Version.String()}, nil</span>
}

// includePackageVersionsSet will verify if user-set version
// information is set on an Include Config for an IncludePackage.
func includePackageVersionsSet(pkg v1alpha2.IncludePackage) bool <span class="cov8" title="1">{
        switch </span>{
        case pkg.MinVersion != "":<span class="cov8" title="1">
                return true</span>
        case pkg.MinBundle != "":<span class="cov0" title="0">
                return true</span>
        case pkg.MaxVersion != "":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// includeChannelVersionsSet will verify if user-set version
// information is set on an Include Config in an IncludeChannel.
func includeChannelVersionsSet(ch v1alpha2.IncludeChannel) bool <span class="cov8" title="1">{
        switch </span>{
        case ch.MinVersion != "":<span class="cov8" title="1">
                return true</span>
        case ch.MinBundle != "":<span class="cov0" title="0">
                return true</span>
        case ch.MaxVersion != "":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func sortPackages(pkgs []v1alpha2.IncludePackage) <span class="cov8" title="1">{
        sort.Slice(pkgs, func(i, j int) bool </span><span class="cov8" title="1">{
                return pkgs[i].Name &lt; pkgs[j].Name
        }</span>)
}

func sortChannels(chs []v1alpha2.IncludeChannel) <span class="cov8" title="1">{
        sort.Slice(chs, func(i, j int) bool </span><span class="cov8" title="1">{
                return chs[i].Name &lt; chs[j].Name
        }</span>)
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package diff

import (
        "context"
        "errors"
        "fmt"
        "io"

        "github.com/blang/semver/v4"
        diffInternal "github.com/openshift/oc-mirror/pkg/operator/diff/internal"
        "github.com/sirupsen/logrus"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/apimachinery/pkg/util/yaml"

        "github.com/operator-framework/operator-registry/alpha/action"
        "github.com/operator-framework/operator-registry/alpha/declcfg"
        "github.com/operator-framework/operator-registry/alpha/model"
        "github.com/operator-framework/operator-registry/pkg/image"
)

type Diff struct {
        Registry image.Registry

        OldRefs []string
        NewRefs []string
        // SkipDependencies directs Run() to not include dependencies
        // of bundles included in the diff if true.
        SkipDependencies bool

        IncludeConfig DiffIncludeConfig
        // IncludeAdditively catalog objects specified in IncludeConfig.
        IncludeAdditively bool
        // HeadsOnly is the mode that selects the head of the channels only.
        HeadsOnly bool

        Logger *logrus.Entry
}

func (diffIn Diff) Run(ctx context.Context) (*declcfg.DeclarativeConfig, error) <span class="cov8" title="1">{
        if err := diffIn.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Disallow bundle refs.
        <span class="cov8" title="1">mask := action.RefDCDir | action.RefDCImage | action.RefSqliteFile | action.RefSqliteImage

        // Heads-only mode does not require an old ref, so there may be nothing to render.
        var oldModel model.Model
        if len(diffIn.OldRefs) != 0 </span><span class="cov8" title="1">{
                oldRender := action.Render{Refs: diffIn.OldRefs, Registry: diffIn.Registry, AllowedRefMask: mask}
                oldCfg, err := oldRender.Run(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, action.ErrNotAllowed) </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("%w (diff does not permit direct bundle references)", err)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("error rendering old refs: %v", err)</span>
                }
                <span class="cov8" title="1">oldModel, err = declcfg.ConvertToModel(*oldCfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting old declarative config to model: %v", err)
                }</span>
        }

        <span class="cov8" title="1">newRender := action.Render{Refs: diffIn.NewRefs, Registry: diffIn.Registry, AllowedRefMask: mask}
        newCfg, err := newRender.Run(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, action.ErrNotAllowed) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%w (diff does not permit direct bundle references)", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error rendering new refs: %v", err)</span>
        }
        <span class="cov8" title="1">newModel, err := declcfg.ConvertToModel(*newCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error converting new declarative config to model: %v", err)
        }</span>

        <span class="cov8" title="1">g := &amp;diffInternal.DiffGenerator{
                Logger:            diffIn.Logger,
                SkipDependencies:  diffIn.SkipDependencies,
                Includer:          convertIncludeConfigToIncluder(diffIn.IncludeConfig),
                IncludeAdditively: diffIn.IncludeAdditively,
                HeadsOnly:         diffIn.HeadsOnly,
        }
        diffModel, err := g.Run(oldModel, newModel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error generating diff: %v", err)
        }</span>

        <span class="cov8" title="1">cfg := declcfg.ConvertFromModel(diffModel)
        return &amp;cfg, nil</span>
}

func (p Diff) validate() error <span class="cov8" title="1">{
        if len(p.NewRefs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no new refs to diff")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// DiffIncludeConfig configures diffInternal.Run() to include a set of packages,
// channels, and/or bundles/versions in the output DeclarativeConfig.
// These override other diff mechanisms. For example, if running in
// heads-only mode but package "foo" channel "stable" is specified,
// the entire "stable" channel (all channel bundles) is added to the output.
type DiffIncludeConfig struct {
        // Packages to include.
        Packages []DiffIncludePackage `json:"packages" yaml:"packages"`
}

// DiffIncludePackage contains a name (required) and channels and/or versions
// (optional) to include in the diffInternal. The full package is only included if no channels
// or versions are specified.
type DiffIncludePackage struct {
        // Name of package.
        Name string `json:"name" yaml:"name"`
        // Channels to include.
        Channels []DiffIncludeChannel `json:"channels,omitempty" yaml:"channels,omitempty"`
        // Versions to include. All channels containing these versions
        // are parsed for an upgrade graph.
        Versions []semver.Version `json:"versions,omitempty" yaml:"versions,omitempty"`
        // Bundles are bundle names to include. All channels containing these bundles
        // are parsed for an upgrade graph.
        // Set this field only if the named bundle has no semantic version metadata.
        Bundles []string `json:"bundles,omitempty" yaml:"bundles,omitempty"`
        // Semver range of versions to include. All channels containing these versions
        // are parsed for an upgrade graph. If the channels don't contain these versions,
        // they will be ignored. This range can only be used with package exclusively
        // and cannot combined with `Range` in `DiffIncludeChannel`.
        // Range setting is mutually exclusive with channel versions/bundles/range settings.
        Range string `json:"range,omitempty" yaml:"range,omitempty"`
}

// DiffIncludeChannel contains a name (required) and versions (optional)
// to include in the diffInternal. The full channel is only included if no versions are specified.
type DiffIncludeChannel struct {
        // Name of channel.
        Name string `json:"name" yaml:"name"`
        // Versions to include.
        Versions []semver.Version `json:"versions,omitempty" yaml:"versions,omitempty"`
        // Bundles are bundle names to include.
        // Set this field only if the named bundle has no semantic version metadata.
        Bundles []string `json:"bundles,omitempty" yaml:"bundles,omitempty"`
        // Semver range of versions to include in the channel. If the channel don't contain
        // these versions, an error will be raised. This range can only be used with
        // channel exclusively and cannot combined with `Range` in `DiffIncludePackage`.
        // Range setting is mutually exclusive with Versions and Bundles settings.
        Range string `json:"range,omitempty" yaml:"range,omitempty"`
}

// LoadDiffIncludeConfig loads a (YAML or JSON) DiffIncludeConfig from r.
func LoadDiffIncludeConfig(r io.Reader) (c DiffIncludeConfig, err error) <span class="cov8" title="1">{
        dec := yaml.NewYAMLOrJSONDecoder(r, 8)
        if err := dec.Decode(&amp;c); err != nil </span><span class="cov8" title="1">{
                return DiffIncludeConfig{}, err
        }</span>

        <span class="cov8" title="1">if len(c.Packages) == 0 </span><span class="cov0" title="0">{
                return c, fmt.Errorf("must specify at least one package in include config")
        }</span>

        <span class="cov8" title="1">var errs []error
        for pkgI, pkg := range c.Packages </span><span class="cov8" title="1">{
                if pkg.Name == "" </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("package at index %v requires a name", pkgI))
                        continue</span>
                }
                <span class="cov8" title="1">if pkg.Range != "" &amp;&amp; (len(pkg.Versions) != 0 || len(pkg.Bundles) != 0) </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("package %q contains invalid settings: range and versions and/or bundles are mutually exclusive", pkg.Name))
                }</span>
                <span class="cov8" title="1">if pkg.Range != "" </span><span class="cov8" title="1">{
                        _, err := semver.ParseRange(pkg.Range)
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("package %q has an invalid version range %s", pkg.Name, pkg.Range))
                        }</span>
                }
                <span class="cov8" title="1">for chI, ch := range pkg.Channels </span><span class="cov8" title="1">{
                        if ch.Name == "" </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("package %s: channel at index %v requires a name", pkg.Name, chI))
                                continue</span>
                        }
                        <span class="cov8" title="1">if ch.Range == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if ch.Range != "" &amp;&amp; (len(ch.Versions) != 0 || len(ch.Bundles) != 0) </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("package %q: channel %q contains invalid settings: range and versions and/or bundles are mutually exclusive", pkg.Name, ch.Name))
                        }</span>
                        <span class="cov8" title="1">if pkg.Range != "" &amp;&amp; ch.Range != "" </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("version range settings in package %q and in channel %q must be mutually exclusive", pkg.Name, ch.Name))
                        }</span>
                        <span class="cov8" title="1">_, err := semver.ParseRange(ch.Range)
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("package %s: channel %q has an invalid version range %s", pkg.Name, ch.Name, pkg.Range))
                        }</span>
                }
        }
        <span class="cov8" title="1">return c, utilerrors.NewAggregate(errs)</span>
}

func convertIncludeConfigToIncluder(c DiffIncludeConfig) (includer diffInternal.DiffIncluder) <span class="cov8" title="1">{
        includer.Packages = make([]diffInternal.DiffIncludePackage, len(c.Packages))
        for pkgI, cpkg := range c.Packages </span><span class="cov8" title="1">{
                pkg := &amp;includer.Packages[pkgI]
                pkg.Name = cpkg.Name
                pkg.AllChannels.Versions = cpkg.Versions
                pkg.AllChannels.Bundles = cpkg.Bundles
                if cpkg.Range != "" </span><span class="cov0" title="0">{
                        pkg.Range, _ = semver.ParseRange(cpkg.Range)
                }</span>

                <span class="cov8" title="1">if len(cpkg.Channels) != 0 </span><span class="cov8" title="1">{
                        pkg.Channels = make([]diffInternal.DiffIncludeChannel, len(cpkg.Channels))
                        for chI, cch := range cpkg.Channels </span><span class="cov8" title="1">{
                                ch := &amp;pkg.Channels[chI]
                                ch.Name = cch.Name
                                ch.Versions = cch.Versions
                                ch.Bundles = cch.Bundles
                                if cch.Range != "" </span><span class="cov0" title="0">{
                                        ch.Range, _ = semver.ParseRange(cch.Range)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return includer</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package internal

import (
        "fmt"
        "reflect"
        "sort"
        "strings"
        "sync"

        "github.com/blang/semver/v4"
        "github.com/mitchellh/hashstructure/v2"
        "github.com/sirupsen/logrus"
        "k8s.io/klog/v2"

        "github.com/operator-framework/operator-registry/alpha/declcfg"
        "github.com/operator-framework/operator-registry/alpha/model"
        "github.com/operator-framework/operator-registry/alpha/property"
)

// DiffGenerator configures how diffs are created via Run().
type DiffGenerator struct {
        Logger *logrus.Entry

        // SkipDependencies directs Run() to not include dependencies
        // of bundles included in the diff if true.
        SkipDependencies bool
        // Includer for adding catalog objects to Run() output.
        Includer DiffIncluder
        // IncludeAdditively catalog objects specified in Includer in headsOnly mode.
        IncludeAdditively bool
        // HeadsOnly is the mode that selects the head of the channels only.
        HeadsOnly bool

        initOnce sync.Once
}

func (g *DiffGenerator) init() <span class="cov8" title="1">{
        g.initOnce.Do(func() </span><span class="cov8" title="1">{
                if g.Logger == nil </span><span class="cov8" title="1">{
                        g.Logger = &amp;logrus.Entry{}
                }</span>
                <span class="cov8" title="1">if g.Includer.Logger == nil </span><span class="cov8" title="1">{
                        g.Includer.Logger = g.Logger
                }</span>
                // Inject headsOnly setting into DiffIncluder from command line setting
                <span class="cov8" title="1">g.Includer.HeadsOnly = g.HeadsOnly</span>
        })
}

// Run returns a Model containing a subset of catalog objects in newModel:
// - If g.Includer contains objects:
//   - If g.IncludeAdditively is false, a diff will be generated only on those objects,
//     depending on the mode.
//   - If g.IncludeAdditionally is true, the diff will contain included objects,
//     plus those added by the mode.
//
// - If in heads-only mode (oldModel == nil), then the heads of channels are added to the output.
// - If in latest mode, a diff between old and new Models is added to the output.
// - Dependencies are added in all modes if g.SkipDependencies is false.
func (g *DiffGenerator) Run(oldModel, newModel model.Model) (model.Model, error) <span class="cov8" title="1">{
        g.init()

        // TODO(estroz): loading both oldModel and newModel into memory may
        // exceed process/hardware limits. Instead, store models on-disk then
        // load by package.

        outputModel := model.Model{}

        // Prunes old objects from outputModel if they exist.
        latestPruneFromOutput := func() error </span><span class="cov8" title="1">{

                for _, outputPkg := range outputModel </span><span class="cov8" title="1">{
                        oldPkg, oldHasPkg := oldModel[outputPkg.Name]
                        if !oldHasPkg </span><span class="cov8" title="1">{
                                // outputPkg was already copied to outputModel above.
                                continue</span>
                        }
                        <span class="cov8" title="1">if err := pruneOldFromNewPackage(oldPkg, outputPkg); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if len(outputPkg.Channels) == 0 </span><span class="cov8" title="1">{
                                // Remove empty packages.
                                delete(outputModel, outputPkg.Name)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">headsOnlyMode := g.HeadsOnly
        latestMode := !headsOnlyMode
        isInclude := len(g.Includer.Packages) != 0

        switch </span>{
        case !g.IncludeAdditively &amp;&amp; isInclude:<span class="cov8" title="1"> // Only diff between included objects.

                // Add included packages/channels/bundles from newModel to outputModel.
                if err := g.Includer.Run(newModel, outputModel); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if latestMode </span><span class="cov8" title="1">{
                        if err := latestPruneFromOutput(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">for _, outputPkg := range outputModel </span><span class="cov8" title="1">{
                        for _, ch := range outputPkg.Channels </span><span class="cov8" title="1">{
                                if len(ch.Bundles) == 0 </span><span class="cov8" title="1">{
                                        delete(outputPkg.Channels, ch.Name)
                                }</span>
                        }
                        <span class="cov8" title="1">if len(outputPkg.Channels) == 0 </span><span class="cov8" title="1">{
                                // Remove empty packages.
                                delete(outputModel, outputPkg.Name)
                        }</span>
                }
        case isInclude:<span class="cov8" title="1"> // Add included objects to outputModel.

                // Assume heads-only is false for include additively since we already have the channel heads
                // in the output model.
                g.Includer.HeadsOnly = false
                // Add included packages/channels/bundles from newModel to outputModel.
                if err := g.Includer.Run(newModel, outputModel); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">fallthrough</span>
        default:<span class="cov8" title="1">

                if headsOnlyMode </span><span class="cov8" title="1">{ // Net-new diff of heads only.

                        // Make shallow copies of packages and channels that are only
                        // filled with channel heads.
                        for _, newPkg := range newModel </span><span class="cov8" title="1">{
                                // This package may have been created in the include step.
                                outputPkg, pkgIncluded := outputModel[newPkg.Name]
                                if !pkgIncluded </span><span class="cov8" title="1">{
                                        outputPkg = copyPackageNoChannels(newPkg)
                                        outputModel[outputPkg.Name] = outputPkg
                                }</span>
                                <span class="cov8" title="1">for _, newCh := range newPkg.Channels </span><span class="cov8" title="1">{
                                        if _, chIncluded := outputPkg.Channels[newCh.Name]; chIncluded </span><span class="cov8" title="1">{
                                                // Head (and other bundles) were added in the include step.
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">outputCh := copyChannelNoBundles(newCh, outputPkg)
                                        outputPkg.Channels[outputCh.Name] = outputCh
                                        head, err := newCh.Head()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">outputBundle := copyBundle(head, outputCh, outputPkg)
                                        outputModel.AddBundle(*outputBundle)</span>
                                }
                        }

                } else<span class="cov8" title="1"> { // Diff between old and new Model.

                        // Copy newModel to create an output model by deletion,
                        // which is more succinct than by addition.
                        for _, newPkg := range newModel </span><span class="cov8" title="1">{
                                if _, pkgIncluded := outputModel[newPkg.Name]; pkgIncluded </span><span class="cov0" title="0">{
                                        // The user has specified the state they want this package to have in the diff
                                        // via an inclusion entry, so the package created above should not be changed.
                                        continue</span>
                                }
                                <span class="cov8" title="1">outputModel[newPkg.Name] = copyPackage(newPkg)</span>
                        }

                        <span class="cov8" title="1">if err := latestPruneFromOutput(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                }

        }

        <span class="cov8" title="1">if !g.SkipDependencies </span><span class="cov8" title="1">{
                // Add dependencies to outputModel not already present in oldModel.
                if err := addAllDependencies(newModel, oldModel, outputModel); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Default channel may not have been copied, so set it to the new default channel here.
        <span class="cov8" title="1">for _, outputPkg := range outputModel </span><span class="cov8" title="1">{
                newPkg, found := newModel[outputPkg.Name]
                if !found </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("package %s not present in the diff new model", outputPkg.Name)
                }</span>
                <span class="cov8" title="1">var outputHasDefault bool
                outputPkg.DefaultChannel, outputHasDefault = outputPkg.Channels[newPkg.DefaultChannel.Name]
                if !outputHasDefault </span><span class="cov8" title="1">{
                        // Set the defaultChannel using the priority of a channel when the default got filtered out
                        // If no channels with the Priority property, raise an error
                        if err := setDefaultChannel(outputPkg, newPkg.DefaultChannel.Name); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return outputModel, nil</span>
}

type channelPriority struct {
        property property.Channel
        channel  *model.Channel
}

type channelPriorityPropList []channelPriority

// setDefaultChannel sets the new default channel of a package if the old default channel got filtered out.
// Throws an error if there are no channels with the Priority property
func setDefaultChannel(outputPkg *model.Package, newPackageDefaultChannelName string) error <span class="cov8" title="1">{
        priorities := channelPriorityPropList{}
        priorityOccurrence := map[int][]string{}

        for _, channel := range outputPkg.Channels </span><span class="cov8" title="1">{
                properties, err := property.Parse(channel.Properties)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, channelProperty := range properties.Channels </span><span class="cov8" title="1">{
                        priorityValue := channelProperty.Priority
                        if len(priorityOccurrence[priorityValue]) &gt; 0 </span><span class="cov0" title="0">{
                                klog.Warningf(
                                        "Priority %d of channel %s has already been defined for channels: %s",
                                        priorityValue, channelProperty.ChannelName, strings.Join(priorityOccurrence[priorityValue], ", "),
                                )
                        }</span>
                        <span class="cov8" title="1">priorityOccurrence[priorityValue] = append(priorityOccurrence[priorityValue], channelProperty.ChannelName)

                        priorities = append(priorities, channelPriority{
                                property: channelProperty,
                                channel:  channel,
                        })</span>
                }
        }

        <span class="cov8" title="1">if len(priorities) &gt; 0 </span><span class="cov8" title="1">{
                sort.Slice(priorities, func(j, k int) bool </span><span class="cov8" title="1">{ return priorities[j].property.Priority &lt; priorities[k].property.Priority }</span>)

                <span class="cov8" title="1">klog.V(1).Infof("defaultChannel choices sorted by priority for package: %s\n", outputPkg.Name)
                for _, priority := range priorities </span><span class="cov8" title="1">{
                        klog.V(1).Infof("%v\t%v\n", priority.property.ChannelName, priority.property.Priority)
                }</span>

                <span class="cov8" title="1">outputPkg.DefaultChannel = priorities[len(priorities)-1].channel
                klog.V(0).Infof("Newly assigned default channel from existing channels by Priority is %s\n", outputPkg.DefaultChannel.Name)
                return nil</span>
        }

        // include a verbose message in the log so someone can figure out what to do next
        <span class="cov8" title="1">klog.V(0).Infof(`The current default channel was not valid, so an attempt was made to automatically assign a new default channel, which has failed.
The failure occurred because none of the remaining channels contain an "olm.channel" priority property, so it was not possible to establish a channel to use as the default channel.

This can be resolved by one of the following changes:
1) assign an "olm.channel" property on the appropriate channels to establish a channel priority
2) modify the default channel manually in the catalog
3) by changing the ImageSetConfiguration to filter channels or packages in such a way that it will include a package version that exists in the current default channel`)

        // include a short message that does not mention any of the above to keep things simple
        return fmt.Errorf("the current default channel %q for package %q could not be determined... ensure that your ImageSetConfiguration filtering criteria results in a package version that exists in the current default channel", newPackageDefaultChannelName, outputPkg.Name)</span>
}

// pruneOldFromNewPackage prune any bundles and channels from newPkg that
// are in oldPkg, but not those that differ in any way.
func pruneOldFromNewPackage(oldPkg, newPkg *model.Package) error <span class="cov8" title="1">{
        for _, newCh := range newPkg.Channels </span><span class="cov8" title="1">{
                oldCh, oldHasCh := oldPkg.Channels[newCh.Name]
                if !oldHasCh </span><span class="cov8" title="1">{
                        // newCh is assumed to have been copied to outputModel by the caller.
                        continue</span>
                }

                <span class="cov8" title="1">for _, newBundle := range newCh.Bundles </span><span class="cov8" title="1">{
                        oldBundle, oldHasBundle := oldCh.Bundles[newBundle.Name]
                        if !oldHasBundle </span><span class="cov8" title="1">{
                                // newBundle is copied to outputModel by the caller if it is a channel head.
                                continue</span>
                        }
                        <span class="cov8" title="1">equal, err := bundlesEqual(oldBundle, newBundle)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if equal </span><span class="cov8" title="1">{
                                delete(newCh.Bundles, newBundle.Name)
                        }</span>
                }
                <span class="cov8" title="1">if len(newCh.Bundles) == 0 </span><span class="cov8" title="1">{
                        // Remove empty channels.
                        delete(newPkg.Channels, newCh.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// bundlesEqual computes then compares the hashes of b1 and b2 for equality.
func bundlesEqual(b1, b2 *model.Bundle) (bool, error) <span class="cov8" title="1">{
        // Use a declarative config bundle type to avoid infinite recursion.
        dcBundle1 := convertFromModelBundle(b1)
        dcBundle2 := convertFromModelBundle(b2)

        hash1, err := hashstructure.Hash(dcBundle1, hashstructure.FormatV2, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">hash2, err := hashstructure.Hash(dcBundle2, hashstructure.FormatV2, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        // CsvJSON and Objects are ignored by Hash, so they must be compared separately.
        <span class="cov8" title="1">return hash1 == hash2 &amp;&amp; b1.CsvJSON == b2.CsvJSON &amp;&amp; reflect.DeepEqual(b1.Objects, b2.Objects), nil</span>
}

func addAllDependencies(newModel, oldModel, outputModel model.Model) error <span class="cov8" title="1">{
        // Get every oldModel's bundle's dependencies, and their dependencies, etc. by BFS.
        providingBundlesByPackage := map[string][]*model.Bundle{}
        var visitedBundles []*model.Bundle
        for currentList := getBundles(outputModel); len(currentList) != 0; </span><span class="cov8" title="1">{
                visitedBundles = append(visitedBundles, currentList...)
                reqGVKs, reqPkgs, err := findDependencies(currentList)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Break early so the entire source model is not iterated through unnecessarily.
                <span class="cov8" title="1">if len(reqGVKs) == 0 &amp;&amp; len(reqPkgs) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">currentList = nil
                // Get bundles that provide dependencies from newModel, which should have
                // the latest bundles of each dependency package.
                for _, pkg := range newModel </span><span class="cov8" title="1">{
                        providingBundles := getBundlesThatProvide(pkg, reqGVKs, reqPkgs)
                        unvisitedProvidingBundles := difference(visitedBundles, providingBundles)
                        currentList = append(currentList, unvisitedProvidingBundles...)

                        oldPkg, oldHasPkg := oldModel[pkg.Name]
                        for _, b := range unvisitedProvidingBundles </span><span class="cov8" title="1">{
                                // If the bundle is not in oldModel, add it to the set.
                                // outputModel is checked below.
                                add := true
                                if oldHasPkg </span><span class="cov8" title="1">{
                                        if oldCh, oldHasCh := oldPkg.Channels[b.Channel.Name]; oldHasCh </span><span class="cov8" title="1">{
                                                _, oldHasBundle := oldCh.Bundles[b.Name]
                                                add = !oldHasBundle
                                        }</span>
                                }
                                <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                                        providingBundlesByPackage[b.Package.Name] = append(providingBundlesByPackage[b.Package.Name], b)
                                }</span>
                        }
                }
        }

        // Add the diff between an oldModel dependency package and its new counterpart
        // or the entire package if oldModel does not have it.
        <span class="cov8" title="1">for pkgName, bundles := range providingBundlesByPackage </span><span class="cov8" title="1">{
                newPkg := newModel[pkgName]
                heads := make(map[string]*model.Bundle, len(newPkg.Channels))
                for _, ch := range newPkg.Channels </span><span class="cov8" title="1">{
                        var err error
                        if heads[ch.Name], err = ch.Head(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Sort by version then channel so bundles lower in the full graph are more likely
                // to be included in previous loops.
                <span class="cov8" title="1">sort.Slice(bundles, func(i, j int) bool </span><span class="cov8" title="1">{
                        if bundles[i].Channel.Name == bundles[j].Channel.Name </span><span class="cov8" title="1">{
                                return bundles[i].Version.LT(bundles[j].Version)
                        }</span>
                        <span class="cov0" title="0">return bundles[i].Channel.Name &lt; bundles[j].Channel.Name</span>
                })

                <span class="cov8" title="1">for _, b := range bundles </span><span class="cov8" title="1">{
                        newCh := b.Channel

                        // Continue if b was added in a previous loop iteration.
                        // Otherwise create a new package/channel for b if they do not exist.
                        var (
                                outputPkg *model.Package
                                outputCh  *model.Channel

                                outHasPkg, outHasCh bool
                        )
                        if outputPkg, outHasPkg = outputModel[b.Package.Name]; outHasPkg </span><span class="cov8" title="1">{
                                if outputCh, outHasCh = outputPkg.Channels[b.Channel.Name]; outHasCh </span><span class="cov8" title="1">{
                                        if _, outputHasBundle := outputCh.Bundles[b.Name]; outputHasBundle </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                }
                        } else<span class="cov8" title="1"> {
                                outputPkg = copyPackageNoChannels(newPkg)
                                outputModel[outputPkg.Name] = outputPkg
                        }</span>
                        <span class="cov8" title="1">if !outHasCh </span><span class="cov8" title="1">{
                                outputCh = copyChannelNoBundles(newCh, outputPkg)
                                outputPkg.Channels[outputCh.Name] = outputCh
                        }</span>

                        <span class="cov8" title="1">head := heads[newCh.Name]
                        graph := makeUpgradeGraph(newCh)

                        //OCPBUGS-11371 - bundles in skips field should not be considered since they are not part of upgradeGraph
                        if isToSkip(*b, *head) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">intersectingBundles, intersectionFound := findIntersectingBundles(newCh, b, head, graph)
                        if !intersectionFound </span><span class="cov0" title="0">{
                                // This should never happen, since b and head are from the same model.
                                return fmt.Errorf("channel %s: head %q not reachable from bundle %q", newCh.Name, head.Name, b.Name)
                        }</span>
                        <span class="cov8" title="1">for _, ib := range intersectingBundles </span><span class="cov8" title="1">{
                                if _, outHasBundle := outputCh.Bundles[ib.Name]; !outHasBundle </span><span class="cov8" title="1">{
                                        outputCh.Bundles[ib.Name] = copyBundle(ib, outputCh, outputPkg)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func difference(a, b []*model.Bundle) []*model.Bundle <span class="cov8" title="1">{
        aMap := make(map[*model.Bundle]struct{})
        for _, bd := range a </span><span class="cov8" title="1">{
                aMap[bd] = struct{}{}
        }</span>
        <span class="cov8" title="1">uniqueBundles := make([]*model.Bundle, 0)
        for _, bd := range b </span><span class="cov8" title="1">{
                if _, present := aMap[bd]; !present </span><span class="cov8" title="1">{
                        uniqueBundles = append(uniqueBundles, bd)
                }</span>
        }
        <span class="cov8" title="1">return uniqueBundles</span>
}

// getBundles collects all bundles specified by m. Since each bundle
// references its package, their uniqueness property holds in a flat list.
func getBundles(m model.Model) (bundles []*model.Bundle) <span class="cov8" title="1">{
        for _, pkg := range m </span><span class="cov8" title="1">{
                for _, ch := range pkg.Channels </span><span class="cov8" title="1">{
                        for _, b := range ch.Bundles </span><span class="cov8" title="1">{
                                bundles = append(bundles, b)
                        }</span>
                }
        }
        <span class="cov8" title="1">return bundles</span>
}

// findDependencies finds all GVK and package dependencies and indexes them
// by the apropriate key for lookups.
func findDependencies(bundles []*model.Bundle) (map[property.GVK]struct{}, map[string][]semver.Range, error) <span class="cov8" title="1">{
        // Find all dependencies of bundles in the output model.
        reqGVKs := map[property.GVK]struct{}{}
        reqPkgs := map[string][]semver.Range{}
        for _, b := range bundles </span><span class="cov8" title="1">{

                for _, gvkReq := range b.PropertiesP.GVKsRequired </span><span class="cov8" title="1">{
                        gvk := property.GVK{
                                Group:   gvkReq.Group,
                                Version: gvkReq.Version,
                                Kind:    gvkReq.Kind,
                        }
                        reqGVKs[gvk] = struct{}{}
                }</span>

                <span class="cov8" title="1">for _, pkgReq := range b.PropertiesP.PackagesRequired </span><span class="cov8" title="1">{
                        var inRange semver.Range
                        if pkgReq.VersionRange != "" </span><span class="cov8" title="1">{
                                var err error
                                if inRange, err = semver.ParseRange(pkgReq.VersionRange); err != nil </span><span class="cov0" title="0">{
                                        // Should never happen since model has been validated.
                                        return nil, nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Any bundle in this package will satisfy a range-less package requirement.
                                inRange = func(semver.Version) bool </span><span class="cov0" title="0">{ return true }</span>
                        }
                        <span class="cov8" title="1">reqPkgs[pkgReq.PackageName] = append(reqPkgs[pkgReq.PackageName], inRange)</span>
                }
        }

        <span class="cov8" title="1">return reqGVKs, reqPkgs, nil</span>
}

// getBundlesThatProvide returns the latest-version bundles in pkg that provide
// a GVK or version in reqGVKs or reqPkgs, respectively.
func getBundlesThatProvide(pkg *model.Package, reqGVKs map[property.GVK]struct{}, reqPkgs map[string][]semver.Range) (providingBundles []*model.Bundle) <span class="cov8" title="1">{
        // Pre-allocate the amount of space needed for all ranges
        // specified by requiring bundles.
        var bundlesByRange [][]*model.Bundle
        ranges, isPkgRequired := reqPkgs[pkg.Name]
        if isPkgRequired </span><span class="cov8" title="1">{
                bundlesByRange = make([][]*model.Bundle, len(ranges))
        }</span>

        // Collect package bundles that provide a GVK or are in a range.
        <span class="cov8" title="1">bundlesProvidingGVK := make(map[property.GVK][]*model.Bundle)
        for _, ch := range pkg.Channels </span><span class="cov8" title="1">{
                for _, b := range ch.Bundles </span><span class="cov8" title="1">{
                        for _, gvk := range b.PropertiesP.GVKs </span><span class="cov8" title="1">{
                                if _, hasGVK := reqGVKs[gvk]; hasGVK </span><span class="cov8" title="1">{
                                        bundlesProvidingGVK[gvk] = append(bundlesProvidingGVK[gvk], b)
                                }</span>
                        }
                        <span class="cov8" title="1">for i, inRange := range ranges </span><span class="cov8" title="1">{
                                if inRange(b.Version) </span><span class="cov8" title="1">{
                                        bundlesByRange[i] = append(bundlesByRange[i], b)
                                }</span>
                        }
                }
        }

        // Sort bundles providing a GVK by version and use the latest version.
        <span class="cov8" title="1">latestBundles := make(map[string]*model.Bundle)
        for gvk, bundles := range bundlesProvidingGVK </span><span class="cov8" title="1">{
                sort.Slice(bundles, func(i, j int) bool </span><span class="cov8" title="1">{
                        // sort by version
                        sortedByVersion := bundles[i].Version.LT(bundles[j].Version)

                        // sort by channel
                        // prioritize default channel bundles
                        if bundles[i].Version.EQ(bundles[j].Version) </span><span class="cov8" title="1">{
                                return bundles[i].Channel != pkg.DefaultChannel
                        }</span>
                        <span class="cov8" title="1">return sortedByVersion</span>
                })
                <span class="cov8" title="1">lb := bundles[len(bundles)-1]
                latestBundles[lb.Version.String()] = lb
                delete(reqGVKs, gvk)</span>
        }

        // Sort bundles in a range by version and use the latest version.
        <span class="cov8" title="1">unsatisfiedRanges := []semver.Range{}
        for i, bundlesInRange := range bundlesByRange </span><span class="cov8" title="1">{
                if len(bundlesInRange) == 0 </span><span class="cov0" title="0">{
                        unsatisfiedRanges = append(unsatisfiedRanges, ranges[i])
                        continue</span>
                }
                <span class="cov8" title="1">sort.Slice(bundlesInRange, func(i, j int) bool </span><span class="cov8" title="1">{
                        // sort by version
                        sortedByVersion := bundlesInRange[i].Version.LT(bundlesInRange[j].Version)

                        // sort by channel
                        // prioritize default channel bundles
                        if bundlesInRange[i].Version.EQ(bundlesInRange[j].Version) </span><span class="cov0" title="0">{
                                return bundlesInRange[i].Channel != pkg.DefaultChannel
                        }</span>
                        <span class="cov8" title="1">return sortedByVersion</span>
                })
                <span class="cov8" title="1">lb := bundlesInRange[len(bundlesInRange)-1]
                latestBundles[lb.Version.String()] = lb</span>
        }
        <span class="cov8" title="1">if isPkgRequired &amp;&amp; len(unsatisfiedRanges) == 0 </span><span class="cov8" title="1">{
                delete(reqPkgs, pkg.Name)
        }</span>
        // TODO(estroz): handle missed ranges with logs.

        // Return deduplicated bundles that provide GVKs/versions.
        <span class="cov8" title="1">for _, b := range latestBundles </span><span class="cov8" title="1">{
                providingBundles = append(providingBundles, b)
        }</span>
        <span class="cov8" title="1">return providingBundles</span>
}

// isToSkip detects if the bundle is skipped by the head of the channel
func isToSkip(b model.Bundle, head model.Bundle) bool <span class="cov8" title="1">{
        for _, versionToSkip := range head.Skips </span><span class="cov8" title="1">{
                if versionToSkip == b.Name </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func convertFromModelBundle(b *model.Bundle) declcfg.Bundle <span class="cov8" title="1">{
        return declcfg.Bundle{
                Schema:        declcfg.SchemaBundle,
                Name:          b.Name,
                Package:       b.Package.Name,
                Image:         b.Image,
                RelatedImages: declcfg.ModelRelatedImagesToRelatedImages(b.RelatedImages),
                CsvJSON:       b.CsvJSON,
                Objects:       b.Objects,
                Properties:    b.Properties,
        }
}</span>

func copyPackageNoChannels(in *model.Package) *model.Package <span class="cov8" title="1">{
        cp := &amp;model.Package{
                Name:        in.Name,
                Description: in.Description,
                Channels:    make(map[string]*model.Channel, len(in.Channels)),
        }
        if in.Icon != nil </span><span class="cov0" title="0">{
                cp.Icon = &amp;model.Icon{
                        Data:      make([]byte, len(in.Icon.Data)),
                        MediaType: in.Icon.MediaType,
                }
                copy(cp.Icon.Data, in.Icon.Data)
        }</span>
        <span class="cov8" title="1">return cp</span>
}

func copyPackage(in *model.Package) *model.Package <span class="cov8" title="1">{
        cp := copyPackageNoChannels(in)
        for _, ch := range in.Channels </span><span class="cov8" title="1">{
                cp.Channels[ch.Name] = copyChannel(ch, cp)
        }</span>
        <span class="cov8" title="1">return cp</span>
}

func copyChannelNoBundles(in *model.Channel, pkg *model.Package) *model.Channel <span class="cov8" title="1">{
        cp := &amp;model.Channel{
                Name:       in.Name,
                Package:    pkg,
                Bundles:    make(map[string]*model.Bundle, len(in.Bundles)),
                Properties: in.Properties,
        }
        return cp
}</span>

func copyChannel(in *model.Channel, pkg *model.Package) *model.Channel <span class="cov8" title="1">{
        cp := copyChannelNoBundles(in, pkg)
        for _, b := range in.Bundles </span><span class="cov8" title="1">{
                cp.Bundles[b.Name] = copyBundle(b, cp, pkg)
        }</span>
        <span class="cov8" title="1">return cp</span>
}

func copyBundle(in *model.Bundle, ch *model.Channel, pkg *model.Package) *model.Bundle <span class="cov8" title="1">{
        cp := &amp;model.Bundle{
                Name:      in.Name,
                Channel:   ch,
                Package:   pkg,
                Image:     in.Image,
                Replaces:  in.Replaces,
                Version:   semver.MustParse(in.Version.String()),
                CsvJSON:   in.CsvJSON,
                SkipRange: in.SkipRange,
        }
        if in.PropertiesP != nil </span><span class="cov8" title="1">{
                cp.PropertiesP = new(property.Properties)
                *cp.PropertiesP = *in.PropertiesP
        }</span>
        <span class="cov8" title="1">if len(in.Skips) != 0 </span><span class="cov8" title="1">{
                cp.Skips = make([]string, len(in.Skips))
                copy(cp.Skips, in.Skips)
        }</span>
        <span class="cov8" title="1">if len(in.Properties) != 0 </span><span class="cov8" title="1">{
                cp.Properties = make([]property.Property, len(in.Properties))
                copy(cp.Properties, in.Properties)
        }</span>
        <span class="cov8" title="1">if len(in.RelatedImages) != 0 </span><span class="cov0" title="0">{
                cp.RelatedImages = make([]model.RelatedImage, len(in.RelatedImages))
                copy(cp.RelatedImages, in.RelatedImages)
        }</span>
        <span class="cov8" title="1">if len(in.Objects) != 0 </span><span class="cov0" title="0">{
                cp.Objects = make([]string, len(in.Objects))
                copy(cp.Objects, in.Objects)
        }</span>
        <span class="cov8" title="1">return cp</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package internal

import (
        "fmt"
        "strings"

        "github.com/blang/semver/v4"
        "github.com/sirupsen/logrus"
        utilerrors "k8s.io/apimachinery/pkg/util/errors"

        "github.com/operator-framework/operator-registry/alpha/model"
)

// DiffIncludeConfig configures Diff.Run() to include a set of packages,
// channels, and/or bundles/versions in the output DeclarativeConfig.
// These override other diff mechanisms. For example, if running in
// heads-only mode but package "foo" channel "stable" is specified,
// the entire "stable" channel (all channel bundles) is added to the output.
type DiffIncludeConfig struct {
        // Packages to include.
        Packages []DiffIncludePackage `json:"packages" yaml:"packages"`
}

// DiffIncluder knows how to add packages, channels, and bundles
// from a source to a destination model.Model.
type DiffIncluder struct {
        // Packages to add.
        Packages []DiffIncludePackage
        Logger   *logrus.Entry
        // HeadsOnly is the mode that selects the head of the channels only.
        // This setting will be overridden by any versions or bundles in the channels.
        HeadsOnly bool
}

// DiffIncludePackage specifies a package, and optionally channels
// or a set of bundles from all channels (wrapped by a DiffIncludeChannel),
// to include.
type DiffIncludePackage struct {
        // Name of package.
        Name string
        // Channels in package.
        Channels []DiffIncludeChannel
        // AllChannels contains bundle versions in package.
        // Upgrade graphs from all channels in the named package containing a version
        // from this field are included.
        AllChannels DiffIncludeChannel
        // The semver range of bundle versions.
        // Package range setting is mutually exclusive with channel range/bundles/version
        // settings.
        Range semver.Range
        // HeadsOnly is the mode that selects the head of the channels only.
        // This setting will be overridden by any versions or bundles in the channels.
        HeadsOnly bool
}

// DiffIncludeChannel specifies a channel, and optionally bundles and bundle versions
// (or version range) to include.
type DiffIncludeChannel struct {
        // Name of channel.
        Name string
        // Versions of bundles.
        Versions []semver.Version
        // Bundles are bundle names to include.
        // Set this field only if the named bundle has no semantic version metadata.
        Bundles []string
        // The semver range of bundle versions.
        // Range setting is mutually exclusive with Versions and Bundles settings.
        Range semver.Range
}

func (dip DiffIncludePackage) Validate() error <span class="cov8" title="1">{
        var errs []error
        if dip.Name == "" </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("missing package name"))
        }</span>

        <span class="cov8" title="1">var isChannelSet bool
        for _, ch := range dip.Channels </span><span class="cov8" title="1">{
                isChannelSet = ch.isChannelSet()
                err := ch.Validate()
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">isChannelSet = dip.AllChannels.isChannelSet()
        if isChannelSet &amp;&amp; dip.Range != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("package range setting is mutually exclusive with channel versions/bundles/range settings"))
        }</span>

        <span class="cov8" title="1">if len(errs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DiffIncludePackage config for package %q:\n%v", dip.Name, utilerrors.NewAggregate(errs))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// isChannelSet returns true if at least one of Range/Bundles/Versions is set
func (dic DiffIncludeChannel) isChannelSet() bool <span class="cov8" title="1">{
        return dic.Range != nil || len(dic.Versions) != 0 || len(dic.Bundles) != 0
}</span>

func (dic DiffIncludeChannel) Validate() error <span class="cov8" title="1">{
        var errs []error
        if dic.Name == "" </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("missing channel name"))
        }</span>

        <span class="cov8" title="1">if dic.Range != nil &amp;&amp; (len(dic.Versions) != 0 || len(dic.Bundles) != 0) </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("Channel %q: range and versions/bundles are mutually exclusive", dic.Name))
        }</span>

        <span class="cov8" title="1">if len(errs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DiffIncludeChannel config for channel %q:\n%v", dic.Name, utilerrors.NewAggregate(errs))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (i DiffIncluder) Validate() error <span class="cov8" title="1">{
        var errs []error
        for _, pkg := range i.Packages </span><span class="cov8" title="1">{
                err := pkg.Validate()
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">if len(errs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DiffIncluder config:\n%v", utilerrors.NewAggregate(errs))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Run adds all packages and channels in DiffIncluder with matching names
// directly, and all versions plus their upgrade graphs to channel heads,
// from newModel to outputModel.
func (i DiffIncluder) Run(newModel, outputModel model.Model) error <span class="cov8" title="1">{
        var includeErrs []error
        if err := i.Validate(); err != nil </span><span class="cov0" title="0">{
                includeErrs = append(includeErrs, err)
                return fmt.Errorf("invalid DiffIncluder config:\n%v", utilerrors.NewAggregate(includeErrs))
        }</span>

        <span class="cov8" title="1">for _, ipkg := range i.Packages </span><span class="cov8" title="1">{
                pkgLog := i.Logger.WithField("package", ipkg.Name)
                ipkg.HeadsOnly = i.HeadsOnly
                includeErrs = append(includeErrs, ipkg.includeNewInOutputModel(newModel, outputModel, pkgLog)...)
        }</span>
        <span class="cov8" title="1">if len(includeErrs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("error including items:\n%v", utilerrors.NewAggregate(includeErrs))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// includeNewInOutputModel adds all packages, channels, and range (or versions/bundles)
// specified by ipkg that exist in newModel to outputModel. Any package, channel,
// or version in ipkg not satisfied by newModel is an error.
func (ipkg DiffIncludePackage) includeNewInOutputModel(newModel, outputModel model.Model, logger *logrus.Entry) (ierrs []error) <span class="cov8" title="1">{

        newPkg, newHasPkg := newModel[ipkg.Name]
        if !newHasPkg </span><span class="cov0" title="0">{
                ierrs = append(ierrs, fmt.Errorf("[package=%q] package does not exist in new model", ipkg.Name))
                return ierrs
        }</span>
        <span class="cov8" title="1">pkgLog := logger.WithField("package", newPkg.Name)

        // No range, channels or versions were specified
        if len(ipkg.Channels) == 0 &amp;&amp; len(ipkg.AllChannels.Versions) == 0 &amp;&amp; len(ipkg.AllChannels.Bundles) == 0 &amp;&amp; ipkg.Range == nil </span><span class="cov8" title="1">{
                // heads-only false, meaning "include the full package".
                if !ipkg.HeadsOnly </span><span class="cov8" title="1">{
                        outputModel[ipkg.Name] = newPkg
                        return nil
                }</span>
                // heads-only true, get the head of every channel in the package
                <span class="cov8" title="1">for _, c := range newPkg.Channels </span><span class="cov8" title="1">{
                        newCh := DiffIncludeChannel{
                                Name: c.Name,
                        }
                        ipkg.Channels = append(ipkg.Channels, newCh)
                }</span>
        }

        <span class="cov8" title="1">outputPkg := copyPackageNoChannels(newPkg)
        outputModel[outputPkg.Name] = outputPkg
        skipMissingBundleForChannels := map[string]bool{}
        if ipkg.Range != nil </span><span class="cov8" title="1">{
                if len(ipkg.Channels) != 0 </span><span class="cov0" title="0">{
                        for _, ich := range ipkg.Channels </span><span class="cov0" title="0">{
                                if ich.Range != nil </span><span class="cov0" title="0">{
                                        ierrs = append(ierrs, fmt.Errorf("[package=%q channel=%q] range setting is mutually exclusive between package and channel", newPkg.Name, ich.Name))
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Add package range setting to all existing channels if there is no
                        // channel setting in the config
                        for newChName := range newPkg.Channels </span><span class="cov8" title="1">{
                                ipkg.Channels = append(ipkg.Channels, DiffIncludeChannel{
                                        Name:  newChName,
                                        Range: ipkg.Range,
                                })
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Add all channels to ipkg.Channels if bundles or versions were specified to include across all channels.
                // skipMissingBundleForChannels's value for a channel will be true IFF at least one version is specified,
                // since some other channel may contain that version.
                if len(ipkg.AllChannels.Versions) != 0 || len(ipkg.AllChannels.Bundles) != 0 </span><span class="cov8" title="1">{
                        for newChName := range newPkg.Channels </span><span class="cov8" title="1">{
                                ipkg.Channels = append(ipkg.Channels, DiffIncludeChannel{
                                        Name:     newChName,
                                        Versions: ipkg.AllChannels.Versions,
                                        Bundles:  ipkg.AllChannels.Bundles,
                                })
                                skipMissingBundleForChannels[newChName] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, ich := range ipkg.Channels </span><span class="cov8" title="1">{
                newCh, pkgHasCh := newPkg.Channels[ich.Name]
                if !pkgHasCh </span><span class="cov0" title="0">{
                        ierrs = append(ierrs, fmt.Errorf("[package=%q channel=%q] channel does not exist in new model", newPkg.Name, ich.Name))
                        continue</span>
                }
                <span class="cov8" title="1">chLog := pkgLog.WithField("channel", newCh.Name)

                var bundles []*model.Bundle
                var head *model.Bundle
                var err error
                // No versions have been specified, but heads-only set to true, get the channel head only.
                switch </span>{
                case ipkg.HeadsOnly &amp;&amp; len(ich.Versions) == 0 &amp;&amp; len(ich.Bundles) == 0 &amp;&amp; ich.Range == nil:<span class="cov8" title="1">
                        head, err = newCh.Head()
                        bundles = append(bundles, head)</span>
                case ich.Range != nil:<span class="cov8" title="1">
                        bundles, err = getBundlesForRange(newCh, ich.Range)</span>
                default:<span class="cov8" title="1">
                        bundles, err = getBundlesForVersions(newCh, ich.Versions, ich.Bundles, chLog, skipMissingBundleForChannels[newCh.Name])</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        ierrs = append(ierrs, fmt.Errorf("[package=%q channel=%q] %v", newPkg.Name, newCh.Name, err))
                        continue</span>
                }

                <span class="cov8" title="1">outputCh := copyChannelNoBundles(newCh, outputPkg)
                outputPkg.Channels[outputCh.Name] = outputCh
                for _, b := range bundles </span><span class="cov8" title="1">{
                        tb := copyBundle(b, outputCh, outputPkg)
                        outputCh.Bundles[tb.Name] = tb
                }</span>
        }

        <span class="cov8" title="1">return ierrs</span>
}

// getBundlesForVersions returns all bundles matching a version in vers
// and their upgrade graph(s) to ch.Head().
// If skipMissingBundles is true, bundle names and versions not satisfied by bundles in ch
// will not result in errors.
func getBundlesForVersions(ch *model.Channel, vers []semver.Version, names []string, logger *logrus.Entry, skipMissingBundles bool) (bundles []*model.Bundle, err error) <span class="cov8" title="1">{

        // Short circuit when no versions were specified, meaning "include the whole channel".
        if len(vers) == 0 </span><span class="cov8" title="1">{
                for _, b := range ch.Bundles </span><span class="cov8" title="1">{
                        bundles = append(bundles, b)
                }</span>
                <span class="cov8" title="1">return bundles, nil</span>
        }

        // Add every bundle with a specified bundle name or directly satisfying a bundle version to bundles.
        <span class="cov8" title="1">versionsToInclude := make(map[string]struct{}, len(vers))
        for _, ver := range vers </span><span class="cov8" title="1">{
                versionsToInclude[ver.String()] = struct{}{}
        }</span>
        <span class="cov8" title="1">namesToInclude := make(map[string]struct{}, len(vers))
        for _, name := range names </span><span class="cov0" title="0">{
                namesToInclude[name] = struct{}{}
        }</span>
        <span class="cov8" title="1">for _, b := range ch.Bundles </span><span class="cov8" title="1">{
                // OCPBUGS-588 - the postfix i.e '-0' causes a miss in the lookup
                // as an  example we have this in the 'vers' variable 2.2.0
                // however the b.Version.String() could return 2.2.0-0
                // the fix is to remove the -0 postfix to ensure the bundle is included
                trimVer := strings.Split(b.Version.String(), "-")[0]
                _, trimmedVersionedBundle := versionsToInclude[trimVer]
                _, includeVersionedBundle := versionsToInclude[b.Version.String()]
                _, includeNamedBundle := namesToInclude[b.Name]
                if includeVersionedBundle || includeNamedBundle || trimmedVersionedBundle </span><span class="cov8" title="1">{
                        bundles = append(bundles, b)
                }</span>
        }

        // Some version was not satisfied by this channel.
        <span class="cov8" title="1">if len(bundles) != len(versionsToInclude)+len(namesToInclude) &amp;&amp; !skipMissingBundles </span><span class="cov0" title="0">{
                for _, b := range bundles </span><span class="cov0" title="0">{
                        delete(versionsToInclude, b.Version.String())
                        delete(namesToInclude, b.Name)
                }</span>
                <span class="cov0" title="0">var verStrs, nameStrs []string
                for verStr := range versionsToInclude </span><span class="cov0" title="0">{
                        verStrs = append(verStrs, verStr)
                }</span>
                <span class="cov0" title="0">for nameStr := range namesToInclude </span><span class="cov0" title="0">{
                        nameStrs = append(nameStrs, nameStr)
                }</span>
                <span class="cov0" title="0">sb := strings.Builder{}
                if len(verStrs) != 0 </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("versions=%+q ", verStrs))
                }</span>
                <span class="cov0" title="0">if len(nameStrs) != 0 </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("names=%+q", nameStrs))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("bundles do not exist in channel: %s", strings.TrimSpace(sb.String()))</span>
        }

        <span class="cov8" title="1">bundles, err = fillUpgradeGraph(ch, bundles, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bundles, nil</span>
}

// getBundlesForRange returns all bundles matching the version range in vers
// If the range is nil, return all bundles in the channel
func getBundlesForRange(ch *model.Channel, vers semver.Range) (bundles []*model.Bundle, err error) <span class="cov8" title="1">{
        // Short circuit when an empty range was specified, meaning "include the whole channel"
        if vers == nil </span><span class="cov0" title="0">{
                for _, b := range ch.Bundles </span><span class="cov0" title="0">{
                        bundles = append(bundles, b)
                }</span>
                <span class="cov0" title="0">return bundles, nil</span>
        }

        <span class="cov8" title="1">for _, b := range ch.Bundles </span><span class="cov8" title="1">{
                v, err := semver.Parse(b.Version.String())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to parse bunble version: %s", err.Error())
                }</span>
                <span class="cov8" title="1">if vers(v) </span><span class="cov8" title="1">{
                        bundles = append(bundles, b)
                }</span>
        }

        <span class="cov8" title="1">return bundles, nil</span>
}

// fillUpgradeGraph fills in the upgrade graph between each bundle and head.
// Regardless of semver order, this step needs to be performed
// for each included bundle because there might be leaf nodes
// in the upgrade graph for a particular version not captured
// by any other fill due to skips not being honored here.
func fillUpgradeGraph(ch *model.Channel, bundles []*model.Bundle, logger *logrus.Entry) (bd []*model.Bundle, err error) <span class="cov8" title="1">{
        head, err := ch.Head()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">graph := makeUpgradeGraph(ch)
        bundleSet := map[string]*model.Bundle{}
        for _, ib := range bundles </span><span class="cov8" title="1">{
                if _, addedBundle := bundleSet[ib.Name]; addedBundle </span><span class="cov0" title="0">{
                        // A prior graph traverse already included this bundle.
                        continue</span>
                }
                <span class="cov8" title="1">intersectingBundles, intersectionFound := findIntersectingBundles(ch, ib, head, graph)
                if !intersectionFound </span><span class="cov0" title="0">{
                        logger.Debugf("channel head %q not reachable from bundle %q, adding without upgrade graph", head.Name, ib.Name)
                        bundleSet[ib.Name] = ib
                }</span>

                <span class="cov8" title="1">for _, rb := range intersectingBundles </span><span class="cov8" title="1">{
                        bundleSet[rb.Name] = rb
                }</span>
        }

        <span class="cov8" title="1">for _, b := range bundleSet </span><span class="cov8" title="1">{
                bundles = append(bundles, b)
        }</span>
        <span class="cov8" title="1">return bundles, nil</span>
}

// makeUpgradeGraph creates a DAG of bundles with map key Bundle.Replaces.
func makeUpgradeGraph(ch *model.Channel) map[string][]*model.Bundle <span class="cov8" title="1">{
        graph := map[string][]*model.Bundle{}
        for _, b := range ch.Bundles </span><span class="cov8" title="1">{
                if b.Replaces != "" </span><span class="cov8" title="1">{
                        graph[b.Replaces] = append(graph[b.Replaces], b)
                }</span>
        }
        <span class="cov8" title="1">return graph</span>
}

// findIntersectingBundles finds the intersecting bundle of start and end in the
// replaces upgrade graph graph by traversing down to the lowest graph node,
// then returns every bundle higher than the intersection. It is possible
// to find no intersection; this should only happen when start and end
// are not part of the same upgrade graph.
// Output bundle order is not guaranteed.
// Precondition: start must be a bundle in ch.
// Precondition: end must be ch's head.
func findIntersectingBundles(ch *model.Channel, start, end *model.Bundle, graph map[string][]*model.Bundle) ([]*model.Bundle, bool) <span class="cov8" title="1">{
        // The intersecting set is equal to end if start is end.
        if start.Name == end.Name </span><span class="cov8" title="1">{
                return []*model.Bundle{end}, true
        }</span>

        // Construct start's replaces chain for comparison against end's.
        <span class="cov8" title="1">startChain := map[string]*model.Bundle{start.Name: nil}
        for curr := start; curr != nil &amp;&amp; curr.Replaces != ""; curr = ch.Bundles[curr.Replaces] </span><span class="cov8" title="1">{
                startChain[curr.Replaces] = curr
        }</span>

        // Trace end's replaces chain until it intersects with start's, or the root is reached.
        <span class="cov8" title="1">var intersection string
        if _, inChain := startChain[end.Name]; inChain </span><span class="cov0" title="0">{
                intersection = end.Name
        }</span> else<span class="cov8" title="1"> {
                for curr := end; curr != nil &amp;&amp; curr.Replaces != ""; curr = ch.Bundles[curr.Replaces] </span><span class="cov8" title="1">{
                        if _, inChain := startChain[curr.Replaces]; inChain </span><span class="cov8" title="1">{
                                intersection = curr.Replaces
                                break</span>
                        }
                }
        }

        // No intersection is found, delegate behavior to caller.
        <span class="cov8" title="1">if intersection == "" </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // Find all bundles that replace the intersection via BFS,
        // i.e. the set of bundles that fill the update graph between start and end.
        <span class="cov8" title="1">replacesIntersection := graph[intersection]
        replacesSet := map[string]*model.Bundle{}
        for _, b := range replacesIntersection </span><span class="cov8" title="1">{
                currName := ""
                for next := []*model.Bundle{b}; len(next) &gt; 0; next = next[1:] </span><span class="cov8" title="1">{
                        currName = next[0].Name
                        if _, hasReplaces := replacesSet[currName]; !hasReplaces </span><span class="cov8" title="1">{
                                replacers := graph[currName]
                                next = append(next, replacers...)
                                replacesSet[currName] = ch.Bundles[currName]
                        }</span>
                }
        }

        // Remove every bundle between start and intersection exclusively,
        // since these bundles must already exist in the destination channel.
        <span class="cov8" title="1">for rep := start; rep != nil &amp;&amp; rep.Name != intersection; rep = ch.Bundles[rep.Replaces] </span><span class="cov8" title="1">{
                delete(replacesSet, rep.Name)
        }</span>

        // Ensure both start and end are added to the output.
        <span class="cov8" title="1">replacesSet[start.Name] = start
        replacesSet[end.Name] = end
        var intersectingBundles []*model.Bundle
        for _, b := range replacesSet </span><span class="cov8" title="1">{
                intersectingBundles = append(intersectingBundles, b)
        }</span>
        <span class="cov8" title="1">return intersectingBundles, true</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
